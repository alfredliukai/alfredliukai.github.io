<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BloomFilter小结</title>
    <url>/2021/04/15/BloomFilter%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>布隆过滤器（Bloom Filter）是由布隆（Burton Howard Bloom）在1970年提出的。它实际上是由一个很长的二进制向量（位向量）和一系列随机映射函数组成，布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率（假正例False positives，即Bloom Filter报告某一元素存在于某集合中，但是实际上该元素并不在集合中）和删除困难，但是没有识别错误的情形（即假反例False negatives，如果某个元素确实没有在该集合中，那么Bloom Filter 是不会报告该元素存在于集合中的，所以不会漏报）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。</p>
<p>如果想判断一个元素是不是在一个集合里，一般想到的是将所有元素保存起来，然后通过比较确定。链表，树等等数据结构都是这种思路. 但是随着集合中元素的增加，我们需要的存储空间越来越大，检索速度也越来越慢。不过世界上还有一种叫作散列表（又叫哈希表，Hash table）的数据结构。它可以通过一个Hash函数将一个元素映射成一个位阵列（Bit Array）中的一个点。这样一来，我们只要看看这个点是不是 1 就知道可以集合中有没有它了。这就是布隆过滤器的基本思想。</p>
<p>Hash面临的问题就是冲突。假设 Hash 函数是随机的，如果我们的位阵列长度为 m 个点，那么如果我们想将冲突率降低到例如 1%, 这个散列表就只能容纳 m/100 个元素。显然这就不叫空间有效了（Space-efficient）。解决方法也简单，就是使用多个 Hash函数，如果它们有一个说元素不在集合中，那肯定就不在(必须对应位置上都是1)。如果它们都说在，有很小的可能性该元素不在。</p>
<p>BloomFilter的几个重要参数：</p>
<p>插入集合的元素个数n，BloomFilter位数组的长度m，hash函数个数k。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>布隆过滤器维护一个N位的位数组，其中N是位数组的大小。它还有另一个参数k，表示使用哈希函数的个数。这些哈希函数用来设置位数组的值。当往过滤器中插入元素x时，h1(x), h2(x), …, hk(x)所对应索引位置的值被置“1”，索引值由各个哈希函数计算得到。注意，如果我们增加哈希函数的数量，误报的概率会趋近于0.但是，插入和查找的时间开销更大，布隆过滤器的容量也会减小。</p>
<p>为了用布隆过滤器检验元素是否存在，我们需要校验是否所有的位置都被置“1”，与我们插入元素的过程非常相似。如果所有位置都被置“1”，那也就意味着该元素很有可能存在于布隆过滤器中。若有位置未被置“1”，那该元素一定不存在。</p>
<p><strong>记录元素</strong></p>
<p>下面我们看一下向Bloom Filter插入字符串的具体过，就是把这个字符串str经过K个不同的hash函数计算得到的结果h1、h2、、、hK。然后在BitArrray的第h1、h2、、、hK的位置上置1。<br><img src="/2021/04/15/BloomFilter小结/bloom1.png" alt="avatar"></p>
<p><strong>判断元素</strong></p>
<p>那么如何判断一个字符串是否存在呢</p>
<p>把这个字符串经过K个hash函数计算得到h1、h2、、、hK，然后逐个判断BitArray的第h1、h2、、、hK个位置是否是1</p>
<p><strong>影响误判率因素</strong></p>
<p>只要降低Bloom Filter误判率，让它达到你可以接受的程度。BloomFilter当然就是你的利器了。影响它的因素有哪些呢？</p>
<ol>
<li>BitArray的位数M</li>
<li>hash函数的数量K</li>
<li>每一个不同的hash函数的质量</li>
</ol>
<p><strong>优点：</strong></p>
<p>1.全量存储但是不存储元素本身，在某些对保密要求非常严格的场合有优势<br>2.空间高效率<br>3.插入/查询时间都是常数O(k),远远超过一般的算法</p>
<p><strong>缺点：</strong></p>
<ol>
<li>存在误算率(False Positive)，随着存入的元素数量增加，误算率随之增加布隆过滤器能确保某个元素“肯定不存在”，但是对于一些元素的判断会是“可能存在”</li>
<li>一般情况下不能从布隆过滤器中删除元素</li>
<li>数组长度以及hash函数个数确定过程复杂</li>
<li>无法得到元素本身</li>
<li>布隆过滤器并不会保存插入元素的内容，只能检索某个元素是否存在</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import BitVector as BitVector</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SimpleHash(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, cap, seed):</span><br><span class="line">        self.cap = cap</span><br><span class="line">        self.seed = seed</span><br><span class="line"></span><br><span class="line">    def hash(self, value):</span><br><span class="line">        ret = 0</span><br><span class="line">        for i in range(len(value)):</span><br><span class="line">            ret += self.seed * ret + ord(value[i])</span><br><span class="line">        return (self.cap - 1) &amp; ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BloomFilter(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, BIT_SIZE=1 &lt;&lt; 25):</span><br><span class="line">        self.BIT_SIZE = 1 &lt;&lt; 25</span><br><span class="line">        self.seeds = [5, 7, 11, 13, 31, 37, 61]</span><br><span class="line">        self.bitset = BitVector.BitVector(size=self.BIT_SIZE)</span><br><span class="line">        self.hashFunc = []</span><br><span class="line"></span><br><span class="line">        for i in range(len(self.seeds)):</span><br><span class="line">            self.hashFunc.append(SimpleHash(self.BIT_SIZE, self.seeds[i]))</span><br><span class="line">        print(self.hashFunc)</span><br><span class="line"></span><br><span class="line">    def insert(self, value):</span><br><span class="line">        for f in self.hashFunc:</span><br><span class="line">            loc = f.hash(value)</span><br><span class="line">            self.bitset[loc] = 1</span><br><span class="line">        print(self.bitset)</span><br><span class="line"></span><br><span class="line">    def is_contains(self, value):</span><br><span class="line">        if value == None:</span><br><span class="line">            return False</span><br><span class="line">        ret = True</span><br><span class="line"></span><br><span class="line">        for f in self.hashFunc:</span><br><span class="line">            loc = f.hash(value)</span><br><span class="line">            ret = ret &amp; self.bitset[loc]</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pybloom_live import ScalableBloomFilter,BloomFilter</span><br><span class="line"> </span><br><span class="line"># 可自动伸缩的布隆过滤器</span><br><span class="line">bloom = ScalableBloomFilter(initial_capacity=100,error_rate=0.001)</span><br><span class="line"> </span><br><span class="line"># 添加内容</span><br><span class="line">bloom.add(&apos;daqi&apos;)</span><br><span class="line">print(&apos;daqi&apos;in bloom)</span><br><span class="line"> </span><br><span class="line"># 定长的布隆过滤器</span><br><span class="line">bloom1 = BloomFilter(capacity=10000)</span><br><span class="line">bloom1.add(&apos;daqi&apos;)</span><br><span class="line">print(&apos;daqi&apos;in bloom1)</span><br></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://www.cnblogs.com/-wenli/p/10886182.html" target="_blank" rel="noopener">https://www.cnblogs.com/-wenli/p/10886182.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/165494112" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/165494112</a></li>
<li><a href="https://blog.csdn.net/TENLIU2099/article/details/78298778" target="_blank" rel="noopener">https://blog.csdn.net/TENLIU2099/article/details/78298778</a></li>
<li><a href="https://www.cnblogs.com/i-love-python/p/11537720.html" target="_blank" rel="noopener">https://www.cnblogs.com/i-love-python/p/11537720.html</a></li>
<li><a href="https://www.cnblogs.com/i-love-python/p/11537720.html" target="_blank" rel="noopener">https://www.cnblogs.com/i-love-python/p/11537720.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CRIT Supervisor running as root问题排查</title>
    <url>/2021/06/10/CRIT-Supervisor-running-as-root%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>项目中遇到如下问题:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2021-06-10 17:58:59,776 CRIT Supervisor running as root (no user in config file)</span><br><span class="line">2021-06-10 17:58:59,777 WARN Included extra file &quot;/etc/supervisord.d/aaa.ini&quot; during parsing</span><br><span class="line">2021-06-10 17:58:59,777 INFO Increased RLIMIT_NOFILE limit to 32768</span><br></pre></td></tr></table></figure></p>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><p>参考文章大致判断流程如下</p>
<ol>
<li>单个进程打开 fb 过多    /etc/security/limits.conf    修改文件或使用 prlimit 命令</li>
<li>操作系统打开的 fb 过多    /proc/sys/fs/file-max    直接 echo 写入即可</li>
<li>Systemd 对进程限制    LimitNOFILE=20480000    通常在 /etc/systemd/system/ 目录下</li>
<li>Supervisor 对进程限制    minfds    通常在 /etc/supervisor/conf.d/ 目录下</li>
<li>Inotify 达到上限    sysctl -p 或 /etc/sysctl.conf    该机制受到 2 个内核参数的影响</li>
</ol>
<p>因此，修改配置文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user=root</span><br><span class="line">minfds=100000</span><br></pre></td></tr></table></figure></p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li><a href="https://github.com/Supervisor/supervisor/issues/308" target="_blank" rel="noopener">https://github.com/Supervisor/supervisor/issues/308</a></li>
<li><a href="https://www.escapelife.site/posts/5457f758.html" target="_blank" rel="noopener">https://www.escapelife.site/posts/5457f758.html</a></li>
<li><a href="https://www.cnblogs.com/orzs/p/12715841.html" target="_blank" rel="noopener">https://www.cnblogs.com/orzs/p/12715841.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>@ConstructorProperties的作用</title>
    <url>/2020/05/05/ConstructorProperties%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h3 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h3><p>spring中@ConstructorProperties的作用,以具体实例来解释：<br>下面是写的HelloService和NewHello的Bean<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloService &#123;</span><br><span class="line">    public String sayHello()&#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import java.beans.ConstructorProperties;</span><br><span class="line"></span><br><span class="line">public class NewHello &#123;</span><br><span class="line"></span><br><span class="line">    private HelloService service;</span><br><span class="line"></span><br><span class="line">    private String hello;</span><br><span class="line"></span><br><span class="line">    //@ConstructorProperties(&#123;&quot;service&quot;,&quot;hello&quot;&#125;)</span><br><span class="line">    public NewHello(HelloService service, String hello) &#123;</span><br><span class="line">        this.service = service;</span><br><span class="line">        this.hello = hello;</span><br><span class="line">    &#125;</span><br><span class="line">    public void sayNewHello()&#123;</span><br><span class="line">        System.out.println(&quot;new hello&quot;);</span><br><span class="line">        System.out.println(service.sayHello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的xml文件中的配置为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;helloService&quot; class=&quot;com.lyk.service.HelloService&quot;/&gt;</span><br><span class="line"></span><br><span class="line"> &lt;bean id=&quot;newHello&quot; class=&quot;com.lyk.service.NewHello&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;hello&quot; value=&quot;hello&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;service&quot; ref=&quot;helloService&quot;/&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>使用@ConstructorProperties注解时，可以通过制定变量名来改变xml文件中constructor-arg的 name名字，比如<br>@ConstructorProperties({“service1”,”hello1”})，在xml文件中要对应的配置为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;newHello&quot; class=&quot;com.lyk.service.NewHello&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;hello1&quot; value=&quot;hello&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;service1&quot; ref=&quot;helloService&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://blog.csdn.net/wslyk606/article/details/78861999" target="_blank" rel="noopener">https://blog.csdn.net/wslyk606/article/details/78861999</a></li>
</ol>
]]></content>
      <tags>
        <tag>spring</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS与NS、NS记录</title>
    <url>/2021/04/01/DNS%E4%B8%8ENS%E3%80%81NS%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>DNS：人们习惯记忆域名，但机器间互相只认IP地址，域名与IP地址之间是一一对应的，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，整个过程是自动进行的。 当你的网站制作完成后上传到你的虚拟主机时，你可以直接在浏览器中输入IP地址浏览你的网站，也可以输入域名查询你的网站，虽然得出的内容是一样的但是调用的过程不一样，输入IP地址是直接从主机上调用内容，输入域名是通过域名解析服务器指向对应的主机的IP地址，再从主机调用网站的内容。</p>
<p>资源记录是用于答复DNS客户端请求的DNS数据库记录，每一个DNS服务器包含了它所管理的DNS命名空间的所有资源记录。资源记录包含和特定主机有关的信息，如IP地址、提供服务的类型等等。常见的资源记录类型有：SOA（起始授权结构）、A（主机）、NS（名称服务器）、CNAME（别名）和MX（邮件交换器）。</p>
<p>A记录是名称解析的重要记录，它用于将特定的主机名映射到对应主机的IP地址上。你可以在DNS服务器中手动创建或通过DNS客户端动态更新来创建。</p>
<p>NS记录此记录指定负责此DNS区域的权威名称服务器。</p>
<p>A记录和NS记录的区别是，A记录直接给出目的IP，NS记录将DNS解析任务交给特定的服务器，NS记录中记录的IP即为该特定服务器的IP地址。</p>
<p><strong>Name Server的作用：</strong></p>
<p>   比如说一个网通ADSL接入的用户想访问<a href="http://www.263.sh.cn，实际上首先是用户先把这个请求反馈给本地电脑所使用的DNS，本地电脑的DNS会先查询在自己的Cache里面是否有www.263.sh.cn的A记录值，如果有，直接反馈给本地电脑，由本地电脑直接连接www.263.sh.cn对应的主机来获取对应的数据；如果Cache里面没有www.263.sh.cn的A记录值，则按照规则企业邮箱一样，网通的DNS会连接.根服务器，在根服务器上面查询.net的根服务器，再连接.net的根服务器来查询263.net的Name" target="_blank" rel="noopener">http://www.263.sh.cn，实际上首先是用户先把这个请求反馈给本地电脑所使用的DNS，本地电脑的DNS会先查询在自己的Cache里面是否有www.263.sh.cn的A记录值，如果有，直接反馈给本地电脑，由本地电脑直接连接www.263.sh.cn对应的主机来获取对应的数据；如果Cache里面没有www.263.sh.cn的A记录值，则按照规则企业邮箱一样，网通的DNS会连接.根服务器，在根服务器上面查询.net的根服务器，再连接.net的根服务器来查询263.net的Name</a> server，最终由用户所使用的DNS和263.net的Name server连接，来获取<a href="http://www.263.sh.cn的A记录值。（注：Cache是一块缓存区域，Cache里面域名记录值的保留时间是由域名本身记录值设定的生存周期来决定的，超过生存周期后，域名的记录值会自动从ISP" target="_blank" rel="noopener">www.263.sh.cn的A记录值。（注：Cache是一块缓存区域，Cache里面域名记录值的保留时间是由域名本身记录值设定的生存周期来决定的，超过生存周期后，域名的记录值会自动从ISP</a> DNS的Cache里面清除，如果有用户再访问该记录，需要按上述过程重新获取记录值）。</p>
<p><strong>NS记录</strong><br>   1、NS记录是域名DNS服务器里面的一种记录类型，可以针对每个域名或子域名来设定他的NS记录，当设定后，相当于把他的解析权交给了对应的DNS。<br>   2、NS记录的用途：CDN或负载均衡时使用。</p>
]]></content>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea创建maven项目问题解决</title>
    <url>/2020/05/05/Idea%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h3 id="困扰"><a href="#困扰" class="headerlink" title="困扰"></a>困扰</h3><p>Intellij idea是一款非常强大的编辑器，可以很方便地帮我们创建maven项目，有用过的同学应该都深有体会，但我们经常会遇到一个困扰，那就是用idea创建maven项目时，速度很慢，往往需要好几分钟的时间，有时甚至会卡住，主要原因是创建maven项目时默认是下载求网络上的一个文件archetype-catalog.xml，该文件的大小有5-6M，下载的速度很慢，导致创建过程也变得很慢。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>解决办法有三种，并且都需要对maven的VM Options参数做配置。</p>
<p><strong>方法一</strong></p>
<p>在maven的VM Options加上-DarchetypeCatalog=internal参数，步骤如下：</p>
<p>打开idea的启动界面，进入全局设置</p>
<p><img src="/2020/05/05/Idea创建maven项目问题解决/idea1.png" alt="avatar"></p>
<p>搜索maven，点击Runner一栏，在VM Options输入框里写上 “-DarchetypeCatalog=local”，</p>
<p><img src="/2020/05/05/Idea创建maven项目问题解决/idea2.png" alt="avatar"></p>
<p>确定后，再新建maven项目，就能发现项目很快就创建完成。</p>
<p><strong>方法二</strong></p>
<p>下载archetype-catalog.xml文件，在maven的VM Options加上-DarchetypeCatalog=local</p>
<p>默认情况下，创建maven项目是从网络下载catalog文件，我们可以将catalog文件下到本地，然后通过设置archetype的使用方式为local，这样就不用每次都从网络上下载了。</p>
<p>步骤：</p>
<p>1、下载archetype-catalog.xml文件到本地。</p>
<p>文件的位置是<a href="http://repo1.maven.org/maven2/archetype-catalog.xml" target="_blank" rel="noopener">http://repo1.maven.org/maven2/archetype-catalog.xml</a></p>
<p>2、下载后放到本地仓库中对应的位置</p>
<p>maven本地仓库的位置与settting.xml中的配置有关，例如我的setting.xml配置仓库的位置是：D:\apache-maven-3.6.0\repository<br><img src="/2020/05/05/Idea创建maven项目问题解决/idea3.png" alt="avatar"></p>
<p>那么catalog文件就可以放在 D:\apache-maven-3.6.0\repository\org\apache\maven\archetype\archetype-catalog\3.0.1下<br><img src="/2020/05/05/Idea创建maven项目问题解决/idea4.png" alt="avatar"></p>
<p>如果setting.xml没有配置仓库位置，那么就放到默认本地仓库下面对应的位置即可。本地仓库的默认位置是：Default: ${user.home}/.m2/repository，例如笔者的计算机用户名是Administrator，仓库位置就是 C:\Users\Administrator.m2\repository。</p>
<p>3、修改maven的VM Options参数</p>
<p>跟之前方法的步骤一样，打开全局设置中的maven设置栏，然后在VM Options输入框中填入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-DarchetypeCatalog=local</span><br></pre></td></tr></table></figure>
<p>这样maven每次就会从本地获取catalog文件，创建项目时就不用等那么久了。</p>
<p><strong>方法三</strong></p>
<p>新建maven项目的时候添加上参数archetypeCatalog，值为local，或者是如果本地仓库里有了catalog文件，参数值也可以为local<br><img src="/2020/05/05/Idea创建maven项目问题解决/idea5.png" alt="avatar"></p>
<p>确定之后，maven项目就能很快的建成了。</p>
<p><strong>心得</strong><br>最后提点建议，读者们可以先尝试前两种方案，因为一劳永逸，不用创建项目的时候都配置参数，如果行不通的话再采取第三种方案好了。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li>cnblogs.com/yeya/p/10314358.html  </li>
</ol>
]]></content>
      <tags>
        <tag>工程工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的loop设备</title>
    <url>/2021/01/26/Linux%E7%9A%84loop%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h3 id="loop设备介绍"><a href="#loop设备介绍" class="headerlink" title="loop设备介绍"></a>loop设备介绍</h3><p>在类 UNIX 系统里，loop 设备是一种伪设备(pseudo-device)，或者也可以说是仿真设备。它能使我们像块设备一样访问一个文件。</p>
<p>在使用之前，一个 loop 设备必须要和一个文件进行连接。这种结合方式给用户提供了一个替代块特殊文件的接口。因此，如果这个文件包含有一个完整的文件系统，那么这个文件就可以像一个磁盘设备一样被 mount 起来。</p>
<p>上面说的文件格式，我们经常见到的是 CD 或 DVD 的 ISO 光盘镜像文件或者是软盘(硬盘)的 *.img 镜像文件。通过这种 loop mount (回环mount)的方式，这些镜像文件就可以被 mount 到当前文件系统的一个目录下。</p>
<p>至此，顺便可以再理解一下 loop 之含义：对于第一层文件系统，它直接安装在我们计算机的物理设备之上；而对于这种被 mount 起来的镜像文件(它也包含有文件系统)，它是建立在第一层文件系统之上，这样看来，它就像是在第一层文件系统之上再绕了一圈的文件系统，所以称为 loop。</p>
<h3 id="losetup命令"><a href="#losetup命令" class="headerlink" title="losetup命令"></a>losetup命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">losetup [ -e encryption ] [ -o offset ] loop_device file</span><br><span class="line">losetup [ -d ] loop_device</span><br></pre></td></tr></table></figure>
<p>说明：<br>此命令用来设置循环设备。循环设备可把文件虚拟成块设备，籍此来模拟整个文件系统，让用户得以将其视为硬盘驱动器，光驱或软驱等设备，并挂入当作目录来使用。<br>上面，命令格式中的选项与参数名：<br>-e 表示加密的方式<br>-o 设置数据偏移量<br>-d 卸载设备</p>
<p>loop_device 循环设备名，在 linux 下如 /dev/loop0 , /dev/loop1 等。<br>file 要与循环设备相关联的文件名，这个往往是一个磁盘镜象文件，如 *.img</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 创建空的磁盘镜像文件，这里创建一个1.44M的软盘</span><br><span class="line">dd if=/dev/zero of=floppy.img bs=512 count=2880</span><br><span class="line"></span><br><span class="line">2. 使用 losetup将磁盘镜像文件虚拟成快设备</span><br><span class="line">losetup /dev/loop1 floppy.img</span><br><span class="line"></span><br><span class="line">3. 挂载块设备</span><br><span class="line">mount /dev/loop0 /tmp</span><br><span class="line">经过上面的三步之后，我们就可以通过/tmp目录，像访问真实快设备一样来访问磁盘镜像文件floppy.img</span><br><span class="line"></span><br><span class="line">4. 卸载loop设备</span><br><span class="line">umount /tmp</span><br><span class="line">losetup -d /dev/loop1</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统/dev/mapper目录</title>
    <url>/2021/01/26/Linux%E7%B3%BB%E7%BB%9F-dev-mapper%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p> Linux系统的一般的文件系统名称类似于/dev/sda1或/dev/hda1，但是今天在进行系统维护的时候，利用df -h 命令敲出了/dev/mapper/VolGroup-lv_root和/dev/mapper/Volume-lv_home两个文件系统名，不解，在网上查找资料后，在此浅谈/dev/mapper目录。</p>
<h3 id="理解Linux系统的Device-mapper机制"><a href="#理解Linux系统的Device-mapper机制" class="headerlink" title="理解Linux系统的Device mapper机制"></a>理解Linux系统的Device mapper机制</h3><p>Device mapper是Linux2.6内核中提供的一种从逻辑设备到物理设备的映射机制，在该机制下，用户能够很方便的根据自己的需要实现对存储资源的管理。在具体管理时需要用到Linux下的逻辑卷管理器，当前比较流行的逻辑卷管理器有 LVM2（Linux Volume Manager 2 version)、EVMS(Enterprise Volume Management System)、dmraid(Device Mapper Raid Tool)等。</p>
<p>想要详细了解Device mapper机制，可参考博文 <a href="http://blog.sina.com.cn/s/blog_6237dcca0100hnwb.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6237dcca0100hnwb.html</a> ，此处不再赘述。</p>
<h3 id="dev-mapper目录的解释"><a href="#dev-mapper目录的解释" class="headerlink" title="/dev/mapper目录的解释"></a>/dev/mapper目录的解释</h3><p>为了方便叙述，假设一台服务器有三块硬盘分别为a，b，c，每块硬盘的容量为1T。在安装Linux的时候，先根据系统及自身的需要建立基本的分区，假设对硬盘a进行了分区，分出去了0.1T的空间挂载在/boot目录下，其他硬盘未进行分区。系统利用Device mapper机制建立了一个卷组（volume group，VG），你可以把VG当做一个资源池来看待，最后在VG上面再创建逻辑卷（logical volume，LV）。若要将硬盘a的剩余空间、硬盘b和硬盘c都加入到VG中，则硬盘a的剩余空间首先会被系统建立为一个物理卷（physical volume，PV），并且这个物理卷的大小就是0.9T，之后硬盘a的剩余的空间、硬盘b和硬盘c以PV的身份加入到VG这个资源池中，然后你需要多大的空间，就可以从VG中划出多大的空间（当然最大不能超过VG的容量）。比如此时池中的空间就是2.9T，此时你就可以建立一个1T以上的空间出来，而不像以前最大的容量空间只能为1T。</p>
<p>/dev/mapper/Volume-lv_root的意思是说你有一个VG (volume group卷组)叫作Volume, 这个Volume里面有一个LV叫作lv_root。其实这个/dev/mapper/Volume-lv_root文件是一个连接文件，是连接到/dev/dm-0的，你可以用命令ll /dev/mapper/Volume-lv_root进行查看。</p>
<p>其实在系统里/dev/Volume/lv_root 和 /dev/mapper/Volume-lv_root以及/dev/dm-0都是一个东西，都可当作一个分区来对待。</p>
<p>若要了解硬盘的具体情况，可通过fdisk或者pvdisplay命令进行查看。</p>
<p>若你想要重装系统到/dev/sda下，且安装时有些东西不想被格式化想转移到/dev/sdb下，但此时/dev/sda和/dev/sdb被放到VG中了，那该如何解决该问题呢？这种情况下，由于此时根本没办法确定数据在哪一个硬盘上,因为这两个硬盘就如同加到池里，被Device mapper管理，所以解决方案就是再建个逻辑卷出来，把数据移到新的卷里，这样你就可以重装系统时只删掉之前分区里的东西，而新的卷里的东西不动，就不会丢失了。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx启用proxy_buffer缓冲</title>
    <url>/2021/03/19/Nginx%E5%90%AF%E7%94%A8proxy-buffer%E7%BC%93%E5%86%B2/</url>
    <content><![CDATA[<h3 id="buffer-是什么"><a href="#buffer-是什么" class="headerlink" title="buffer 是什么"></a>buffer 是什么</h3><p>buffer ，即缓冲区，它在 Nginx 上发挥的作用就是 启用一个缓冲区，先在这个缓冲区内进行存储，再把数据发送出去 。和在线观看视频有点类似，先把视频文件缓冲一部分到本地再开始播放。</p>
<p>若没有 buffer，数据将会直接从 Nginx 传输到客户端。假设如果客户端的加载速度足够快，你可以直接把 buffer 关掉，让数据尽可能快地到达客户端。</p>
<p>而使用 buffer，Nginx 将会临时存储后端 response 到缓冲区，然后慢慢把数据发送到客户端。启用 buffer 的好处在于可以把数据一次性地发送给目标，相较于即时传输可以节约出这部分带宽。</p>
<p>顺带一提，Nginx 全局配置中的 tcp_nopush 的作用就是 数据包会累计到一定大小之后才会发送 。而 tcp_nodelay 是尽快发送数据，所以若你启用了 buffer，建议关闭 tcp_nodelay。</p>
<p>下面总结下 nginx buffer 设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_buffer_size 4k;</span><br><span class="line">proxy_buffering on;</span><br><span class="line">proxy_buffers 4 4k;</span><br><span class="line">proxy_busy_buffers_size 8k;</span><br><span class="line">proxy_max_temp_file_size 1024m;</span><br></pre></td></tr></table></figure>
<p>首先，这些参数都是针对每一个http request ，不是全局的。</p>
<p><strong>proxy_buffer 的配置</strong></p>
<p>proxy_buffer 是用于 proxy 模式（一般也可称为反向代理）的 buffer 配置。Nginx 有另外一种适用于 server 模式的 buffer 配置，这里本帖不做介绍。</p>
<p>proxy_buffer 包括了以下配置项：</p>
<p>需注意，以下指定的数值都是针对每一个 http request 的上限，而不是对于整个 buffer 区指定的上限。  </p>
<p><strong>proxy_buffering</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_buffering on;</span><br></pre></td></tr></table></figure>
<p>在 proxy_buffering 开启的时候，proxy_buffers 和 proxy_busy_buffers_size 才会起作用。</p>
<p><strong>proxy_buffers</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_buffers 4 8k;</span><br></pre></td></tr></table></figure></p>
<p>指定一个 request 的 buffer 的数量和大小。</p>
<p><strong>proxy_buffer_size</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_buffer_size 4k;</span><br></pre></td></tr></table></figure>
<p>指定后端 response 的 buffer 的大小。它是来自后端 response 的一部分，它包含 Headers，从 response 分离出来。它仅用于限定 headers 的 buffer 区，所以它的值比 proxy_buffers 更低。</p>
<p>proxy_buffer_size 有一点特殊在于，无论 proxy_buffering 是否开启，proxy_buffer_size 都会起作用。</p>
<p><strong>proxy_busy_buffers_size</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_busy_buffers_size 12k;</span><br></pre></td></tr></table></figure>
<p>忙时 buffer 的最大值。一个客户端一次只能从一个 buffer 中读取数据的同时，剩下的 buffer 会被放到队列中，等待发送到客户端，这个 directive 指定在这个状态下的 buffer 的大小。</p>
<ul>
<li>如果 proxy_buffers 关闭<br>Nginx不会尝试获取到后端服务器所有响应数据之后才返回给客户端，Nginx 会尽快把数据传给客户端，在数据传完之前，Nginx 接收到的最大缓存大小不能超过 proxy_buffer_size 。</li>
<li>如果 proxy_buffers 打开<br>Nginx将会尽可能的读取后端服务器的数据到buffer，直到proxy_buffers设置的所有buffer们被写满或者数据被读取完(EOF)，此时Nginx开始向客户端传输数据，会同时传输这一整串buffer们。如果数据很大的话，Nginx会接收并把他们写入到temp_file里去，大小由proxy_max_temp_file_size 控制。「当数据没有完全读完的时候」，Nginx同时向客户端传送的buffer 大小 不能超过 proxy_busy_buffers_size 「此句可能理解有误」。</li>
</ul>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>PEP8规范总结</title>
    <url>/2020/08/03/PEP8%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="PEP8规范总结"><a href="#PEP8规范总结" class="headerlink" title="PEP8规范总结"></a>PEP8规范总结</h2><p>PEP8 是什么呢，简单说就是一种编码规范，是为了让代码“更好看”，更容易被阅读。 具体有这些规范，参考 PEP 8 –Style Guide for Python Code.当然也可以使用Pycharm检查或使用pylint.下面是规范总结</p>
<p><strong>缩进</strong></p>
<blockquote>
<p>不要使用 tab 缩进<br>使用任何编辑器写 Python，请把一个 tab 展开为 4 个空格<br>绝对不要混用 tab 和空格，否则容易出现 IndentationError</p>
</blockquote>
<p><strong>空格</strong></p>
<blockquote>
<p>在 list, dict, tuple, set, 参数列表的 , 后面加一个空格<br>在 dict 的 : 后面加一个空格<br>在注释符号 # 后面加一个空格，但是 #!/usr/bin/python 的 # 后不能有空格<br>操作符两端加一个空格，如 +, -, *, /, |, &amp;, =<br>接上一条，在参数列表里的 = 两端不需要空格<br>括号（(), {}, []）内的两端不需要空格</p>
</blockquote>
<p><strong>空行</strong></p>
<blockquote>
<p>function 和 class 顶上两个空行<br>class 的 method 之间一个空行<br>函数内逻辑无关的段落之间空一行，不要过度使用空行<br>不要把多个语句写在一行，然后用 ; 隔开<br>if/for/while 语句中，即使执行语句只有一句，也要另起一行</p>
</blockquote>
<p><strong>换行</strong></p>
<blockquote>
<p>每一行代码控制在 80 字符以内<br>使用 \ 或 () 控制换行，举例：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def foo(first, second, third, fourth, fifth,</span><br><span class="line">        sixth, and_some_other_very_long_param):</span><br><span class="line">    user = User.objects.filter_by(first=first, second=second, third=third) \</span><br><span class="line">        .skip(100).limit(100) \</span><br><span class="line">        .all()</span><br><span class="line"></span><br><span class="line">text = (&apos;Long strings can be made up &apos;</span><br><span class="line">        &apos;of several shorter strings.&apos;)</span><br></pre></td></tr></table></figure>
<p><strong>命名</strong></p>
<blockquote>
<p>使用有意义的，英文单词或词组，绝对不要使用汉语拼音<br>package/module 名中不要出现 -<br>各种类型的命名规范：</p>
</blockquote>
<table>
<thead>
<tr>
<th>Type</th>
<th>public</th>
<th>Inernal</th>
</tr>
</thead>
<tbody>
<tr>
<td>Modules</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr>
<td>Packages</td>
<td>lower_with_under    </td>
</tr>
<tr>
<td>Classes</td>
<td>CapWords</td>
<td>_CapWords</td>
</tr>
<tr>
<td>Exceptions</td>
<td>CapWords    </td>
</tr>
<tr>
<td>Functions</td>
<td>lower_with_under()</td>
<td>_lower_with_under()</td>
</tr>
<tr>
<td>Global/Class Constans</td>
<td>CAPS_WITH_UNDER</td>
<td>CAPS_WITH_UNDER</td>
</tr>
<tr>
<td>Global/Class Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr>
<td>Instance Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under(protected)or __lower_with_under</td>
</tr>
<tr>
<td>Method Names</td>
<td>lower_with_under()</td>
<td>_lower_with_under(protected)or __lower_with_under</td>
</tr>
<tr>
<td>Function/Method Parameters</td>
<td>lower_with_under    </td>
</tr>
<tr>
<td>Local Variables</td>
<td>lower_with_under    </td>
</tr>
</tbody>
</table>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><blockquote>
<p>所有 import 尽量放在文件开头，在 docstring 下面，其他变量定义的上面<br>不要使用 from foo imort *<br>import 需要分组，每组之间一个空行，每个分组内的顺序尽量采用字典序，分组顺序是：</p>
<ol>
<li>标准库</li>
<li>第三方库</li>
<li>本项目的 package 和 module</li>
</ol>
</blockquote>
<p>不要使用隐式的相对导入（implicit relative imports），可是使用显示的相对导入（explicit relative imports），如 from …utils import parse，最好使用全路径导入（absolute imports） 对于不同的 package，一个 import 单独一行，同一个 package/module 下的内容可以写一起：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bad</span><br><span class="line">import sys, os, time</span><br><span class="line"></span><br><span class="line"># good</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># ok</span><br><span class="line">from flask import Flask, render_template, jsonify</span><br></pre></td></tr></table></figure>
<p>为了避免可能出现的命名冲突，可以使用 as 或导入上一级命名空间<br>不要出现循环导入(cyclic import)</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>文档字符串 docstring, 是 package, module, class, method, function 级别的注释，可以通过 doc 成员访问到，注释内容在一对 “”” 符号之间<br>function, method 的文档字符串应当描述其功能、输入参数、返回值，如果有复杂的算法和实现，也需要写清楚<br>不要写错误的注释，不要无谓的注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bad 无谓的注释</span><br><span class="line">x = x + 1       # increase x by 1</span><br><span class="line"></span><br><span class="line"># bad 错误的注释</span><br><span class="line">x = x - 1       # increase x by 1</span><br></pre></td></tr></table></figure>
<p>优先使用英文写注释，英文不好全部写中文，否则更加看不懂</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><blockquote>
<p>不要轻易使用 try/except<br>except 后面需要指定捕捉的异常，裸露的 except 会捕捉所有异常，意味着会隐藏潜在的问题<br>可以有多个 except 语句，捕捉多种异常，分别做异常处理<br>使用 finally 子句来处理一些收尾操作<br>从 Exception 而不是 BaseException 继承自定义的异常类<br>try/except 里的内容不要太多，只在可能抛出异常的地方使用，如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bad</span><br><span class="line">try:</span><br><span class="line">    user = User()</span><br><span class="line">    user.name = &quot;leon&quot;</span><br><span class="line">    user.age = int(age) # 可能抛出异常</span><br><span class="line">    user.created_at = datetime.datetime.utcnow()</span><br><span class="line"></span><br><span class="line">    db.session.add(user)</span><br><span class="line">    db.session.commit() # 可能抛出异常</span><br><span class="line">except:</span><br><span class="line">    db.session.rollback()</span><br><span class="line"></span><br><span class="line"># better</span><br><span class="line">try:</span><br><span class="line">    age = int(age)</span><br><span class="line">except (TypeError, ValueError):</span><br><span class="line">    return # 或别的操作</span><br><span class="line"></span><br><span class="line">user = User()</span><br><span class="line">user.name = &quot;leon&quot;</span><br><span class="line">user.age = age</span><br><span class="line">user.created_at = datetime.datetime.utcnow()</span><br><span class="line">db.session.add(user)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    db.session.commit()</span><br><span class="line">except sqlalchemy.exc.SQLAlchemyError: # 或者更具体的异常</span><br><span class="line">    db.session.rollback()</span><br><span class="line">finally:</span><br><span class="line">    db.session.close()</span><br></pre></td></tr></table></figure>
<h2 id="Class（类）"><a href="#Class（类）" class="headerlink" title="Class（类）"></a>Class（类）</h2><blockquote>
<p>显示的写明父类，如果不是继承自别的类，就继承自 object 类<br>使用 super 调用父类的方法<br>支持多继承，即同时有多个父类，建议使用 Mixin</p>
</blockquote>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><blockquote>
<p>使用字符串的 join 方法拼接字符串<br>使用字符串类型的方法，而不是 string 模块的方法<br>使用 startswith 和 endswith 方法比较前缀和后缀<br>使用 format 方法格式化字符串</p>
</blockquote>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ol>
<li>空的 list, str, tuple, set, dict 和 0, 0.0, None 都是 False</li>
<li>使用 if somelist 而不是 if len(somelist) 判断某个 list 是否为空，其他类型同理</li>
<li>使用 is 和 is not 与单例（如 None）进行比较，而不是用 == 和 !=</li>
<li>使用 if a is not None 而不是 if not a is None</li>
<li>用 isinstance 而不是 type 判断类型</li>
<li>不要用 == 和 != 与 True 和 False 比较（除非有特殊情况，如在 sqlalchemy 中可能用到）</li>
<li>使用 in 操作</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bad</span><br><span class="line">if d.has_key(k):</span><br><span class="line">    do_something()</span><br><span class="line"></span><br><span class="line"># good</span><br><span class="line">if k in d:</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure>
<p>用 set 加速 “存在性” 检查，list 的查找是线性的，复杂度 O(n)，set 底层是 hash table, 复杂度 O(1)，但用 set 需要比 list 更多内存空间</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>使用列表表达式（list comprehension），字典表达式(dict comprehension, Python 2.7+) 和生成器(generator)</li>
<li>dict 的 get 方法可以指定默认值，但有些时候应该用 [] 操作，使得可以抛出 KeyError</li>
<li>使用 for item in list 迭代 list, for index, item in enumerate(list) 迭代 list 并获取下标</li>
<li>使用内建函数 sorted 和 list.sort 进行排序</li>
<li>适量使用 map, reduce, filter 和 lambda，使用内建的 all, any 处理多个条件的判断</li>
<li>使用 defaultdict (Python 2.5+), Counter(Python 2.7+) 等 “冷门” 但好用的标准库算法和数据结构</li>
<li>使用装饰器(decorator)</li>
<li>使用 with 语句处理上下文</li>
<li>有些时候不要对类型做太过严格的限制，利用 Python 的鸭子类型（Duck Type）特性</li>
<li>使用 logging 记录日志，配置好格式和级别</li>
<li>了解 Python 的 Magic Method：A Guide to Python’s Magic Methods, Python 魔术方法指南</li>
<li>阅读优秀的开源代码，如 Flask 框架, Requests for Humans</li>
<li>不要重复造轮子，查看标准库、PyPi、Github、Google 等使用现有的优秀的解决方案</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://blog.csdn.net/genius_jiang/article/details/91479711" target="_blank" rel="noopener">https://blog.csdn.net/genius_jiang/article/details/91479711</a></li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP中backlog参数</title>
    <url>/2020/02/15/TCP-IP%E4%B8%ADbacklog%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h4 id="TCP-IP协议中backlog参数"><a href="#TCP-IP协议中backlog参数" class="headerlink" title="TCP/IP协议中backlog参数"></a>TCP/IP协议中backlog参数</h4><p>TCP建立连接是要进行三次握手，但是否完成三次握手后，服务器就处理（accept）呢？<br>backlog其实是一个连接队列，在Linux内核2.2之前，backlog大小包括半连接状态和全连接状态两种队列大小。</p>
<ul>
<li>半连接状态为：服务器处于Listen状态时收到客户端SYN报文时放入半连接队列中，即SYN queue（服务器端口状态为：SYN_RCVD）。</li>
<li>全连接状态为：TCP的连接状态从服务器（SYN+ACK）响应客户端后，到客户端的ACK报文到达服务器之前，则一直保留在半连接状态中；当服务器接收到客户端的ACK报文后，该条目将从半连接队列搬到全连接队列尾部，即 accept queue （服务器端口状态为：ESTABLISHED）。</li>
</ul>
<p>在Linux内核2.2之后，分离为两个backlog来分别限制半连接（SYN_RCVD状态）队列大小和全连接（ESTABLISHED状态）队列大小。</p>
<ul>
<li>SYN queue 队列长度由 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，默认为2048。</li>
<li>Accept queue 队列长度由 /proc/sys/net/core/somaxconn 和使用listen函数时传入的参数，二者取最小值。默认为128。在Linux内核2.4.25之前，是写死在代码常量 SOMAXCONN ，在Linux内核2.4.25之后，在配置文件 /proc/sys/net/core/somaxconn 中直接修改，或者在 /etc/sysctl.conf 中配置 net.core.somaxconn = 128 。<br><img src="/2020/02/15/TCP-IP中backlog参数/tcpip1.png" alt="avatar"><br>可以通过ss命令来显示<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ss -l</span><br><span class="line">State       Recv-Q Send-Q                                     Local Address:Port                                         Peer Address:Port     </span><br><span class="line">LISTEN      0      128                                                    *:http                                                    *:*       </span><br><span class="line">LISTEN      0      128                                                   :::ssh                                                    :::*       </span><br><span class="line">LISTEN      0      128                                                    *:ssh                                                     *:*       </span><br><span class="line">LISTEN      0      100                                                  ::1:smtp                                                   :::*       </span><br><span class="line">LISTEN      0      100                                            127.0.0.1:smtp                                                    *:*</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在LISTEN状态，其中 Send-Q 即为Accept queue的最大值，Recv-Q 则表示Accept queue中等待被服务器accept()。<br>另外客户端connect()返回不代表TCP连接建立成功，有可能此时accept queue 已满，系统会直接丢弃后续ACK请求；客户端误以为连接已建立，开始调用等待至超时；服务器则等待ACK超时，会重传SYN+ACK 给客户端，重传次数受限 net.ipv4.tcp_synack_retries ，默认为5，表示重发5次，每次等待30~40秒，即半连接默认时间大约为180秒，该参数可以在tcp被洪水攻击是临时启用这个参数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# netstat -s | grep LISTEN</span><br><span class="line">102324 SYNs to LISTEN sockets dropped</span><br></pre></td></tr></table></figure></p>
<p>查看Accept queue 溢出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# netstat -s | grep TCPBacklogDrop</span><br><span class="line">TCPBacklogDrop: 2334</span><br></pre></td></tr></table></figure></p>
<p>　　查看SYN queue 溢出</p>
<h4 id="TCP-queue-的一些问题"><a href="#TCP-queue-的一些问题" class="headerlink" title="TCP queue 的一些问题"></a>TCP queue 的一些问题</h4><ol>
<li>当 client 通过 connect 向 server 发出 SYN 包时，client 会维护一个 socket 等待队列，而 server 会维护一个 SYN 队列</li>
<li>此时进入半链接的状态，如果 socket 等待队列满了，server 则会丢弃，而 client 也会由此返回 connection time out；只要是 client 没有收到 SYN+ACK，3s 之后，client 会再次发送，如果依然没有收到，9s 之后会继续发送</li>
<li>半连接 syn 队列的长度为 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)  决定</li>
<li>当 server 收到 client 的 SYN 包后，会返回 SYN, ACK 的包加以确认，client 的 TCP 协议栈会唤醒 socket 等待队列，发出 connect 调用</li>
<li>client 返回 ACK 的包后，server 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的 backlog 的含义请看这里。需要注意的是，一些 Linux 的发型版本可能存在对 somaxcon 错误 truncating 方式。</li>
<li>当 accept 队列满了之后，即使 client 继续向 server 发送 ACK 的包，也会不被相应，此时，server 通过 /proc/sys/net/ipv4/tcp_abort_on_overflow 来决定如何返回，0 表示直接丢丢弃该 ACK，1 表示发送 RST 通知 client；相应的，client 则会分别返回 read timeout 或者 connection reset by peer。上面说的只是些理论，如果服务器不及时的调用 accept()，当 queue 满了之后，服务器并不会按照理论所述，不再对 SYN 进行应答，返回 ETIMEDOUT。根据这篇文档的描述，实际情况并非如此，服务器会随机的忽略收到的 SYN，建立起来的连接数可以无限的增加，只不过客户端会遇到延时以及超时的情况。</li>
</ol>
]]></content>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>TUN/TAP设备浅析</title>
    <url>/2021/01/28/TUN-TAP%E8%AE%BE%E5%A4%87%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h3 id="TUN设备"><a href="#TUN设备" class="headerlink" title="TUN设备"></a>TUN设备</h3><p>TUN 设备是一种虚拟网络设备，通过此设备，程序可以方便地模拟网络行为。TUN 模拟的是一个三层设备,也就是说,通过它可以处理来自网络层的数据，更通俗一点的说，通过它，我们可以处理 IP 数据包。</p>
<p>先来看看物理设备是如何工作的：</p>
<p><img src="/2021/01/28/TUN-TAP设备浅析/tun1.png" alt="avatar"></p>
<p>上图中的 eth0 表示我们主机已有的真实的网卡接口 (interface)。</p>
<p>网卡接口 eth0 所代表的真实网卡通过网线(wire)和外部网络相连，该物理网卡收到的数据包会经由接口 eth0 传递给内核的网络协议栈(Network Stack)。然后协议栈对这些数据包进行进一步的处理。</p>
<p>对于一些错误的数据包,协议栈可以选择丢弃；对于不属于本机的数据包，协议栈可以选择转发；而对于确实是传递给本机的数据包,而且该数据包确实被上层的应用所需要，协议栈会通过 Socket API 告知上层正在等待的应用程序。</p>
<p>下面看看 TUN 的工作方式：</p>
<p>数据包处理过程<br><img src="/2021/01/28/TUN-TAP设备浅析/tun2.png" alt="avatar"></p>
<p>UDP_VPN<br><img src="/2021/01/28/TUN-TAP设备浅析/tun3.png" alt="avatar"></p>
<p>我们知道，普通的网卡是通过网线来收发数据包的话，而 TUN 设备比较特殊，它通过一个文件收发数据包。</p>
<p>如上图所示，tunX 和上面的 eth0 在逻辑上面是等价的， tunX 也代表了一个网络接口,虽然这个接口是系统通过软件所模拟出来的.</p>
<p>网卡接口 tunX 所代表的虚拟网卡通过文件 /dev/tunX 与我们的应用程序(App) 相连，应用程序每次使用 write 之类的系统调用将数据写入该文件，这些数据会以网络层数据包的形式，通过该虚拟网卡，经由网络接口 tunX 传递给网络协议栈，同时该应用程序也可以通过 read 之类的系统调用，经由文件 /dev/tunX 读取到协议栈向 tunX 传递的所有数据包。</p>
<p>此外，协议栈可以像操纵普通网卡一样来操纵 tunX 所代表的虚拟网卡。比如说，给 tunX 设定 IP 地址，设置路由，总之，在协议栈看来，tunX 所代表的网卡和其他普通的网卡区别不大，当然，硬要说区别，那还是有的,那就是 tunX 设备不存在 MAC 地址，这个很好理解，tunX 只模拟到了网络层，要 MAC地址没有任何意义。当然，如果是 tapX 的话，在协议栈的眼中，tapX 和真是网卡没有任何区别。</p>
<p>如果我们使用 TUN 设备搭建一个基于 UDP 的 VPN ，那么整个处理过程可能是这幅样子：</p>
<p><img src="/2021/01/28/TUN-TAP设备浅析/tun4.png" alt="avatar"></p>
<p>首先，我们的应用程序通过 eth0 和远程的 UDP 程序相连,对方传递过来的 UDP 数据包经由左边的协议栈传递给了应用程序，UDP 数据包的内容其实是一个网络层的数据包，比如说 IP 数据报，应用程序接收到该数据包的数据（剥除了各种头部之后的 UDP 数据）之后，然后进行一定的处理，处理完成后将处理后的数据写入文件 /dev/tunX，这样，数据会第二次到达协议栈。需要注意的是，上图中绘制的两个协议栈其实是同一个协议栈，之所以这么画是为了叙述的方便。</p>
<h3 id="TAP设备"><a href="#TAP设备" class="headerlink" title="TAP设备"></a>TAP设备</h3><p>TAP 设备与 TUN 设备工作方式完全相同，区别在于：</p>
<ol>
<li>TUN 设备是一个三层设备，它只模拟到了 IP 层，即网络层 我们可以通过 /dev/tunX 文件收发 IP 层数据包，它无法与物理网卡做 bridge，但是可以通过三层交换（如 ip_forward）与物理网卡连通。可以使用ifconfig之类的命令给该设备设定 IP 地址。</li>
<li>TAP 设备是一个二层设备，它比 TUN 更加深入，通过 /dev/tapX 文件可以收发 MAC 层数据包，即数据链路层，拥有 MAC 层功能，可以与物理网卡做 bridge，支持 MAC 层广播。同样的，我们也可以通过ifconfig之类的命令给该设备设定 IP 地址，你如果愿意，我们可以给它设定 MAC 地址。</li>
</ol>
<p>最后，关于文章中出现的二层，三层，我这里说明一下，第一层是物理层，第二层是数据链路层，第三层是网络层，第四层是传输层。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>UltraISO制作ISO镜像流程及问题记录</title>
    <url>/2021/04/16/UltraISO%E5%88%B6%E4%BD%9CISO%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E5%8F%8A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>业务系统中需要使用ISO进行项目交付，制作ISO镜像的过程中需要制作U盘启动盘。相关流程及问题总结如下：</p>
<h3 id="1-制作系统启动镜像"><a href="#1-制作系统启动镜像" class="headerlink" title="1. 制作系统启动镜像"></a>1. 制作系统启动镜像</h3><p>制作自定义ISO镜像的流程可以参考文章<a href="https://alfredliukai.github.io/2021/02/05/%E5%AE%9A%E5%88%B6%E5%8C%96ISO%E9%95%9C%E5%83%8F/">https://alfredliukai.github.io/2021/02/05/%E5%AE%9A%E5%88%B6%E5%8C%96ISO%E9%95%9C%E5%83%8F/</a></p>
<p>在制作镜像的过程中需要注意的点是：syslinux.cfg.注意修改内容为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">label linux</span><br><span class="line">  menu label ^Install CentOS 7</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img inst.stage2=hd:LABEL=CentOS7 inst.ks=hd:LABEL=CentOS7:/isolinux/ks.cfg quiet</span><br></pre></td></tr></table></figure></p>
<p>生成自定义ISO镜像如CentOs-7.iso</p>
<h3 id="2-明确制作启动盘"><a href="#2-明确制作启动盘" class="headerlink" title="2. 明确制作启动盘"></a>2. 明确制作启动盘</h3><p>UltraISO 软件（试用版就行）。</p>
<p><img src="/2021/04/16/UltraISO制作ISO镜像流程及问题记录/ultra1.png" alt="avatar"></p>
<p>打开CentOS镜像<br><img src="/2021/04/16/UltraISO制作ISO镜像流程及问题记录/ultra2.png" alt="avatar"></p>
<p>把CentOS镜像写入到优盘中：</p>
<p><img src="/2021/04/16/UltraISO制作ISO镜像流程及问题记录/ultra3.png" alt="avatar"></p>
<p>写入镜像时的设置：</p>
<p><img src="/2021/04/16/UltraISO制作ISO镜像流程及问题记录/ultra4.png" alt="avatar"></p>
<p>这里参考的是： [1] 中的第三种方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写入方式USB-HDD+</span><br><span class="line">便捷启动&gt;写入新的硬盘主引导（MBR）记录&gt;选择USB-HDD+</span><br></pre></td></tr></table></figure>
<p>在看到这个之前，我被一篇文章给“坑到了”： [2]，因为这里说的是：在便捷启动设置里面要设置syslinux，结果显示syslinux不支持NTFS文件系统。然而我的优盘是 NTFS 格式。</p>
<p>其实后来看了 [1] 才知道，不一定要用syslinux设置。</p>
<h3 id="3-安装Ubuntu系统"><a href="#3-安装Ubuntu系统" class="headerlink" title="3. 安装Ubuntu系统"></a>3. 安装Ubuntu系统</h3><p>根据以上步骤，已经做好了CentOS7 启动盘。</p>
<p><strong>设置BIOS优先从优盘启动</strong></p>
<p>先把优盘插入到你要安装Ubuntu系统的电脑上，在开机时进入bios（del键，或者F12，或者F2等等，各机型之间各有差异）。</p>
<p>然后在bios中的fast boot选项中（如果有这个选项的话），设置其为enable。我感觉如果不设为enable的话，电脑在开机的时候可能会识别不到优盘。这里也参考了一下：[4] 和 [5]。</p>
<p>然后在boot option选项（也有可能是 启动-&gt;boot，或者boot priority等等），设置优盘先启动（根据 [3] ，如果显示两个优盘，则选择UEFI格式的优盘）。</p>
<p>然后按下F10，即保存后退出。这时候会重新启动，然后就会进入Ubuntu安装界面。</p>
<p><strong>进行系统安装</strong></p>
<p>这里很简单了，当屏幕显示出安装界面之后，选择 install Ubuntu。</p>
<p>然后进入一系列设置，这里就根据自己的喜好设置就行。（其中包括用户名等）</p>
<p>然后一直continue，等待片刻之后系统就装好了，然后提示restart，点击确认，重启之后就能看到你安装的Ubuntu 14.04系统了。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://blog.csdn.net/weixin_39278265/article/details/89006467" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39278265/article/details/89006467</a></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>U盘制作启动盘中的问题小结</title>
    <url>/2021/06/29/U%E7%9B%98%E5%88%B6%E4%BD%9C%E5%90%AF%E5%8A%A8%E7%9B%98%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>为了让软件的交付更加简便，在制作iso盘的过程中涉及一些问题。简单总结如下：</p>
<p><strong>windows中的盘符和卷标</strong></p>
<p>用windows的人每天都会看到盘符和卷标，但往往对其概念模糊，下面解释一下：</p>
<p>盘符：只有windows下有，用来表示分区的顺序，默认第一个可以识别的主分区为C:，以后依次为D:、E:、F:等（为方便，光驱也有，默认排在最后），不属于分区的信息，该信息不保存在该分区内。</p>
<p>卷标：就是在显示“本地磁盘”的地方，如果有卷标就把“本地磁盘”这几个字换成其他的文字（就是卷标），是该分区的信息之一，即卷标保存在该分区内。</p>
<p>如何辨别：盘符后一定有一个英文的冒号（“:”），而卷标可以随意（只是有字符个数的限制）。</p>
<p><strong>U盘安装CentOS7黑屏</strong></p>
<p>系统识别到u盘LABEL标签跟实际的不一致，windows卷标长度限制长度为11位，所以省去后面多余的几位，但系统识别到的u盘标签为CentOS 7 x86_64。</p>
<p>解决方法<br>原始引导命令语句为：<br>vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 quiet<br>uefi模式按“e”进入，传统模式按“tab”键进入</p>
<p>（1）方法一<br>方法一操作复杂，不建议使用<br>先通过dd命令列出当前可用的设备信息，我u盘的确认是sdb4；<br>修改为vmlinuz initrd=initrd.img dd linux quiet，按enter确定<br>再次修改系统引导命令行语句为：<br>vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb4 quiet<br>说明：hd:/dev/sdb4表示上一步中所找到的U盘挂载目录信息</p>
<p>（2）方法二<br>修改系统引导命令行语句为：<br>vmlinuz initrd=initrd.img inst.stage2=hd: LABEL=CentOS\x207\x20x8 quiet</p>
<p>（3）方法三<br>修改系统引导命令行语句为：<br>vmlinuz initrd=initrd.img inst.stage2=hd: LABEL=CentOS\x207\x20x8 nomodeset quiet</p>
<p><strong>总结</strong></p>
<p>对于交付同学，为避免出现问题，建议修改卷标为指定名称。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>cryptsetup文件系统加密</title>
    <url>/2021/01/26/cryptsetup%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>当Ubuntu Linux使用加密文件系统后，数据的安万能得到非常好的保护。在这种情况下，即使把我们的机器送给黑客，只要他们没有密钥，黑客看到的数据只会是一堆乱 码，毫无利用价值可言。<br>本文将周详介绍利用dm-crypt来创建加密文件系统的方法。和其他创建加密文件系统的方法相比，dm-crypt系统有着无可比拟的优越性：他的速度 更快，易用性更强。除此之外，他的适用面也非常广，能够运行在各种块设备上，即使这些设备使用了RAID和 LVM也毫无障碍。dm-crypt系统之所以具有这些好处，主要得益于该技术是建立在2.6版本内核的device-mapper特性之上的。 device-mapper是设计用来为在实际的块设备之上添加虚拟层提供一种通用灵活的方法，以方便研发人员实现映像、快照、级联和加密等处理。此外， dm-crypt使用了内核密码应用编程接口实现了透明的加密，并且兼容cryptloop系统。</p>
<h3 id="一、设置内核"><a href="#一、设置内核" class="headerlink" title="一、设置内核"></a>一、设置内核</h3><p>dm-crypt利用内核的密码应用编程接口来完成密码操作。一般说来，内核通常将各种加密程式以模块的形式加载。对于256-bit AES来说，其安全强度已非常之高，即便用来保护绝密级的数据也足够了。因此本文中我们使用256-bit AES密码，为了确保你的内核已加载AES密码模块，请利用下列命令进行检查：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /proc/crypto如果看到类似下面的输出的话，说明AES模块已加载：</span><br><span class="line">name         : aes</span><br><span class="line">module       : aes</span><br><span class="line">type         : cipher</span><br><span class="line">blocksize    : 16</span><br><span class="line">min keysize  : 16</span><br><span class="line">max keysize  : 32</span><br></pre></td></tr></table></figure></p>
<p>否则，我们能利用modprobe来手工加载AES模块，命令如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo modprobe aes</span><br></pre></td></tr></table></figure></p>
<p>接下来安装dmsetup软件包，该软件包含有设置device-mapper所需的工具：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install dmsetup cryptsetup为检查dmsetup软件包是否已建立了设备映象程式，键入下列命令：</span><br><span class="line">$ ls -l /dev/mapper/control接下来加载dm-crypt内核模块：</span><br><span class="line">$ sudo modprobe dm-cryptdm-crypt加载后，他会用device-mapper自动注册。如果再次检验的话，device-mapper已能识别dm- crypt，并且把crypt 添加为可用的对象：</span><br><span class="line">$ sudo dmsetup targets如果一切顺利，目前你应该看到crypt的下列输出：</span><br><span class="line">crypt            v1.1.0</span><br><span class="line">striped          v1.0.2</span><br><span class="line">linear           v1.0.1</span><br><span class="line">error            v1.0.1</span><br></pre></td></tr></table></figure></p>
<p>这说明我们的系统已为装载加密设备做好了准备。下面，我们先来建立一个加密设备。</p>
<h3 id="二、建立加密设备"><a href="#二、建立加密设备" class="headerlink" title="二、建立加密设备"></a>二、建立加密设备</h3><p>要创建作为加密设备装载的文件系统，有两种选择：一是建立一个磁盘映像，然后作为回送设备加载；二是使用物理设备。无论那种情况，除了在建立和捆绑回送设备外，其他操作过程都是相似的。</p>
<p>1.建立回送磁盘映象<br>如果你没有用来加密的物理设备（比如存储棒或另外的磁盘分区），作为替换，你能利用命令dd来建立一个空磁盘映象，然后将该映象作为回送设备来装载，照样 能用。下面我们以实例来加以介绍：<br>$ dd if=/dev/zero of=~/secret.img bs=1M count=100这里我们新建了一个大小为100 MB的磁盘映象，该映象名字为secret.img。要想改动其大小，能改动count的值。<br>接下来，我们利用losetup命令将该映象和一个回送设备联系起来：<br>$ sudo losetup /dev/loop/0 ~/secret.img目前，我们已得到了一个虚拟的块设备，其位于/dev/loop/0，并且我们能够如同使用其他设备那样来使用他。</p>
<p>2.设置块设备<br>准备好了物理块设备（例如/dev/sda1），或是虚拟块设备（像前面那样建立了回送映象，并利用device-mapper将其作为加密的逻辑卷加载），我们就能进行块设备设置了。<br>下面我们使用cryptsetup来建立逻辑卷，并将其和块设备捆绑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo cryptsetup -y create myEncryptedFilesystem   /dev/DEVICENAME</span><br></pre></td></tr></table></figure>
<p>其中，myEncryptedFilesystem 是新建的逻辑卷的名称。并且最后一个参数必须是将用作加密卷的块设备。所以，如果你要使用前面建立的回送映象作为虚拟块设备的话，应当运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo cryptsetup -y create myEncryptedFilesystem  /dev/loop/0</span><br></pre></td></tr></table></figure>
<p>无论是使用物理块设备还是虚拟块设备，程式都会要你输入逻辑卷的口令，-y的作用 在于要你输入两次口令以确保无误。这一点非常重要，因为一旦口令弄错，你就会把自己的数据锁住，这时谁也帮不了你了！<br>为了确认逻辑卷是否已建立，能使用下列命令进行检查一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo dmsetup ls只要该命令列出了逻辑卷，就说明已成功建立了逻辑卷。不过根据机器的不同，设备号可能有所不同：</span><br><span class="line">myEncryptedFilesystem  (221, 0)device-mapper会把他的虚拟设备装载到/dev/mapper下面，所以，你的虚拟块设备应该是/dev/mapper /myEncryptedFilesystem ，尽管用起来他和其他块设备没什么不同，实际上他却是经过透明加密的。</span><br></pre></td></tr></table></figure></p>
<p>如同物理设备相同，我们也能在虚拟设备上创建文件系统：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo mkfs.ext3 /dev/mapper/myEncryptedFilesystem目前为新的虚拟块设备建立一个装载点，然后将其装载。命令如下所示：</span><br><span class="line">$ sudo mkdir /mnt/myEncryptedFilesystem</span><br><span class="line">$ sudo mount /dev/mapper/myEncryptedFilesystem  /mnt/myEncryptedFilesystem我们能够利用下面的命令 查看其装载后的情况：</span><br><span class="line">$ df -h /mnt/myEncryptedFilesystem</span><br><span class="line">Filesystem              Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/myEncryptedFilesystem     97M  2.1M   90M   2% /mnt/myEncryptedFilesystem</span><br></pre></td></tr></table></figure>
<p>非常好，我们看到装载的文件系统，尽管看起来和其他文件系统无异，但实际上写到/mnt/myEncryptedFilesystem /下的所有数据，在数据写入之前都是经过透明的加密处理后才写入磁盘的，因此，从该处读取的数据都是些密文。</p>
<h3 id="三、卸载方法"><a href="#三、卸载方法" class="headerlink" title="三、卸载方法"></a>三、卸载方法</h3><p>要卸载加密文件系统，和平常的方法没什么两样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo umount /mnt/myEncryptedFilesystem 即便已卸载了块设备，在dm-crypt中仍然视为一个虚拟设备。如若不信，你能再次运行命令 </span><br><span class="line">sudo dmsetup ls 来验证一下，你会看到该设备依然会被列出。因为dm-crypt缓存了口令，所以机器上的其他用户不必知道口令就能重新装载该设备。为了避免这种情况 发生，你必须在卸载设备后从dm-crypt中显式的删除该设备。命令具体如下所示：</span><br><span class="line">$ sudo cryptsetup remove myEncryptedFilesystem此后，他将完全清除，要想再次装载的话，你必须再次输入口令。为了简化该过程，我们能利用一个简单的脚本来完 成卸载和清除工作：</span><br><span class="line">#!/bin/sh</span><br><span class="line">umount /mnt/myEncryptedFilesystem</span><br><span class="line">cryptsetup remove myEncryptedFilesystem</span><br></pre></td></tr></table></figure></p>
<h3 id="四、重新装载"><a href="#四、重新装载" class="headerlink" title="四、重新装载"></a>四、重新装载</h3><p>在卸载加密设备后，我们非常可能还需作为普通用户来装载他们。为了简化该工作，我们需要在/etc/fstab文件中添加下列内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/dev/mapper/myEncryptedFilesystem  /mnt/myEncryptedFilesystem  ext3 noauto,noatime 0 0此外，我们也能通过建立脚本来替我们完成dm-crypt设备的创建和卷的装载工作，方法是用实际设备的名称或文件路径来替换/dev /DEVICENAME：</span><br><span class="line">#!/bin/sh</span><br><span class="line">cryptsetup create myEncryptedFilesystem  /dev/DEVICENAME</span><br><span class="line">mount /dev/mapper/myEncryptedFilesystem  /mnt/myEncryptedFilesystem如果你使用的是回送设备 的话，你还能利用脚本来捆绑设备：</span><br><span class="line">#!/bin/sh</span><br><span class="line">losetup /dev/loop/0 ~/secret.img</span><br><span class="line">cryptsetup create myEncryptedFilesystem  /dev/loop/0</span><br><span class="line">mount /dev/mapper/myEncryptedFilesystem  /mnt/myEncryptedFilesystem如果你收到消息 “ioctl: LOOP_SET_FD: Device or resource busy”，这说明回送设备非常可能仍然装载在系统上。我们能利用sudo losetup -d /dev/loop/0命令将其删除。</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>df、du、fdisk、lsblk区别</title>
    <url>/2021/01/26/df%E3%80%81du%E3%80%81fdisk%E3%80%81lsblk%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>df主要是检查文件系统磁盘占用情况，所以这里可以看到文件系统<br><img src="/2021/01/26/df、du、fdisk、lsblk区别/df1.png" alt="avatar"><br>du主要是检查磁盘空间占用情况，统计目录或者文件大小的，和ll功能有相同之处。</p>
<p>fdisk一般用来磁盘分区，也可以用来查看磁盘分区情况。<br><img src="/2021/01/26/df、du、fdisk、lsblk区别/df2.png" alt="avatar"></p>
<p>这里可以看到/dev/sdb和/dev/sda两个分区。<br>但是在df命令中看不到/dev/sda，因为/dev/sda上面没有跑文件系统，如果想看所有的磁盘分区需要用这个命令。</p>
<p>lsblk命令用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，这个命令很好用，因为可以让电脑上的磁盘和分区信息很清晰。<br><img src="/2021/01/26/df、du、fdisk、lsblk区别/df3.png" alt="avatar"></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>docker环境下使用kafka</title>
    <url>/2021/02/09/docker%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8kafka/</url>
    <content><![CDATA[<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Copy//下载zookeeper</span><br><span class="line">docker pull wurstmeister/zookeeper</span><br><span class="line"></span><br><span class="line">//下载kafka</span><br><span class="line">docker pull wurstmeister/kafka:2.11-0.11.0.3</span><br></pre></td></tr></table></figure>
<h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Copy//启动zookeeper</span><br><span class="line">docker run -d --name zookeeper -p 2181:2181  wurstmeister/zookeeper</span><br><span class="line"></span><br><span class="line">//启动kafka</span><br><span class="line">docker run  -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=192.168.1.106:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.1.106:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -t wurstmeister/kafka</span><br></pre></td></tr></table></figure>
<h3 id="测试kafka"><a href="#测试kafka" class="headerlink" title="测试kafka"></a>测试kafka</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./kafka-console-producer.sh --broker-list localhost:9092 --topic sun</span><br><span class="line">&gt;123</span><br><span class="line">&gt;asdf</span><br><span class="line">&gt;hahh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic sun --from-beginning</span><br></pre></td></tr></table></figure>
<h3 id="创建查看topic"><a href="#创建查看topic" class="headerlink" title="创建查看topic"></a>创建查看topic</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper 192.168.1.106:2181 --create --topic dalianpai --partitions 2 --replication-factor 1</span><br><span class="line"></span><br><span class="line">bin/kafka-topics.sh --zookeeper 192.168.1.106:2181 --list</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>es总结1</title>
    <url>/2020/03/22/es%E6%80%BB%E7%BB%931/</url>
    <content><![CDATA[<h4 id="Elasticsearch生态圈"><a href="#Elasticsearch生态圈" class="headerlink" title="Elasticsearch生态圈"></a>Elasticsearch生态圈</h4><p><img src="/2020/03/22/es总结1/es1.png" alt="avatar"></p>
<h4 id="Elasticsearch安装与配置"><a href="#Elasticsearch安装与配置" class="headerlink" title="Elasticsearch安装与配置"></a>Elasticsearch安装与配置</h4><ul>
<li>本地部署 &amp;水平扩展<br><img src="/2020/03/22/es总结1/es2.png" alt="avatar"></li>
<li>安装部署</li>
</ul>
<ol>
<li>运行Elasticsearch，需要安装并配置JDK,设置JAVA_HOME</li>
<li>Elasticsearch需要Java 8 以上版本,6.5版本支持JAVA 11,7.0内置了Java环境</li>
<li>解压直接运行</li>
</ol>
<ul>
<li><p>文件目录<br>bin : 脚本文件，包括启动elasticsearch，安装插件。运行统计数据等。<br>config : 集群配置文件，user，role based相关配置<br>JDK : Java运行环境<br>data : path.data 数据文件<br>lib : Java类库<br>logs : path.log 日志文件<br>modules : 包含所有es文件<br>plugins : 包含所有已安装插件</p>
</li>
<li><p>JVM配置</p>
</li>
</ul>
<ol>
<li>修改JVM : config/jvm.options, 7.1 默认为1G</li>
<li>配置建议 :  1. Xms与Xmx设置成一眼，2. Xmx  不要超过机器内存50%，3. 不要超过30GB</li>
</ol>
<ul>
<li>启动运行</li>
</ul>
<ol>
<li>启动单节点<br>bin/elasticsearch -E node.name=node0 -E cluster.name=geektime -E path.data=node0_data</li>
<li>安装插件<br>bin/elasticsearch-plugin install analysis-icu</li>
<li>查看插件<br>bin/elasticsearch-plugin list</li>
<li>查看安装的插件<br>GET <a href="http://localhost:9200/_cat/plugins?v" target="_blank" rel="noopener">http://localhost:9200/_cat/plugins?v</a></li>
<li>start multi-nodes Cluster<br>bin/elasticsearch -E node.name=node0 -E cluster.name=geektime -E path.data=node0_data<br>bin/elasticsearch -E node.name=node1 -E cluster.name=geektime -E path.data=node1_data<br>bin/elasticsearch -E node.name=node2 -E cluster.name=geektime -E path.data=node2_data<br>bin/elasticsearch -E node.name=node3 -E cluster.name=geektime -E path.data=node3_data</li>
<li>查看集群<br>GET <a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a></li>
<li>查看nodes<br>GET _cat/nodes<br>GET _cluster/health</li>
</ol>
<ul>
<li>Kibana</li>
</ul>
<ol>
<li><a href="https://www.elastic.co/downloads/kibana" target="_blank" rel="noopener">https://www.elastic.co/downloads/kibana</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 启动 kibana</span><br><span class="line">bin/kibana</span><br><span class="line"></span><br><span class="line">// 查看插件</span><br><span class="line">bin/kibana-plugin list</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>Docker容器中部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;2.2&apos;</span><br><span class="line">services:</span><br><span class="line">  cerebro:</span><br><span class="line">    image: lmenezes/cerebro:0.8.3</span><br><span class="line">    container_name: cerebro</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9000:9000&quot;</span><br><span class="line">    command:</span><br><span class="line">      - -Dhosts.0.host=http://elasticsearch:9200</span><br><span class="line">    networks:</span><br><span class="line">      - es72net</span><br><span class="line">  kibana:</span><br><span class="line">    image: docker.elastic.co/kibana/kibana:7.2.0</span><br><span class="line">    container_name: kibana72</span><br><span class="line">    environment:</span><br><span class="line">      #- I18N_LOCALE=zh-CN</span><br><span class="line">      - XPACK_GRAPH_ENABLED=true</span><br><span class="line">      - TIMELION_ENABLED=true</span><br><span class="line">      - XPACK_MONITORING_COLLECTION_ENABLED=&quot;true&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5601:5601&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - es72net</span><br><span class="line">  elasticsearch:</span><br><span class="line">    image: docker.elastic.co/elasticsearch/elasticsearch:7.2.0</span><br><span class="line">    container_name: es72_01</span><br><span class="line">    environment:</span><br><span class="line">      - cluster.name=geektime</span><br><span class="line">      - node.name=es72_01</span><br><span class="line">      - bootstrap.memory_lock=true</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br><span class="line">      - discovery.seed_hosts=es72_01,es72_02</span><br><span class="line">      - network.publish_host=elasticsearch</span><br><span class="line">      - cluster.initial_master_nodes=es72_01,es72_02</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    volumes:</span><br><span class="line">      - es72data1:/usr/share/elasticsearch/data</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">    networks:</span><br><span class="line">      - es72net</span><br><span class="line">  elasticsearch2:</span><br><span class="line">    image: docker.elastic.co/elasticsearch/elasticsearch:7.2.0</span><br><span class="line">    container_name: es72_02</span><br><span class="line">    environment:</span><br><span class="line">      - cluster.name=geektime</span><br><span class="line">      - node.name=es72_02</span><br><span class="line">      - bootstrap.memory_lock=true</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span><br><span class="line">      - discovery.seed_hosts=es72_01,es72_02</span><br><span class="line">      - network.publish_host=elasticsearch</span><br><span class="line">      - cluster.initial_master_nodes=es72_01,es72_02</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    volumes:</span><br><span class="line">      - es72data2:/usr/share/elasticsearch/data</span><br><span class="line">    networks:</span><br><span class="line">      - es72net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  es72data1:</span><br><span class="line">    driver: local</span><br><span class="line">  es72data2:</span><br><span class="line">    driver: local</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  es72net:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure>
</li>
<li><p>logstash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动Elasticsearch实例，然后启动 logstash，并制定配置文件导入数据</span><br><span class="line">bin/logstash -f /YOUR_PATH_of_logstash.conf</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>es3总结</title>
    <url>/2020/03/29/es%E6%80%BB%E7%BB%933/</url>
    <content><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol>
<li>概念</li>
</ol>
<ul>
<li>正排索引-文档Id到文档内容和单词的关联；</li>
<li>倒排索引- 单词到文档Id的关系；<br><img src="/2020/03/29/es总结3/es3-1.png" alt="avatar"></li>
</ul>
<ol start="2">
<li>核心组成</li>
</ol>
<ul>
<li>单词词典（Term Dictionary），记录所有文档的单词，记录单词倒排列表的关联关系；单词词典一般比较大，可以通过B+树或哈希拉链法实现，以满足性能的插入与查询；</li>
<li>倒排列表（Posting List），记录了单词对应的文档结合，由倒排索引项组成；倒排索引项（Posting）由文档ID、词频TF（该单词在文档中出现的次数，用于相关性评分）、位置（Postion）（单词在文档中的位置，用于语句搜索phrase query）、偏移（offset）（记录单词的开始结束位置，实现高亮显示）<br><img src="/2020/03/29/es总结3/es3-2.png" alt="avatar"></li>
</ul>
<ol start="3">
<li>Elasticsearch的倒排索引</li>
</ol>
<ul>
<li>Elasticsearch的JSON文档中的每个字段，都有自己的倒排索引</li>
<li>可以指定对某些字段不做索引，优点是节省存储空间，缺点是字段无法被搜索</li>
</ul>
<h4 id="Analysis与Analyzer"><a href="#Analysis与Analyzer" class="headerlink" title="Analysis与Analyzer"></a>Analysis与Analyzer</h4><ol>
<li>Analysis</li>
</ol>
<ul>
<li>Analysis：文本分析是把全文本转换一系列单词（term/token）的过程，也叫分词；</li>
<li>Analysis是通过Analyzer来实现的，可使用Elasticsearch内置的分析器/或者按需定制化分析器</li>
<li>除了在数据写入时转换词条，匹配query语句时侯也需要相同的分析器对查询语句进行分析</li>
</ul>
<ol start="2">
<li>Analyzer<br>分词器是专门处理分词的组件，Analyzer由三部分组成</li>
</ol>
<ul>
<li>Character Filters：针对原始文本处理，例如去除html</li>
<li>Tokenizer：按照规则切分为单词</li>
<li>Token Filter：将切分的单词进行加工，小写，删除stopwords，增加同义词；<br><img src="/2020/03/29/es总结3/es3-3.png" alt="avatar"></li>
</ul>
<ol start="3">
<li>Elasticsearch的内置分词器</li>
</ol>
<ul>
<li>Standard Analyzer：默认分词器，按词切分，小写处理</li>
<li>Simple Analyzer：按照非字母切分（符号被过滤），小写处理</li>
<li>Stop Analyzer：小写处理，停用词过滤（the，a，is）</li>
<li>Whitespace Analyzer：按照空格切分，不转小写</li>
<li>Keyword Analyzer：不分词，直接将输入当作输出</li>
<li>Patter Analyzer：正则表达式，默认\W+(非字符分隔)</li>
<li>Language：提高了30多种常见语言的分词器</li>
<li>Customer Analyzer：自定义分词器<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;Mastering Elasticsearch, elasticsearch in Action&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;mastering&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 9,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 10,</span><br><span class="line">      &quot;end_offset&quot; : 23,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 25,</span><br><span class="line">      &quot;end_offset&quot; : 38,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;in&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 39,</span><br><span class="line">      &quot;end_offset&quot; : 41,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;action&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 42,</span><br><span class="line">      &quot;end_offset&quot; : 48,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2020/03/29/es总结3/es3-4.png" alt="avatar"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. simple Analyzer</span><br><span class="line">按照非字母切分，非字母的都被去除；小写处理</span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;simple&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. Whitespace Analyzer</span><br><span class="line">按照空格切分</span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3. Stop Analyzer</span><br><span class="line">相比Simple Analyzer，多了stop filter（会把the a is等修饰词去除）</span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;stop&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. Keyword Analyzer</span><br><span class="line">不分词，直接将输出当一个term输出</span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;keyword&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5. Pattern Analyzer</span><br><span class="line">通过正则表达式进行分词，默认\W+,非字符的符号进行分隔</span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;pattern&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6. Language Analyzer</span><br><span class="line"></span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;english&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">7. 中文分词</span><br><span class="line">中文句子：切分成一个一个词（不是一个个字）；英文中：单词有自然的空格作为分隔</span><br><span class="line">一句中文，在不同的上下文，有不同的理解；一些例子（他说的确实在理/这事的确定不下来）</span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;icu_analyzer&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;他说的确实在理”&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;他说的确实在理”&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;icu_analyzer&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;这个苹果不大好吃&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>git clean的方法小结</title>
    <url>/2020/09/16/git-clean%E7%9A%84%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h2><p>想批量删除branch中新加的文件(untracked files)，，git reset –hard不行～</p>
<p>首先确认要删除的文件<br>git clean -fd -n</p>
<p>如果以上命令给出的文件列表是你想删除的， 那么接下来执行</p>
<p>git clean -f -d或者git clean -fd就可以了。</p>
<p>其中-f表示文件 -d表示目录, 如果还要删除.gitignore中的文件那么再加上-x (-x对我来说没用）</p>
<p>如果git submodule中也存在需要删除的文件那么需要再加个-f， 变成git clean -dff</p>
<p>详见：<a href="http://stackoverflow.com/questions/61212/how-do-i-remove-local-untracked-files-from-my-current-git-branch" target="_blank" rel="noopener">http://stackoverflow.com/questions/61212/how-do-i-remove-local-untracked-files-from-my-current-git-branch</a></p>
<p><strong>删除 untracked files</strong></p>
<p>git clean -f</p>
<p><strong>连 untracked 的目录也一起删掉</strong></p>
<p>git clean -fd</p>
<p><strong>连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）</strong></p>
<p>git clean -xfd</p>
<p><strong>在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删</strong></p>
<p>git clean -nxfd<br>git clean -nf<br>git clean -nfd</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git中的对象简介</title>
    <url>/2020/07/08/git%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>为了加深git中底层对象的理解，特意整理如下文章。<br>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 快照 。</p>
<p>在进行提交操作时，Git 会保存一个提交对象（commit object）。 知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象，</p>
<p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在 起步 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add README test.rb LICENSE</span><br><span class="line">$ git commit -m &apos;The initial commit of my project&apos;</span><br></pre></td></tr></table></figure>
<p>当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。</p>
<p>现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树 对象 （记录着目录结构和 blob 对象索引）以及一个 提交 对象（包含着指向前述树对象的指针和所有提交信息）。<br><img src="/2020/07/08/git中的对象简介/git1.png" alt="avatar"><br>Figure 9. 首次提交对象及其树结构<br>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。<br><img src="/2020/07/08/git中的对象简介/git2.png" alt="avatar"><br>Figure 10. 提交对象及其父对象<br>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。<br><img src="/2020/07/08/git中的对象简介/git3.png" alt="avatar"><br>Figure 11. 分支及其提交历史</p>
<h4 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h4><p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure></p>
<p>这会在当前所在的提交对象上创建一个指针。<br><img src="/2020/07/08/git中的对象简介/git4.png" alt="avatar"></p>
<p>Figure 12. 两个指向相同提交历史的分支<br>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。</p>
<p><img src="/2020/07/08/git中的对象简介/git5.png" alt="avatar"></p>
<p>Figure 13. HEAD 指向当前所在的分支<br>你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 –decorate<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --oneline --decorate</span><br><span class="line">f30ab (HEAD -&gt; master, testing) add feature #32 - ability to add new formats to the central interface</span><br><span class="line">34ac2 Fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">98ca9 The initial commit of my project</span><br></pre></td></tr></table></figure></p>
<p>正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。</p>
<h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><p>要切换到一个已存在的分支，你需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure>
<p>这样 HEAD 就指向 testing 分支了。</p>
<p><img src="/2020/07/08/git中的对象简介/git6.png" alt="avatar"></p>
<p>Figure 14. HEAD 指向当前所在的分支<br>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m &apos;made a change&apos;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/08/git中的对象简介/git7.png" alt="avatar"></p>
<p>Figure 15. HEAD 分支随着提交操作自动向前移动<br>如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/08/git中的对象简介/git8.png" alt="avatar"><br>Figure 16. 检出时 HEAD 随之移动<br>这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。</p>
<p>我们不妨再稍微做些修改并提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m &apos;made other changes&apos;</span><br></pre></td></tr></table></figure>
<p>现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。<br><img src="/2020/07/08/git中的对象简介/git9.png" alt="avatar"><br>Figure 17. 项目分叉历史<br>你可以简单地使用 git log 命令查看分叉历史。 运行 git log –oneline –decorate –graph –all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --oneline --decorate --graph --all</span><br><span class="line">* c2b9e (HEAD, master) made other changes</span><br><span class="line">| * 87ab2 (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure>
<p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p>
<p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B</a></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2020/04/05/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><ul>
<li><p>查看本地分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* br-2.1.2.2</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看远程分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">  origin/HEAD -&gt; origin/master</span><br><span class="line">  origin/feature/IOS_visualtrack</span><br><span class="line">  origin/feature/android_visualtrack</span><br><span class="line">  origin/master</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">* br-2.1.2.2</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/br-2.1.2.1</span><br><span class="line">  remotes/origin/br-2.1.2.2</span><br><span class="line">  remotes/origin/br-2.1.3</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>
</li>
<li><p>PS: git branch -r 无法获取远程分支，ui可以看见分支但是git 命令无法查看<br>原因 git branch -a 这条命令并没有每一次都从远程更新仓库信息，我们可以手动更新一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin </span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/Release</span><br><span class="line">  remotes/origin/master</span><br><span class="line"></span><br><span class="line">$ git checkout -b myRelease origin/Release</span><br><span class="line">Branch myRelease set up to track remote branch Release from origin.</span><br><span class="line">Switched to a new branch &apos;myRelease&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并分支<br>合并前要先切回要并入的分支<br>以下表示要把issue1234分支合并入master分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$: git checkout master</span><br><span class="line">$: git merge issue1234</span><br><span class="line">Merge made by recursive.</span><br><span class="line"> README |    1 +</span><br><span class="line"> 1 files changed, 1 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤消上一次commit的内容(该操作会彻底回退到某个版本，本地的源码也会变为上一个版本的内容)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>git commit -m 注释换行<br>git commit -m 注释可以通过单引号来换行，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &apos;</span><br><span class="line">&gt; 1.aaaaa</span><br><span class="line">&gt; 2.bbbb</span><br><span class="line">&gt; &apos;</span><br><span class="line">[master b25154b] 1.aaaaa 2.bbbb</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 ss.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过git commit –amend 命令可以查看到刚刚的log信息为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.aaaaa</span><br><span class="line">2.bbbb</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><ul>
<li><p>工作目录 vs 暂存区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff &lt;filename&gt;</span><br><span class="line">意义：查看文件在工作目录与暂存区的差别。如果还没 add 进暂存区，则查看文件自身修改前后的差别。也可查看和另一分支的区别。</span><br><span class="line">git diff &lt;branch&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>暂存区 vs Git仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff --cached &lt;filename&gt;</span><br><span class="line">意义：表示查看已经 add 进暂存区但是尚未 commit 的内容同最新一次 commit 时的内容的差异。 也可以指定仓库版本</span><br><span class="line">git diff --cached &lt;commit&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>工作目录 vs Git仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff &lt;commit&gt; &lt;filename&gt;</span><br><span class="line">意义：查看工作目录同Git仓库指定 commit 的内容的差异。&lt;commit&gt;=HEAD 时：查看工作目录同最近一次 commit 的内容的差异。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Git仓库 vs Git仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff &lt;commit&gt; &lt;commit&gt;</span><br><span class="line">意义：Git仓库任意两次 commit 之间的差别。</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展：<br>以上命令可以不指定 <filename>，则对全部文件操作。<br>以上命令涉及和 Git仓库 对比的，均可指定 commit 的版本。<br>HEAD 最近一次 commit<br>HEAD^ 上次提交<br>HEAD~100 上100次提交<br>每次提交产生的哈希值</filename></p>
</li>
</ul>
<h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><ul>
<li><p>git reset –soft<br>将HEAD引用指向给定提交。索引（暂存区）和工作目录的内容是不变的，在三个命令中对现有版本库状态改动最小。</p>
</li>
<li><p>git reset –mixed（git reset默认的模式）<br>HEAD引用指向给定提交，并且索引（暂存区）内容也跟着改变，工作目录内容不变。这个命令会将索引（暂存区）变成你刚刚暂存该提交全部变化时的状态，会显示工作目录中有什么修改。</p>
</li>
<li><p>git reset –hard<br>HEAD引用指向给定提交，索引（暂存区）内容和工作目录内容都会变给定提交时的状态。也就是在给定提交后所修改的内容都会丢失(新文件会被删除，不在工作目录中的文件恢复，未清除回收站的前提)。</p>
</li>
</ul>
<p><img src="/2020/04/05/git常用命令/git1.png" alt="avatar"></p>
<h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><ul>
<li>git pull –rebase<br>如果远程git服务器仓库分支已经有了更新上，通常git pull时候将会默认执行merge合并提交。相当于执行两个操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git merge origin/master</span><br><span class="line"></span><br><span class="line">实际上除了合并外还有一种方法，那就是执行rebase来同步变化，它通常更有用，git提交历史也更清晰，</span><br><span class="line">rebase方法需要显性指定--rebase参数：</span><br><span class="line"></span><br><span class="line">git pull --rebase ，他相当执行:</span><br><span class="line">git fetch origin</span><br><span class="line">git rebase origin/master</span><br><span class="line"></span><br><span class="line">合并方法更简单，更容易理解。但是很多时候我们更需要的是rebase，我们也可以通过设置，设置rebase为</span><br><span class="line">pull时候默认执行的动作：git config --global pull.rebase true</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git常见场景操作</title>
    <url>/2020/07/10/git%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="1-远程分支"><a href="#1-远程分支" class="headerlink" title="1.远程分支"></a>1.远程分支</h4><p>可以通过 git ls-remote <remote> 来显式地获得远程引用的完整列表， 或者通过 git remote show <remote> 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</remote></remote></p>
<p>git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。</p>
<p><strong>推送</strong><br>如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push <remote> <branch>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin serverfix</span><br><span class="line">Counting objects: 24, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure></branch></remote></p>
<p> 下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> $ git fetch origin</span><br><span class="line">remote: Counting objects: 7, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</span><br></pre></td></tr></table></figure></p>
<p> 可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> $ git checkout -b serverfix origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &apos;serverfix&apos;</span><br></pre></td></tr></table></figure>
<p><strong>跟踪分支</strong></p>
<p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 git checkout -b <branch> <remote>/<branch>。 这是一个十分常用的操作所以 Git 提供了 –track 快捷方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &apos;serverfix&apos;</span><br></pre></td></tr></table></figure></branch></remote></branch></p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> git branch -u origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure>
<p><strong>拉取</strong><br>当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。</p>
<p>由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。</p>
<p><strong>删除远程分支</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure></p>
<h4 id="2-变基"><a href="#2-变基" class="headerlink" title="2. 变基"></a>2. 变基</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i [startpoint] [endpoint]</span><br></pre></td></tr></table></figure>
<p>其中-i的意思是–interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint] [endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个前开后闭的区间)。<br>在查看到了log日志后，我们运行以下命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i 0bb85c 582db9</span><br><span class="line">或者</span><br><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure></p>
<p>上面未被注释的部分列出的是我们本次rebase操作包含的所有提交，下面注释部分是git为我们提供的命令说明。每一个commit id 前面的pick表示指令类型，git 为我们提供了以下几个命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick：保留该commit（缩写:p）</span><br><span class="line">reword：保留该commit，但我需要修改该commit的注释（缩写:r）</span><br><span class="line">edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</span><br><span class="line">squash：将该commit和前一个commit合并（缩写:s）</span><br><span class="line">fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</span><br><span class="line">exec：执行shell命令（缩写:x）</span><br><span class="line">drop：我要丢弃该commit（缩写:d）</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/10/git常见场景操作/git01.png" alt="avatar"></p>
<h4 id="2-常见场景"><a href="#2-常见场景" class="headerlink" title="2. 常见场景"></a>2. 常见场景</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 修改最新commit的message</span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line">2. 怎么修改老旧commit的message</span><br><span class="line">git rebase -i reward</span><br><span class="line"></span><br><span class="line">3. 怎样把连续的多个commit整理成1个</span><br><span class="line"></span><br><span class="line">git rebase -i squash</span><br></pre></td></tr></table></figure>
<h4 id="3-强制禁止命令"><a href="#3-强制禁止命令" class="headerlink" title="3. 强制禁止命令"></a>3. 强制禁止命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 禁止向集成分支</span><br><span class="line">git push -f</span><br><span class="line"></span><br><span class="line">2. 禁止向集成分支执行变更历史的操作</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>goland在mac下的交叉编译</title>
    <url>/2021/03/23/goland%E5%9C%A8mac%E4%B8%8B%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h3 id="Golang在-Mac、Linux、Windows-下交叉编译"><a href="#Golang在-Mac、Linux、Windows-下交叉编译" class="headerlink" title="Golang在 Mac、Linux、Windows 下交叉编译"></a>Golang在 Mac、Linux、Windows 下交叉编译</h3><p><strong>Windows 下编译 Linux 64位系统的可执行程序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=linux</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build main.go</span><br></pre></td></tr></table></figure>
<p><strong>Windows 下编译 macOS 64位系统的可执行程序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build main.go</span><br></pre></td></tr></table></figure>
<p><strong>macOS下编译Linux 64位系统的可执行程序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure>
<p><strong>macOS下编译Windows 64位系统的可执行程序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure>
<p><strong>Linux下编译Windows 64位系统的可执行程序</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure></p>
<p><strong>Linux下编译macOS 64位系统的可执行程序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure>
<p>GOOS： 目标平台的操作系统（darwin、freebsd、linux、windows）<br>GOARCH： 目标平台的体系架构（386、amd64、arm）<br>CGO： 交叉编译不支持 CGO 所以要禁用它</p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang下sync包整理</title>
    <url>/2019/04/04/golang%E4%B8%8Bsync%E5%8C%85%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Locker interface &#123;</span><br><span class="line">        Lock()</span><br><span class="line">        Unlock()</span><br><span class="line">&#125;</span><br><span class="line">互斥锁 Mutex</span><br><span class="line">func (m *Mutex) Lock()</span><br><span class="line">func (m *Mutex) Unlock()</span><br><span class="line">读写锁 RWMutex</span><br><span class="line">func (rw *RWMutex) Lock()</span><br><span class="line">func (rw *RWMutex) Unlock()</span><br><span class="line">func (rw *RWMutex) RLock()</span><br><span class="line">func (rw *RWMutex) RUnlock()</span><br></pre></td></tr></table></figure>
<p>同时只能有一个 goroutine 能够获得写锁定。<br>同时可以有任意多个 gorouinte 获得读锁定。<br>同时只能存在写锁定或读锁定（读和写互斥）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">	var a = 0</span><br><span class="line">	var lock sync.Mutex</span><br><span class="line">	//var rwlock sync.RWMutex</span><br><span class="line">	for i:=0; i&lt;50;i++&#123;</span><br><span class="line">		go func(idx int) &#123;</span><br><span class="line">			lock.Lock()</span><br><span class="line">			defer lock.Unlock()</span><br><span class="line">			a+=1</span><br><span class="line">			fmt.Printf(&quot;goroutine %d, a=%d\n&quot;, idx, a)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Once struct &#123;</span><br><span class="line">        // 非暴露字段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (o *Once) Do(f func())</span><br></pre></td></tr></table></figure>
<p>使用前先定义 Once 类型变量：var once Once<br>使用的时候向 Once 类型变量传入函数：once.Do(func() { init() })<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	testOnce()</span><br><span class="line">&#125;</span><br><span class="line">func testOnce()&#123;</span><br><span class="line">	var once sync.Once</span><br><span class="line">	testOnceFunction := func()&#123;</span><br><span class="line">		fmt.Println(&quot;Only once&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	done := make(chan bool)</span><br><span class="line">	a:=0</span><br><span class="line">	var lock sync.Mutex</span><br><span class="line">	for i:=0;i&lt;10;i++&#123;</span><br><span class="line">		go func()&#123;</span><br><span class="line">			lock.Lock()</span><br><span class="line">			defer lock.Unlock()</span><br><span class="line">			once.Do(testOnceFunction)</span><br><span class="line">			fmt.Println(&quot;a=&quot;,a)</span><br><span class="line">			a++</span><br><span class="line">			done &lt;-true</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	for j:=0;j&lt;10;j++&#123;</span><br><span class="line">		&lt;-done</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Pool</span><br><span class="line">func (p *Pool) Get() interface&#123;&#125;  </span><br><span class="line">func (p *Pool) Put(x interface&#123;&#125;)  </span><br><span class="line">New func() interface&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个类设计的目的是用来保存和复用临时对象，以减少内存分配，降低CG压力。<br>Get返回Pool中的任意一个对象。<br>如果Pool为空，则调用New返回一个新创建的对象。<br>如果没有设置New，则返回nil。<br>还有一个重要的特性是，放进Pool中的对象，会在说不准什么时候被回收掉。<br>所以如果事先Put进去100个对象，下次Get的时候发现Pool是空也是有可能的。<br>不过这个特性的一个好处就在于不用担心Pool会一直增长，因为Go已经帮你在Pool中做了回收机制。<br>这个清理过程是在每次垃圾回收之前做的。垃圾回收是固定两分钟触发一次。<br>而且每次清理会将Pool中的所有对象都清理掉！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">    // 建立对象</span><br><span class="line">    var pipe = &amp;sync.Pool&#123;New:func()interface&#123;&#125;&#123;return &quot;Hello,BeiJing&quot;&#125;&#125;</span><br><span class="line">    // 准备放入的字符串</span><br><span class="line">    val := &quot;Hello,World!&quot;</span><br><span class="line">    // 放入</span><br><span class="line">    pipe.Put(val)</span><br><span class="line">    // 取出</span><br><span class="line">    log.Println(pipe.Get())</span><br><span class="line">    // 再取就没有了,会自动调用NEW</span><br><span class="line">    log.Println(pipe.Get())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go基础整理</title>
    <url>/2019/04/05/go%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="main函数和init函数"><a href="#main函数和init函数" class="headerlink" title="main函数和init函数"></a>main函数和init函数</h4><p>&emsp;&emsp;Go里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main）。这两个函数在定义时不能有任何的参数和返回值。虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个package中每个文件只写一个init函数。<br>&emsp;&emsp;Go程序会自动调用init()和main()，所以你不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。<br>&emsp;&emsp;程序的初始化和执行都起始于main包。如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。</p>
<h4 id="json处理"><a href="#json处理" class="headerlink" title="json处理"></a>json处理</h4><p>json 中提供的处理 json 的标准包是 encoding/json,主要使用的是以下两个方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 序列化</span><br><span class="line">func Marshal(v interface&#123;&#125;) ([]byte, error)</span><br><span class="line">// 反序列化</span><br><span class="line">func Unmarshal(data []byte, v interface&#123;&#125;) error</span><br><span class="line">序列化前后的数据结构有以下的对应关系：</span><br><span class="line">bool, for JSON booleans</span><br><span class="line">float64, for JSON numbers</span><br><span class="line">string, for JSON strings</span><br><span class="line">[]interface&#123;&#125;, for JSON arrays</span><br><span class="line">map[string]interface&#123;&#125;, for JSON objects</span><br><span class="line">nil for JSON null</span><br></pre></td></tr></table></figure></p>
<p>Unmarshal<br>这是一个反序列化的过程，将 JSON 串重新组装成结构体。<br>已知类型解析<br>JSON 解析的时候只会解析能找得到的字段，找不到的字段会被忽略，这样的一个好处是：当你接收到一个很大的 JSON 数据结构而你却只想获取其中的部分数据的时候，你只需将你想要的数据对应的字段名大写，即可轻松解决这个问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;encoding/json&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">type Animal struct &#123;</span><br><span class="line">    Name  string</span><br><span class="line">    Order string</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var jsonBlob = []byte(`[</span><br><span class="line">        &#123;&quot;Name&quot;: &quot;Platypus&quot;, &quot;Order&quot;: &quot;Monotremata&quot;&#125;,</span><br><span class="line">        &#123;&quot;Name&quot;: &quot;Quoll&quot;,    &quot;Order&quot;: &quot;Dasyuromorphia&quot;&#125;</span><br><span class="line">    ]`)</span><br><span class="line"></span><br><span class="line">    var animals []Animal</span><br><span class="line">    err := json.Unmarshal(jsonBlob, &amp;animals)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;error:&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%+v&quot;, animals)</span><br></pre></td></tr></table></figure></p>
<p>未知解析类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f interface&#123;&#125;</span><br><span class="line">b := []byte(`&#123;&quot;Name&quot;:&quot;Wednesday&quot;,&quot;Age&quot;:6,&quot;Parents&quot;:[&quot;Gomez&quot;,&quot;Morticia&quot;]&#125;`)</span><br><span class="line">json.Unmarshal(b, &amp;f)</span><br><span class="line">for k, v := range f.(map[string]interface&#123;&#125;) &#123;</span><br><span class="line">    switch vv := v.(type) &#123;</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Println(k, &quot;is string&quot;, vv)</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Println(k, &quot;is int &quot;, vv)</span><br><span class="line">    case float64:</span><br><span class="line">        fmt.Println(k, &quot;is float64 &quot;, vv)</span><br><span class="line">    case []interface&#123;&#125;:</span><br><span class="line">        fmt.Println(k, &quot;is array:&quot;)</span><br><span class="line">        for i, j := range vv &#123;</span><br><span class="line">            fmt.Println(i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Marshal<br>这是序列化的过程，将结构体序列化成一个 JSON 串。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;encoding/json&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">type Animal struct &#123;</span><br><span class="line">    Name  string `json:&quot;name&quot;`</span><br><span class="line">    Order string `json:&quot;order&quot;`</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var animals []Animal</span><br><span class="line">    animals = append(animals, Animal&#123;Name: &quot;Platypus&quot;, Order: &quot;Monotremata&quot;&#125;)</span><br><span class="line">    animals = append(animals, Animal&#123;Name: &quot;Quoll&quot;, Order: &quot;Dasyuromorphia&quot;&#125;)</span><br><span class="line"></span><br><span class="line">    jsonStr, err := json.Marshal(animals)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;error:&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(string(jsonStr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>json tag 有很多值可以取，同时有着不同的含义，比如：<br>tag 是 “-“，表示该字段不会输出到 JSON.<br>tag 中带有自定义名称，那么这个自定义名称会出现在 JSON 的字段名中，比如上面小写字母开头的 name.<br>tag 中带有 “omitempty” 选项，那么如果该字段值为空，就不会输出到JSON 串中.<br>如果字段类型是 bool, string, int, int64 等，而 tag 中带有”,string” 选项，那么该字段在输出到 JSON 时，会把该字段对应的值转换成 JSON 字符串.</p>
<h4 id="net-http包处理请求"><a href="#net-http包处理请求" class="headerlink" title="net/http包处理请求"></a>net/http包处理请求</h4><h4 id="golang类型断言"><a href="#golang类型断言" class="headerlink" title="golang类型断言"></a>golang类型断言</h4><p>类型断言是一个使用在接口值上的操作<br>有时候，我们可能需要知道某个接口类型的实际类型，比如某个方法需要接收多种类型的数据并需做分别处理时，我们可以把形参设为空接口类型以接收任意类型的值，但是我们怎么反向知道里面实际保存了的是哪个类型的对象呢？<br>• Comma-ok 断言语法<br>value,ok := x.(T)<br>x表示一个接口的类型，T表示一个类型（也可为接口类型）<br>该断言表达式会返回x的值和一个布尔值 可根据该布尔值判断x是否为T类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var x interface&#123;&#125;</span><br><span class="line">    x = 10</span><br><span class="line">    value, ok := x.(int)</span><br><span class="line">    fmt.Print(value, &quot;,&quot;, ok)</span><br><span class="line">&#125;</span><br><span class="line">func judgeType(a interface&#123;&#125;) &#123;</span><br><span class="line">    switch a.(type) &#123;</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Println(&quot;the type of a is int&quot;)</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Println(&quot;the type of a is string&quot;)</span><br><span class="line">    case float64:</span><br><span class="line">        fmt.Println(&quot;the type of a is float&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;unknown type&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>hypervisor学习总结</title>
    <url>/2019/09/08/hypervisor%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="什么是hypervisor"><a href="#什么是hypervisor" class="headerlink" title="什么是hypervisor"></a>什么是hypervisor</h4><p>  Hypervisor是一种将操作系统与硬件抽象分离的方法，以达到host machine的硬件能同时运行一个至多个虚拟机作为guest machine的目的 ，这样能够使得这些虚拟机 高 效地分享主机硬件资源。</p>
<h4 id="hypervisor的优点"><a href="#hypervisor的优点" class="headerlink" title="hypervisor的优点"></a>hypervisor的优点</h4><ol>
<li>提高主机硬件的使用效率。因为一个主机可以运行多个虚拟机，这样主机的硬件资源能被高效充分的利用起来。</li>
<li>虚拟机移动性强。传统软件强烈捆绑在硬件上，转移一个软件至另一个服务器上耗时耗力（比如重新安装）；然而，虚拟机与硬件是独立的，这样使得虚拟机可以在本地或远程虚拟服务器上低消耗转移。</li>
<li>虚拟机彼此独立。一个虚拟机的奔溃不会影响其他分享同一硬件资源的虚拟机，大大提升安全性。</li>
<li>易保护，易恢复。Snapshot技术可以记录下某一时间点下的虚拟机状态，这使得虚拟机在错误发生后能快速恢复。</li>
</ol>
<h4 id="hypervisor的分类"><a href="#hypervisor的分类" class="headerlink" title="hypervisor的分类"></a>hypervisor的分类</h4><p>bare-metal hypervisors：直接部署在主机硬件上，以管理硬件和guest machine。<br>hosted hypervisors：作为软件层部署在主机操作系统上，现在常用的VMware Player和VirtualBox就是这种类型。<br><img src="/2019/09/08/hypervisor学习总结/server_virt-hypervisor.jpg" alt="avatar"></p>
<p>类型I：本地或裸机Hypervisor<br>这些虚拟机管理程序直接运行在主机的硬件来控制硬件和管理客体操作系统上。<br>特点<br>需要硬件支持<br>虚拟机监视器作为主操作系统<br>运行效率高<br>类型II：Hosted Hypervisor<br>这些虚拟机管理程序运行在传统的操作系统上，就像其他计算机程序那样运行。<br>特点<br>虚拟机监视器作为应用程序运行在主操作系统环境内<br>运行效率一般较类型I低</p>
<h4 id="虚拟化技术的对比"><a href="#虚拟化技术的对比" class="headerlink" title="虚拟化技术的对比"></a>虚拟化技术的对比</h4><table>
<thead>
<tr>
<th>类型</th>
<th>代表产品 </th>
</tr>
</thead>
<tbody>
<tr>
<td>硬件分区</td>
<td>IBM/HP等大型机硬件分区技术 </td>
</tr>
<tr>
<td>虚拟机 （Virtual Machine Monitor）</td>
<td>EMC VMware Mircosoft Virtual PC/Server Parallels </td>
</tr>
<tr>
<td>准虚拟机 （Para-Virtualization）</td>
<td>Xen Project</td>
</tr>
<tr>
<td>虚拟操作系统 （OS Virtualization）</td>
<td>SWsoft Virtuozzo/OpenVZ Project Sun Solaris Container  HP vSE FreeBSD Jail Linux Vserver</td>
</tr>
</tbody>
</table>
<h4 id="QEMU和KVM"><a href="#QEMU和KVM" class="headerlink" title="QEMU和KVM"></a>QEMU和KVM</h4><p><strong> 基本概念 </strong><br>在 x86 平台上最热门运用最广泛的虚拟化方案莫过于KVM了。KVM 全称是 Kernel-Based Virtual Machine 。也就是说KVM是基于Linux内核实现的。 KVM有一个内核模 块叫kvm.ko，只用于管理虚拟CPU和内存。那 IO 的虚拟化，比如存储和网络设备由谁实现呢？这个就交给 Linux 内核和Qemu来实现。说白了，作为一个 Hypervisor，KVM 本身只关注虚拟机调度和内存管理这两个方面。IO 外设的任务交给 Linux 内核和 Qemu。<br><strong> Libvirt </strong><br>简单说就是 KVM 的管理工具。其实，Libvirt 除了能管理 KVM 这种 Hypervisor，还能管理 Xen，VirtualBox 等。<br>Libvirt 包含 3 个东西：后台 daemon 程序 libvirtd、API 库和命令行工具 virsh<br>libvirtd是服务程序，接收和处理 API 请求；<br>API 库使得其他人可以开发基于 Libvirt 的高级工具，比如 virt-manager，这是个图形化的 KVM 管理工具，后面我们也会介绍；<br>virsh 是我们经常要用的 KVM 命令行工具，后面会有使用的示例。<br><strong> KVM </strong><br>Kernel-Based Virtual Machine 基于内核的虚拟机，是Linux内核的一个可加载模块，通过调用Linux本身内核功能，实现对CPU的底层虚拟化和内存的虚拟化，使Linux内核成为虚拟化层，需要x86架构的，支持虚拟化功能的硬件支持（比如Intel-VT，AMD-V），是一种全虚拟化架构。KVM在2007年2月被导入Linux 2.6.20内核中。从存在形式来看，它包括两个内核模块：kvm.ko 和 kvm_intel.ko（或kvm_amd.ko），本质上，KVM是管理虚拟硬件设备的驱动，该驱动使用字符设备/dev/kvm（由KVM本身创建）作为管理接口，主要负责vCPU的创建，虚拟内存的分配，vCPU寄存器的读写以及vCPU的运行。<br><strong> QEMU </strong><br>QEMU：是一套由Fabrice Bellard编写的模拟处理器的自由软件，它是一个完整的可以单独运行的软件，可以独立模拟出整台计算机，包括CPU，内存，IO设备，通过一个特殊的“重编译器”对特定的处理器的二进制代码进行翻译，从而具有了跨平台的通用性。QEMU有两种工作模式：系统模式，可以模拟出整个电脑系统，另一种是用户模式，可以运行不同与当前硬件平台的其他平台上的程序（比如在x86平台上运行跑在ARM平台上的程序）；其代码地址 <a href="http://git.qemu.org/qemu.git" target="_blank" rel="noopener">http://git.qemu.org/qemu.git</a> ，有兴趣的同学可以自己去看看，目前最新的版本是2.7.0，在0.9.1及之前版本还可以使用kqemu加速器（可以理解为QEMU的一个插件，用来提高QEMU的翻译性能，支持Windows平台），但1.0以后版本就只能使用qemu-kvm（只支持Linux）进行加速了，1.3版本后QEMU和QEMU-KVM合二为一了。<br><strong> QEMU-KVM </strong><br>QEMU-KVM：从前面对KVM内核模块的介绍知道，它只负责CPU和内存的虚拟化，加载了它以后，用户就可以进一步通过工具创建虚拟机（KVM提供接口），但仅有KVM还是不够的，用户无法直接控制内核去做事情（KVM只提供接口，怎么创建虚拟机，分配vCPU等并不在它上面进行），还必须有个运行在用户空间的工具才行，KVM的开发者选择了比较成熟的开源虚拟化软件QEMU来作为这个工具，并对其进行了修改，最后形成了QEMU-KVM。</p>
<p>在QEMU-KVM中，KVM运行在内核空间，QEMU运行在用户空间，实际模拟创建，管理各种虚拟硬件，QEMU将KVM整合了进来，通过/ioctl 调用 /dev/kvm，从而将CPU指令的部分交给内核模块来做，KVM实现了CPU和内存的虚拟化，但kvm不能虚拟其他硬件设备，因此qemu还有模拟IO设备（磁盘，网卡，显卡等）的作用，KVM加上QEMU后就是完整意义上的服务器虚拟化。当然，由于qemu模拟io设备效率不高的原因，现在常常采用半虚拟化的virtio方式来虚拟IO设备。</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://blog.csdn.net/JackLiu16/article/details/79462698" target="_blank" rel="noopener">https://blog.csdn.net/JackLiu16/article/details/79462698</a><br><a href="https://blog.csdn.net/hdy007/article/details/1518425" target="_blank" rel="noopener">https://blog.csdn.net/hdy007/article/details/1518425</a></p>
]]></content>
  </entry>
  <entry>
    <title>java中的clone小结</title>
    <url>/2020/07/06/java%E4%B8%AD%E7%9A%84clone%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p>
<p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p>
<p><img src="/2020/07/06/java中的clone小结/clone.png" alt="avatar"></p>
<h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">	// 创建父亲(LiLiu)，儿子(LiWu)，孙子（LiLiu）并关联</span><br><span class="line">	Son father = new Son();</span><br><span class="line">	father.setName(&quot;LiSi&quot;);</span><br><span class="line">	Son son = new Son();</span><br><span class="line">	son.setName(&quot;LiWu&quot;);</span><br><span class="line">	Son grandSon = new Son();</span><br><span class="line">	grandSon.setName(&quot;LiLiu&quot;);</span><br><span class="line">	father.setSon(son);</span><br><span class="line">	son.setSon(grandSon);</span><br><span class="line">	// 调用clone方法</span><br><span class="line">	Son fatherCopy =  (Son) father.clone();</span><br><span class="line">	boolean flag1 = fatherCopy==father;</span><br><span class="line">	boolean flag2 = fatherCopy.getSon() == son;</span><br><span class="line">	boolean flag3 = fatherCopy.getSon().getSon() == grandSon;</span><br><span class="line">	// 比较克隆后的地址</span><br><span class="line">	System.out.println(flag1);// false</span><br><span class="line">	System.out.println(flag2);// true</span><br><span class="line">	System.out.println(flag3);// true</span><br><span class="line">	// 比较Name</span><br><span class="line">	flag1= fatherCopy.getName()==father.getName();</span><br><span class="line">	flag2 = fatherCopy.getSon().getName() == son.getName();</span><br><span class="line">	flag3 = fatherCopy.getSon().getSon().getName() == grandSon.getName();</span><br><span class="line">	System.out.println(flag1);// true</span><br><span class="line">	System.out.println(flag2);// true</span><br><span class="line">	System.out.println(flag3);// true</span><br><span class="line">	</span><br><span class="line">	//将对象写到流里    </span><br><span class="line">	ByteArrayOutputStream byteOut=new ByteArrayOutputStream();    </span><br><span class="line">	ObjectOutputStream objOut=new ObjectOutputStream(byteOut);    </span><br><span class="line">	objOut.writeObject(father);</span><br><span class="line">	//从流里读出来    </span><br><span class="line">	ByteArrayInputStream byteIn=new ByteArrayInputStream(byteOut.toByteArray());    </span><br><span class="line">	ObjectInputStream objInput=new ObjectInputStream(byteIn);</span><br><span class="line">    fatherCopy = (Son) objInput.readObject();</span><br><span class="line">	flag1= fatherCopy==father;</span><br><span class="line">	flag2 = fatherCopy.getSon() == son;</span><br><span class="line">	flag3 = fatherCopy.getSon().getSon() == grandSon;</span><br><span class="line">	System.out.println(flag1);// false</span><br><span class="line">	System.out.println(flag2);// false</span><br><span class="line">	System.out.println(flag3);// false</span><br><span class="line">	</span><br><span class="line">	// 比较Name</span><br><span class="line">	flag1= fatherCopy.getName()==father.getName();</span><br><span class="line">	flag2 = fatherCopy.getSon().getName() == son.getName();</span><br><span class="line">	flag3 = fatherCopy.getSon().getSon().getName() == grandSon.getName();</span><br><span class="line">	System.out.println(flag1);// false</span><br><span class="line">	System.out.println(flag2);// false</span><br><span class="line">	System.out.println(flag3);// false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上文代码及运行结果不难看出，如果对象实现Cloneable并重写clone方法不进行任何操作时,调用clone是进行的浅克隆。而使用对象流将对象写入流然后再读出是进行的深克隆。</p>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CloneUtils &#123;</span><br><span class="line">  </span><br><span class="line">    private static final Logger LOG = LoggerFactory.getLogger(CloneUtils.class);</span><br><span class="line"></span><br><span class="line">    private CloneUtils&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T extends Serializable&gt; T clone(T obj)&#123;</span><br><span class="line">        T cloneObj = null;</span><br><span class="line">        ByteArrayOutputStream out = null;</span><br><span class="line">        ByteArrayInputStream in = null;</span><br><span class="line">        </span><br><span class="line">        try&#123;</span><br><span class="line">            </span><br><span class="line">            out = new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream obs = new ObjectOutputStream(out);</span><br><span class="line">            obs.writeObject(obj);</span><br><span class="line">            obs.close();</span><br><span class="line"></span><br><span class="line">            ios = new ByteArrayInputStream(out.toByteArray());</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(ios);</span><br><span class="line">            cloneObj = (T)ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line"></span><br><span class="line">        &#125;catch(Exception ex)&#123;</span><br><span class="line">            LOG.error(&quot;拷贝对象时发生异常&quot;, e1);</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            try()&#123;</span><br><span class="line">                if(null != out)&#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">                if(null != in)&#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch(Exception ex)&#123;</span><br><span class="line">                LOG.warn(&quot;关闭字节流时发生异常&quot;, e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://www.cnblogs.com/liqiangchn/p/9465186.html" target="_blank" rel="noopener">https://www.cnblogs.com/liqiangchn/p/9465186.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java日志体系二(slf4j作用及其实现原理)</title>
    <url>/2020/04/26/java%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB%E4%BA%8C/</url>
    <content><![CDATA[<h4 id="简单回顾门面模式"><a href="#简单回顾门面模式" class="headerlink" title="简单回顾门面模式"></a>简单回顾门面模式</h4><p>slf4j是门面模式的典型应用，因此在讲slf4j前，我们先简单回顾一下门面模式，</p>
<p>门面模式，其核心为外部与一个子系统的通信必须通过一个统一的外观对象进行，使得子系统更易于使用。用一张图来表示门面模式的结构为：<br><img src="/2020/04/26/java日志体系二/facade.png" alt="avatar"></p>
<p>门面模式的核心为Facade即门面对象，门面对象核心为几个点：</p>
<ul>
<li>知道所有子角色的功能和责任</li>
<li>将客户端发来的请求委派到子系统中，没有实际业务逻辑</li>
<li>不参与子系统内业务逻辑的实现</li>
</ul>
<p>大致上来看，对门面模式的回顾到这里就可以了，开始接下来对SLF4J的学习。</p>
<h4 id="我们为什么要使用slf4j"><a href="#我们为什么要使用slf4j" class="headerlink" title="我们为什么要使用slf4j"></a>我们为什么要使用slf4j</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们自己的系统中使用了logback这个日志系统</span><br><span class="line">我们的系统使用了A.jar，A.jar中使用的日志系统为log4j</span><br><span class="line">我们的系统又使用了B.jar，B.jar中使用的日志系统为slf4j-simple</span><br><span class="line"></span><br><span class="line">这样，我们的系统就不得不同时支持并维护logback、log4j、slf4j-simple三种日志框架，非常不便。</span><br></pre></td></tr></table></figure>
<p>解决这个问题的方式就是引入一个适配层，由适配层决定使用哪一种日志系统，而调用端只需要做的事情就是打印日志而不需要关心如何打印日志，slf4j或者commons-logging就是这种适配层，slf4j是本文研究的对象。</p>
<p>从上面的描述，我们必须清楚地知道一点：slf4j只是一个日志标准，并不是日志系统的具体实现。理解这句话非常重要，slf4j只做两件事情：</p>
<ul>
<li>提供日志接口</li>
<li>提供获取具体日志对象的方法</li>
</ul>
<p>slf4j-simple、logback都是slf4j的具体实现，log4j并不直接实现slf4j，但是有专门的一层桥接slf4j-log4j12来实现slf4j。</p>
<p>为了更理解slf4j，我们先看例子，再读源码，相信读者朋友会对slf4j有更深刻的认识。</p>
<h4 id="slf4j应用举例"><a href="#slf4j应用举例" class="headerlink" title="slf4j应用举例"></a>slf4j应用举例</h4><p>上面讲了，slf4j的直接/间接实现有slf4j-simple、logback、slf4j-log4j12，我们先定义一个pom.xml，引入相关jar包：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.wukong.learn&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;paopaozhu&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;paopaozhu&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.apache.org&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p>写一段简单的Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">  @Test</span><br><span class="line">   public void testSlf4j() &#123;</span><br><span class="line"></span><br><span class="line">       Logger logger = LoggerFactory.getLogger(Object.class);</span><br><span class="line">       logger.info(&quot;123&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>看到没有任何日志的输出，这验证了我们的观点：slf4j不提供日志的具体实现，只有slf4j是无法打印日志的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc[17409]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java (0x1043044c0) and /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/libinstrument.dylib (0x1053d64e0). One of the two will be used. Which one is undefined.</span><br><span class="line">Connected to the target VM, address: &apos;127.0.0.1:51663&apos;, transport: &apos;socket&apos;</span><br><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span><br><span class="line">Disconnected from the target VM, address: &apos;127.0.0.1:51663&apos;, transport: &apos;socket&apos;</span><br></pre></td></tr></table></figure></p>
<p>接着打开logback-classic的注释，运行Test方法，我们看一下控制台的输出为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc[17360]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java (0x108f494c0) and /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/libinstrument.dylib (0x10a01b4e0). One of the two will be used. Which one is undefined.</span><br><span class="line">Connected to the target VM, address: &apos;127.0.0.1:51630&apos;, transport: &apos;socket&apos;</span><br><span class="line">14:51:51.477 [main] INFO java.lang.Object - 123</span><br><span class="line">Disconnected from the target VM, address: &apos;127.0.0.1:51630&apos;, transport: &apos;socket&apos;</span><br></pre></td></tr></table></figure></p>
<p>看到我们只要引入了一个slf4j的具体实现类，即可使用该日志框架输出日志。</p>
<p>最后做一个测验，我们把所有日志打开，引入logback-classic、slf4j-simple、log4j，运行Test方法，控制台输出为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc[17324]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java (0x104b2e4c0) and /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/libinstrument.dylib (0x10640b4e0). One of the two will be used. Which one is undefined.</span><br><span class="line">Connected to the target VM, address: &apos;127.0.0.1:51595&apos;, transport: &apos;socket&apos;</span><br><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/Users/zyy/.m2/repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/Users/zyy/.m2/repository/org/slf4j/slf4j-simple/1.7.25/slf4j-simple-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/Users/zyy/.m2/repository/org/slf4j/slf4j-log4j12/1.7.21/slf4j-log4j12-1.7.21.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder]</span><br><span class="line">14:48:05.808 [main] INFO java.lang.Object - 123</span><br><span class="line">Disconnected from the target VM, address: &apos;127.0.0.1:51595&apos;, transport: &apos;socket&apos;</span><br></pre></td></tr></table></figure></p>
<p>和上面的差别是，可以输出日志，但是会输出一些告警日志，提示我们同时引入了多个slf4j的实现，然后选择其中的一个作为我们使用的日志系统。</p>
<p>从例子我们可以得出一个重要的结论，即slf4j的作用：只要所有代码都使用门面对象slf4j，我们就不需要关心其具体实现，最终所有地方使用一种具体实现即可，更换、维护都非常方便。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java线程池小结</title>
    <url>/2021/06/17/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p><strong>什么是线程池？</strong></p>
<p>一种线程管理模式。线程维护着多个线程，等待着分配可并发执行的任务。这避免了在处理短时间任务时创建和销毁线程的代价，进而影响影响缓存性能。线程池不仅不仅保证内核的充分利用，还能防止过分调度。</p>
<p><strong>线程池的意义</strong></p>
<p>循环利用线程资源，避免重复创建和销毁线程</p>
<p>线程池的任务是异步执行的，只要提交完成就能快速返回，可以提高应用响应性</p>
<p>Java线程池还有一个很重要的意义：Java线程池就是JDK 5 推出的Executor框架，在此之前Java线程既是工作任务又是执行机制，而Executor框架把工作任务与执行机制分离开来：工作任务包括Runnable接口和Callable接口，而执行机制由Executor接口提供。</p>
<p><strong>Java中四种线程池</strong></p>
<ol>
<li>newFixedThreadExecutor() ： 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ks.cfg详解</title>
    <url>/2021/02/04/ks-cfg%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Kickstart文件中的主要项目及参数介绍(ks.cfg)：</p>
<p>每个项目都由关键字来识别；关键字可跟一个或多个参数；如果某选项后面跟随了一个等号（=），它后面就必须指定一个值。</p>
<p>install (可选)<br>明确指定系统次次进行的是全新安装系统；是默认项；</p>
<p>cdrom （可选）<br>以本地CD-ROM为源安装系统；</p>
<p>harddrive (可选)<br>以硬盘分区中包含的镜像为源（安装树）安装新系统；当以该种方式安装系统时，即使指定clearpart –all项，源所在分区也不会被重新抹去；<br>–partition= 指定分区<br>–dir= 指定包含镜像的目录<br>例：<br>harddrive –partition=/dev/sdb2 –dir=/data/iso</p>
<p>nfs (可选)<br>指定从NFS服务器上获取安装树；<br>–server= 指定NFS服务器，主机名称或IP<br>–dir= 包含安装树的目录<br>–opts= 可以指定挂载NFS的目录时的挂载选项<br>例：<br>nfs –server=192.168.1.254 –dir=/data/iso</p>
<p>url (可选)<br>指定通过FTP或HTTP从网络获取安装树；<br>–url 指定资源位置<br>例：<br>url –url ftp://<username>:<password>@install.example.com/iso<br>url –url <a href="http://install.example.com/iso" target="_blank" rel="noopener">http://install.example.com/iso</a></password></username></p>
<p>bootloader （必需）<br>设定boot loader安装选项；<br>–append= 可以指定内核参数<br>–driveorder= 设定设备BIOS中的开机设备启动顺序<br>–location= 设定引导记录的位置； mbr：默认值；partition：将boot loader安装于包含kernel的分区超级快中；none：不安装boot loder。<br>示例：<br>bootloader –location=mbr –append=“rhgb quiet” –driveorder=sda,sdb</p>
<p>clearpart （可选）<br>在建立新分区前清空系统上原有的分区表，默认不删除分区；<br>–all 擦除系统上原有所有分区；<br>–drives 删除指定驱动器上的分区<br>–initlabel 初始化磁盘卷标为系统架构的默认卷标<br>–linux 擦除所有的linux分区<br>–none（default）不移除任何分区<br>例：<br>clearpart –drives=hda,hdb –all –initlabel</p>
<p>zerombr （可选）<br>清除mbr信息，会同时清空系统用原有分区表</p>
<p>drivedisk （可选）<br>如果使用特殊存储方式时，需要指定驱动程序盘位置以便加载存储驱动；</p>
<p>firewall （可选）<br>配置系统防火墙选项；<br>firewall –enable|–disable [ –trust ] <device> [ –port= ]<br>–enable 拒绝外部发起的任何主动连接；<br>–disable 不配置任何iptables防御规则；<br>–trust 指定完全信任网卡设备；<br>–port 使用port:protocol格式指定可以通过防火墙的服务；<br>示例：<br>firewall –enable –trust eth0 –trust eth1 –port=80:tcp</device></p>
<p>selinux （可选）<br>设置系统selinux状态；默认为启用并处于enforcing模式；<br>selinux [ –disabled|–enforcing|–premissive ]</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux网卡</title>
    <url>/2021/01/22/linux%E7%BD%91%E5%8D%A1/</url>
    <content><![CDATA[<h3 id="查看全部网卡"><a href="#查看全部网卡" class="headerlink" title="查看全部网卡"></a>查看全部网卡</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目录 /sys/class/net/</span><br><span class="line"></span><br><span class="line">ls /sys/class/net/</span><br><span class="line">br-df65b94a220f  docker0  enp0s31f6  lo</span><br></pre></td></tr></table></figure>
<h3 id="查看虚拟网卡"><a href="#查看虚拟网卡" class="headerlink" title="查看虚拟网卡"></a>查看虚拟网卡</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目录 /sys/devices/virtual/net/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ls /sys/devices/virtual/net/</span><br><span class="line">br-df65b94a220f  docker0  lo  veth1706661</span><br></pre></td></tr></table></figure>
<h3 id="查看物理网卡"><a href="#查看物理网卡" class="headerlink" title="查看物理网卡"></a>查看物理网卡</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls /sys/class/net/ | grep -v &quot;`ls /sys/devices/virtual/net/`&quot;</span><br><span class="line"></span><br><span class="line">enp0s31f6</span><br><span class="line">wlp1s0</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>logrotate小结</title>
    <url>/2021/03/12/logrotate%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>对于Linux 的系统安全来说，日志文件是极其重要的工具。系统管理员可以使用logrotate 程序用来管理系统中的最新的事件，对于Linux 的系统安全来说，日志文件是极其重要的工具。系统管理员可以使用logrotate 程序用来管理系统中的最新的事件， 还可以用来备份日志文件。</p>
<h3 id="logrotate-命令使用"><a href="#logrotate-命令使用" class="headerlink" title="logrotate 命令使用"></a>logrotate 命令使用</h3><p>功能说明：管理记录文件。</p>
<p>语　　法：logrotate [-?dfv][-s &lt;状态文件&gt;][–usage][配置文件]</p>
<p>补充说明：使用logrotate指令，可让你轻松管理系统所产生的记录文件。它提供自动替换，压缩，删除和邮寄记录文件，每个记录文件都可被设置成每日，每周或每月处理，也能在文件太大时立即处理。您必须自行编辑，指定配置文件，预设的配置文件存放在/etc目录下，文件名称为logrotate.conf。</p>
<p>　参　　数：<br>　-?或–help 　在线帮助。<br>　-d或–debug 　详细显示指令执行过程，便于排错或了解程序执行的情况。<br>　-f或–force 　强行启动记录文件维护操作，纵使logrotate指令认为没有需要亦然。<br>　-s&lt;状态文件&gt;或–state=&lt;状态文件&gt; 　使用指定的状态文件。<br>　-v或–version 　显示指令执行过程。<br>　-usage 　显示指令基本用法。</p>
<p>logrotate最常用的三个方式为：<br>logrotate /etc/logrotate.conf：重新读取配置文件，并对符合条件的文件文件进行rotate。<br>logrotate -d /etc/logrotate.conf：调试模式，输出调试结果，但并不执行。<br>logrotate -f /etc/logrotate.conf：强制模式，对所有相关文件进行rotate。</p>
<h3 id="logrotate-配置"><a href="#logrotate-配置" class="headerlink" title="logrotate 配置"></a>logrotate 配置</h3><p>logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件，我们把它叫做“转储”。我们可以根据日志文件的大小，也可以根据其天数来转储，这个过程一般通过 cron 程序来执行。<br>logrotate 程序还可以用于压缩日志文件，以及发送日志到指定的E-mail 。</p>
<p>logrotate 的配置文件是 /etc/logrotate.conf。主要参数如下表：</p>
<p>配置参数 　　　功能说明<br>compress 　　通过gzip 压缩转储以后的日志<br>nocompress 　不需要压缩时，用这个参数<br>copytruncate 　用于还在打开中的日志文件，把当前日志备份并截断<br>nocopytruncate 　备份日志文件但是不截断<br>create mode owner group 　　转储文件，使用指定的文件模式创建新的日志文件<br>nocreate 　　不建立新的日志文件<br>delaycompress 和 compress 　　一起使用时，转储的日志文件到下一次转储时才压缩<br>nodelaycompress 　　 delaycompress 选项，转储同时压缩。<br>errors address 　　专储时的错误信息发送到指定的Email 地址<br>ifempty 　　即使是空文件也转储，这个是 logrotate 的缺省选项。<br>notifempty　　 如果是空文件的话，不转储<br>mail address 　　把转储的日志文件发送到指定的E-mail 地址<br>nomail 　　转储时不发送日志文件<br>olddir directory 　　转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统<br>noolddir 　　转储后的日志文件和当前日志文件放在同一个目录下<br>prerotate/endscript 　　在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行<br>postrotate/endscript 　　在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行<br>daily 　　指定转储周期为每天<br>weekly 　　指定转储周期为每周<br>monthly 　　指定转储周期为每月<br>rotate count 　　指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份<br>tabootext [+] list 让logrotate 　　不转储指定扩展名的文件，缺省的扩展名是：.rpm-orig, .rpmsave, v, 和 ~<br>size 　size当日志文件到达指定的大小时才转储，Size 可以指定 bytes (缺省)以及KB (sizek)或者MB (sizem).</p>
<h3 id="logrotate-默认配置文件"><a href="#logrotate-默认配置文件" class="headerlink" title="logrotate 默认配置文件"></a>logrotate 默认配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># see &quot;man logrotate&quot; for details</span><br><span class="line"># rotate log files weekly</span><br><span class="line">weekly</span><br><span class="line"></span><br><span class="line"># keep 4 weeks worth of backlogs</span><br><span class="line">rotate 4</span><br><span class="line"></span><br><span class="line"># send errors to root</span><br><span class="line">errors root</span><br><span class="line"># create new (empty) log files after rotating old ones</span><br><span class="line">create</span><br><span class="line"></span><br><span class="line"># uncomment this if you want your log files compressed</span><br><span class="line">#compress</span><br><span class="line"></span><br><span class="line"># RPM packages drop log rotation information into this directory</span><br><span class="line">include /etc/logrotate.d</span><br><span class="line"></span><br><span class="line"># no packages own lastlog or wtmp --we&apos;ll rotate them here</span><br><span class="line">/var/log/wtmp &#123;</span><br><span class="line">monthly</span><br><span class="line">create 0664 root utmp</span><br><span class="line">rotate 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/var/log/lastlog &#123;</span><br><span class="line">monthly</span><br><span class="line">rotate 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># system-specific logs may be configured here</span><br></pre></td></tr></table></figure>
<h3 id="使用include-选项覆盖缺省配置"><a href="#使用include-选项覆盖缺省配置" class="headerlink" title="使用include 选项覆盖缺省配置"></a>使用include 选项覆盖缺省配置</h3><p>当/etc/logrotate.conf读入文件时，include指定的文件中的转储参数将覆盖缺省的参数，如下例：<br>linuxconf文件的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/var/log/htmlaccess.log &#123; </span><br><span class="line"> errors jim</span><br><span class="line"> notifempty</span><br><span class="line"> nocompress</span><br><span class="line"> weekly</span><br><span class="line"> prerotate</span><br><span class="line"> /usr/bin/chattr -a /var/log/htmlaccess.log</span><br><span class="line"> endscript</span><br><span class="line"></span><br><span class="line"> postrotate</span><br><span class="line"> /usr/bin/chattr +a /var/log/htmlaccess.log</span><br><span class="line"> endscript</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/var/log/netconf.log &#123; </span><br><span class="line"> nocompress</span><br><span class="line"> monthly</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>logrotate日志切割不执行问题</title>
    <url>/2021/06/30/logrotate%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E4%B8%8D%E6%89%A7%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>业务服务中写的日志切割功能没有执行，具体排查流程如下：</p>
<p><strong>1、先看下配置文件是否正确，可以先手动执行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logrotate /etc/logrotate.conf</span><br></pre></td></tr></table></figure>
<p><strong>2. 看下logrotate执行的结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@p45282v ~]# cat /var/lib/logrotate/logrotate.status</span><br><span class="line">logrotate state -- version 2</span><br><span class="line">&quot;/var/log/supervisor/kafka_consumer_stderr.log&quot; 2021-6-28-3:34:26</span><br><span class="line">&quot;/var/log/supervisor/gunicorn_web-stderr---supervisor.log&quot; 2021-6-27-3:7:26</span><br><span class="line">&quot;/var/log/supervisor/match_log_stderr.log&quot; 2021-6-28-3:34:26</span><br><span class="line">&quot;/var/log/supervisor/root_service_stderr.log&quot; 2021-6-27-3:7:26</span><br></pre></td></tr></table></figure>
<p><strong>3、logrotate是crontab执行的，涉及到以下俩个文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat /etc/cron.daily/logrotate</span><br><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">/usr/sbin/logrotate /etc/logrotate.conf</span><br><span class="line">EXITVALUE=$?</span><br><span class="line">if [ $EXITVALUE != 0 ]; then</span><br><span class="line">    /usr/bin/logger -t logrotate &quot;ALERT exited abnormally with [$EXITVALUE]&quot;</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p>有的服务还会在crontab设置定时执行，我的没有这个文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /etc/cron.d/nginx </span><br><span class="line">55 23 * * * root sleep `perl -e &quot;print int(rand(120))&quot;` &amp;&amp; /usr/sbin/logrotate -v -f /usr/local/nginx/conf/logrotate.conf</span><br></pre></td></tr></table></figure>
<p><strong>4. 手工执行</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf</span><br></pre></td></tr></table></figure></p>
<p><strong>小结</strong></p>
<p>可以手工添加定时任务解决问题。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下的vnc</title>
    <url>/2021/01/23/mac%E4%B8%8B%E7%9A%84vnc/</url>
    <content><![CDATA[<p>由于有需要远程VNC的需要，苦苦寻找一款Mac上比较好使的VNC Client，结果经人指点，发现原来MacOS自带了VNC Client，只是没有在Launchpad中显示罢了。使用command+space 调出Spotlight搜索键入screen Sharing.app即可。</p>
]]></content>
      <tags>
        <tag>工程工具</tag>
      </tags>
  </entry>
  <entry>
    <title>mongo常用的限制</title>
    <url>/2021/06/07/mongo%E5%B8%B8%E7%94%A8%E7%9A%84%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>今天在将stix文件导入mongo数据库时，报出了文档大于16M的情况。小记下mongo常用的限制。</p>
<p><strong>命名限制</strong></p>
<ol>
<li>数据库名称是大小写区别的：同时mongo也不允许两个数据库名称仅仅为大小写区别。</li>
<li>在windows下的数据库名称限制：/. “*&lt;&gt;:|? 并且不能包括空格符。</li>
<li>在Unix Linux下的数据库名称限制：/. “ 同样不能包括空格符。</li>
<li>数据库名称长度：64字节</li>
<li>集合名称限制：必须以下划线或者字母开头，并且不能包括 $,引号，空格符，点号</li>
<li>字段名称限制：不能包括点号，$，与空格符。</li>
</ol>
<p><strong>名字空间</strong></p>
<ol>
<li>名字空间长度限制：包括数据库与集合名称，总共不能超过123字节</li>
<li>名字空间数量：mongo为每个数据库保存一个16MB的名字空间文件，dbname.ns ,每个名称占用628字节，因此默认可以支持24000个名字空间（索引也占用一个名字空间）。</li>
<li>名字空间文件大小：最大不超过2048MB，默认为16MB，可以使用nssize选项进行配置。</li>
</ol>
<p><strong>Capped Collections</strong></p>
<ol>
<li>帽子集合的最大文档数：当在创建时候执行最大文档数参数时，该值必须小于2的32次方。若在创建的时候没有指定则文档数不限制。</li>
</ol>
<p><strong>BSON 文档</strong></p>
<ol>
<li>BSON文档大小，最大限制为16MB，这种限制是为了确保单个文档不会使用过多的RAM，或者在迁移期间不会占用过多的带宽。为了保存大于该限制的文档，mongodb提供了GridFS 当插入的文档大于16MB时将得到如下的错误信息（java客户端）：com.mongodb.MongoInternalException: DBObject of size 30836631 is over Max BSON size 16777216</li>
<li>文档的最大嵌套数为 100</li>
</ol>
<p><strong>索引</strong></p>
<ol>
<li>索引关键字：该字段的取值不能超过1024字节，否则不能添加到一个索引中。</li>
<li>集合的最大所有个数：64</li>
<li>索引名称长度：包括数据库于集合名称总共不超过125字符。</li>
<li>联合索引最大字段个数：31</li>
<li>不能联合使用text索引与其他类型索引</li>
</ol>
<p><strong>复制集</strong>  </p>
<ol>
<li>最大的复制集个数：12</li>
<li>复制集的投票成员个数：任何时刻最大只有7个成员拥有投票权</li>
</ol>
<p><strong>参考文档</strong></p>
<ol>
<li><a href="https://docs.mongodb.com/manual/reference/limits/#limit-bson-document-size" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/limits/#limit-bson-document-size</a></li>
</ol>
]]></content>
      <tags>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>pipenv使用</title>
    <url>/2020/08/06/pipenv%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Pipenv"><a href="#Pipenv" class="headerlink" title="Pipenv"></a>Pipenv</h2><p>参考链接：<a href="https://juejin.im/post/6844903812755357703" target="_blank" rel="noopener">https://juejin.im/post/6844903812755357703</a></p>
<h3 id="Pipenv介绍"><a href="#Pipenv介绍" class="headerlink" title="Pipenv介绍"></a>Pipenv介绍</h3><p>Pipenv会自动帮你管理虚拟环境和依赖文件，并且提供了一系列命令和选项来帮助你实现各种依赖和环境管理相关的操作。简而言之，它更方便、完善和安全。你可以通过Pipenv文档开头的介绍来了解它的详细特性。Pipenv的slogan是“Python Dev Workflow for Humans”。</p>
<h3 id="Pipenv使用"><a href="#Pipenv使用" class="headerlink" title="Pipenv使用"></a>Pipenv使用</h3><ol>
<li>安装Pipenv</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pipenv</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建虚拟环境</li>
</ol>
<p>2.1 通过<code>--python</code>指定python版本，如果想指定默认 Python 版本可以通过环境变量<code>PIPENV_DEFAULT_PYTHON_VERSION</code>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv install --python 3.7</span><br></pre></td></tr></table></figure>
<p>2.2 通过python解释器程序路径指定python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv --python /path/to/python</span><br></pre></td></tr></table></figure>
<p>2.3 指定虚拟运行环境在项目目录下创建</p>
<p>方法一：</p>
<p>执行<code>pipenv</code>前先创建<code>.venv</code>目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir .venv &amp;&amp; pipenv install requests --python 3.6</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<p>配置<code>PIPENV_VENV_IN_PROJECT</code>环境变量，如果想自定义这个目录需要通过环境变量<code>WORKON_HOME</code>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PIPENV_VENV_IN_PROJECT=1</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>激活虚拟环境</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv shell</span><br></pre></td></tr></table></figure>
<p>或直接运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv run python3 main.py</span><br></pre></td></tr></table></figure>
<p>此外，Pipenv还提供了一个pipenv run命令，在该命令后附加的参数会直接作为命令在虚拟环境中执行，这允许你不必显式的激活虚拟环境即可在虚拟环境中执行命令。比如，pipenv run python会启动虚拟环境中的Python解释器。</p>
<p>在项目根目录下有 .env 环境配置文件时，激活虚拟环境同时会加载 .env 文件中的环境变量配置，如果不想使用这个功能可以通过配置 <code>PIPENV_DONT_LOAD_ENV</code> 变量来关闭它。</p>
<ol start="4">
<li>安装依赖到虚拟环境</li>
</ol>
<font color="red">项目开发中安装依赖包时，请指定依赖包版本</font>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv install ***</span><br><span class="line"></span><br><span class="line">pipenv install &quot;requests&gt;=1.4&quot; # 版本号大于或等于 1.4.0</span><br><span class="line"></span><br><span class="line">pipenv install &quot;requests&lt;=2.13&quot; # 版本号小于或等于 2.13.0</span><br><span class="line"></span><br><span class="line">pipenv install &quot;requests&gt;2.19&quot; # 版本号大于 2.19.0</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>记录依赖</li>
</ol>
<p>Pipenv会自动帮你管理依赖。Pipenv会在你创建虚拟环境时自动创建Pipfile和Pipfile.lock文件（如果不存在），并且会在你使用pipenv install和pipenv uninstall命令安装和卸载包时自动更新Pipfile和Pipfile.lock。</p>
<ol start="6">
<li>在部署环境安装依赖</li>
</ol>
<p>使用Pipenv只需要执行pipenv install,它会自动安装Pipfile中记录的依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv install</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>区分开发依赖</li>
</ol>
<p>使用Pipenv时，你只需要在安装pytest时添加一个–dev选项，它会自动被分类为开发依赖（写入Pipfile的dev-packages一节中）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv install pytest --dev</span><br></pre></td></tr></table></figure>
<p>在新的开发环境安装依赖时，也只需要在pipenv install命令后添加–dev选项即可一并安装开发依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv install --dev</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>更新包</li>
</ol>
<p>查看有更新的包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv update --outdated</span><br></pre></td></tr></table></figure>
<p>更新所有依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv update</span><br></pre></td></tr></table></figure>
<p>更新所指定依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv update requests</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>卸载包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv uninstall requests</span><br></pre></td></tr></table></figure>
<p>查看依赖关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv graph</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>在部署中使用pipenv</li>
</ol>
<p>为了保证部署时安装的依赖版本与发布一致，不能使用 <code>pipenv install</code> 进行安装，需要加上 <code>--deploy</code> 参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv install -deploy</span><br></pre></td></tr></table></figure>
<p>如果不使用虚拟环境，还需要加上<code>--system</code>参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pipenv install --deploy --system</span><br></pre></td></tr></table></figure>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol>
<li>更换pip源</li>
</ol>
<p>只需要更改Pipfile中更换对应的url即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[source]]</span><br><span class="line"></span><br><span class="line">url = &quot;https://mirrors.aliyun.com/pypi/simple&quot;</span><br><span class="line"></span><br><span class="line">verify_ssl = true</span><br><span class="line"></span><br><span class="line">name = &quot;pypi&quot;</span><br></pre></td></tr></table></figure>
<p>除了修改Pipfile，你也可以在执行安装命令时通过–pypi-mirror选项指定PyPI源，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv install --pypi-mirror https://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure>
<p>设置环境变量PIPENV_PYPI_MIRROR效果相同。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql中死锁问题排查</title>
    <url>/2021/04/20/postgresql%E4%B8%AD%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<p>最近在做一个业务数据导入导出的功能需求，在导入过程中出现了系统卡死的现象。怀疑为数据库死锁导致，具体排查流程如下。</p>
<h4 id="排查流程"><a href="#排查流程" class="headerlink" title="排查流程"></a>排查流程</h4><ol>
<li>查询ACTIVITY的状态等信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT T</span><br><span class="line">	.PID,</span><br><span class="line">	T.STATE,</span><br><span class="line">	T.QUERY,</span><br><span class="line">	T.WAIT_EVENT_TYPE,</span><br><span class="line">	T.WAIT_EVENT,</span><br><span class="line">	T.QUERY_START    </span><br><span class="line">FROM</span><br><span class="line">	PG_STAT_ACTIVITY T</span><br><span class="line">WHERE</span><br><span class="line">	T.DATNAME = &apos;数据库用户名&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/20/postgresql中死锁问题排查/pg1.png" alt="avatar"></p>
<p>上面查询结果中：pid就是ACTIVITY的唯一标识，state就是活动状态，query就是正在执行的sql语句，query——start就是开始执行的时间。</p>
<ol start="2">
<li>查询死锁的ACTIVITY</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT T</span><br><span class="line">	.PID,</span><br><span class="line">	T.STATE,</span><br><span class="line">	T.QUERY,</span><br><span class="line">	T.WAIT_EVENT_TYPE,</span><br><span class="line">	T.WAIT_EVENT,</span><br><span class="line">	T.QUERY_START    </span><br><span class="line">FROM</span><br><span class="line">	PG_STAT_ACTIVITY T </span><br><span class="line">WHERE</span><br><span class="line">	T.DATNAME = &apos;数据库用户名&apos; </span><br><span class="line">	AND T.WAIT_EVENT_TYPE = &apos;Lock&apos;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>将第二条查询语句的pid字段的数字值记录下来，执行下面的查询语句可以解锁：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select PG_CANCEL_BACKEND(&apos;6984&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的查询语句，执行了pg_cancel_backend()函数，该函数是取消后台操作，回滚未提交事物的用途。</p>
<ol start="4">
<li><p>解决idle in transaction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select pg_terminate_backend (&apos;21967&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>小结 </p>
</li>
</ol>
<p>根据以上流程，排查出truncate语句与select语句执行过程中出现了Lock清空。追踪到业务场景中，在执行导入的过程中存在权限校验，校验需要查询当前用户的登录状态。登录过程包含sql如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id,user_name from user where id=1;</span><br><span class="line"></span><br><span class="line">truncate table user reset identity cascade;</span><br></pre></td></tr></table></figure></p>
<p>其中select语句的状态一直是“idle in transaction”的状态。</p>
<p>业务逻辑中存在监控请求，每隔10s请求一次，也存在权限校验的场景：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id,user_name from user where id=1;</span><br></pre></td></tr></table></figure></p>
<p>所以后续的sql也是处于Lock的状态。</p>
<p>继续排查“idle in transaction”的问题</p>
<h4 id="PostgreSql中一直有连接长时间处于idle-in-transaction的问题"><a href="#PostgreSql中一直有连接长时间处于idle-in-transaction的问题" class="headerlink" title="PostgreSql中一直有连接长时间处于idle in transaction的问题"></a>PostgreSql中一直有连接长时间处于idle in transaction的问题</h4><p><strong>数据库连接的几种状态</strong></p>
<p>pg_stat_activity 是一张postgresql的系统视图，它的每一行都表示一个系统进程，显示与当前会话的活动进程的一些信息，比如当前会话的状态和查询等。它的state字段表示当前进程的状态，一共有六种：</p>
<ul>
<li>Active(活动): 进程正在执行某个语句</li>
<li>Idle(空闲): 进程正在等待客户端的指令</li>
<li>idle in transaction(事务空闲):进程在处理事务的过程中，但当前没有执行任何语句</li>
<li>idle in transaction (aborted)(事务空闲-退出):除了事务中声明一个错误外，其余情况与idle in transaction相同</li>
<li>fastpath function call(快速通道函数调用): 后台正在执行某个快速通道函数</li>
<li>Disabled(禁用): 报告状态被禁用</li>
</ul>
<p>Postgresql在9.6版本提供了idle_in_transaction_session_timeout 参数，用于释放一直处于idle in transaction状态下的连接。<br>尝试在postgresql.conf 文件中添加idle_in_transaction_session_timeout参数控制，参数单位为毫秒<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idle_in_transaction_session_timeout=30000</span><br></pre></td></tr></table></figure></p>
<h4 id="问题最终解决方案"><a href="#问题最终解决方案" class="headerlink" title="问题最终解决方案"></a>问题最终解决方案</h4><ol>
<li>导入用户数据功能时，业务加锁处理；</li>
<li>数据库修改相关配置，添加<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idle_in_transaction_session_timeout=30000</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol>
<li><a href="https://blog.csdn.net/DB_su/article/details/78204101" target="_blank" rel="noopener">https://blog.csdn.net/DB_su/article/details/78204101</a></li>
<li><a href="https://blog.csdn.net/qq_25775675/article/details/104360897" target="_blank" rel="noopener">https://blog.csdn.net/qq_25775675/article/details/104360897</a></li>
<li><a href="https://blog.csdn.net/cutcue/article/details/89351026" target="_blank" rel="noopener">https://blog.csdn.net/cutcue/article/details/89351026</a></li>
<li><a href="https://copyfuture.com/blogs-details/20200117234850895p89v43xrnosg9bg" target="_blank" rel="noopener">https://copyfuture.com/blogs-details/20200117234850895p89v43xrnosg9bg</a></li>
<li><a href="https://www.pianshen.com/article/49201804388/" target="_blank" rel="noopener">https://www.pianshen.com/article/49201804388/</a></li>
</ol>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql中的replace函数</title>
    <url>/2021/04/13/postgresql%E4%B8%AD%E7%9A%84replace%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>select replace(字段名,E’\r’,’’) from 表名 where 字段名 like E’%\r%’;；  查看修改后结果，并不真实修改数据库</p>
<p>update 表名 set 字段名=replace(字段名,E’\r’,’’) where 字段名 like E’%\r%’;;  更改字段中包含某个字符为另一个字符，这里是把’\r’替换为空。</p>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql中的重复行问题</title>
    <url>/2021/04/15/postgresql%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>本文主要描述使用各种技术来删除PostgreSQL中的重复行。</p>
<h3 id="准备示例数据"><a href="#准备示例数据" class="headerlink" title="准备示例数据"></a>准备示例数据</h3><p>首先创建一个表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE basket(</span><br><span class="line">    id SERIAL PRIMARY KEY,</span><br><span class="line">    fruit VARCHAR(50) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>接下来插入一些数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO basket(fruit) values(&apos;apple&apos;);</span><br><span class="line">INSERT INTO basket(fruit) values(&apos;apple&apos;);</span><br><span class="line"></span><br><span class="line">INSERT INTO basket(fruit) values(&apos;orange&apos;);</span><br><span class="line">INSERT INTO basket(fruit) values(&apos;orange&apos;);</span><br><span class="line">INSERT INTO basket(fruit) values(&apos;orange&apos;);</span><br><span class="line"></span><br><span class="line">INSERT INTO basket(fruit) values(&apos;banana&apos;);</span><br></pre></td></tr></table></figure>
<h3 id="查找重复行"><a href="#查找重复行" class="headerlink" title="查找重复行"></a>查找重复行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    fruit,</span><br><span class="line">    COUNT( fruit )</span><br><span class="line">FROM</span><br><span class="line">    basket</span><br><span class="line">GROUP BY</span><br><span class="line">    fruit</span><br><span class="line">HAVING</span><br><span class="line">    COUNT( fruit )&gt; 1</span><br><span class="line">ORDER BY</span><br><span class="line">    fruit;</span><br></pre></td></tr></table></figure>
<h3 id="使用-DELETE-USING-语句删除重复的行"><a href="#使用-DELETE-USING-语句删除重复的行" class="headerlink" title="使用 DELETE USING 语句删除重复的行"></a>使用 DELETE USING 语句删除重复的行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE</span><br><span class="line">FROM</span><br><span class="line">    basket a</span><br><span class="line">        USING basket b</span><br><span class="line">WHERE</span><br><span class="line">    a.id &lt; b.id</span><br><span class="line">    AND a.fruit = b.fruit;</span><br></pre></td></tr></table></figure>
<h3 id="使用子查询删除重复的行"><a href="#使用子查询删除重复的行" class="headerlink" title="使用子查询删除重复的行"></a>使用子查询删除重复的行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM basket</span><br><span class="line">WHERE id IN</span><br><span class="line">    (SELECT id</span><br><span class="line">    FROM </span><br><span class="line">        (SELECT id,</span><br><span class="line">         ROW_NUMBER() OVER( PARTITION BY fruit</span><br><span class="line">        ORDER BY  id ) AS row_num</span><br><span class="line">        FROM basket ) t</span><br><span class="line">        WHERE t.row_num &gt; 1 );</span><br></pre></td></tr></table></figure>
<h3 id="ON和USING和NATURAL"><a href="#ON和USING和NATURAL" class="headerlink" title="ON和USING和NATURAL"></a>ON和USING和NATURAL</h3><p>ON子句是最常见的连接条件的类型：它接收一个和WHERE 子句相同的布尔表达式。如果两个分别来自T1和T2 的行在ON表达式上运算的结果为真，那么它们就算是匹配的行。</p>
<p>USING是一个连接条件的缩写语法：它接收一个用逗号分隔的字段名列表，这些字段必须是连接表共有的并且其值必须相同。最后，JOIN USING 会将每一对相等的输入字段输出为一个字段，其后跟着所有其它字段。因此，USING (a, b, c) 等效于ON (t1.a = t2.a AND t1.b = t2.b AND t1.c = t2.c) 只不过是如果使用了ON，那么在结果里a, b和c 字段都会有两个，而用USING的时候就只会有一个（如果使用了SELECT * 的话，他们会优先发生）。</p>
<p>最后，NATURAL是USING的缩写形式：它自动形成一个由两个表中同名的字段组成的USING列表(同名字段只出现一次)。如果没有同名的字段，NATURAL的行为会像CROSS JOIN。</p>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>postgres中的序列及自增量</title>
    <url>/2021/04/17/postgres%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%8A%E8%87%AA%E5%A2%9E%E9%87%8F/</url>
    <content><![CDATA[<p>业务中需要调整id字段类型，最开始设置的为SERIAL，后续需要调整至SERIAL8。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table tab_name alter column data_id type SERIAL8;</span><br><span class="line">-- 失败！类型SERIAL8不存在！</span><br></pre></td></tr></table></figure>
<p>但实际上 create table 语句中的字段类型 SERIAL8，并不存在。 SERIAL8 （或者SERIAL）会创建对应的sequence， 然后将sequence 跟表的主键关联。具体对应过程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table table_name (dataId bigint not null primary key);</span><br><span class="line">create sequence seq_name;</span><br><span class="line">alter table table_name alter column set default nextval(&apos;seq_name&apos; ::regclass);</span><br></pre></td></tr></table></figure>
<p>理解了这个过程，就容易明白了，直接修改字段类型 SERIAL8 是不可以的，需要按照上述过程操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 先把字段类型调整为 int8, 这一步操作耗时较长，在8核心+SSD固态盘的主机上，2亿条数据耗时超过一刻钟</span><br><span class="line">alter table bw_data alter column dataId type int8;</span><br><span class="line"> </span><br><span class="line">-- 创建sequence, 默认bigint</span><br><span class="line">-- 起始值从当前表中选取</span><br><span class="line">select max(dataId) into max_dataId_from_data from bw_data;</span><br><span class="line">create sequence bw_data_dataid_seq8 start with max_dataId_from_data;</span><br><span class="line"> </span><br><span class="line">-- 先将表的自增量主键字段 默认值置为null</span><br><span class="line">alter table bw_data alter column dataId set default null;</span><br><span class="line"> </span><br><span class="line">-- 设置默认值为新的 sequence</span><br><span class="line">alter table bw_data alter column dataId set default nextval(&apos;bw_data_dataid_seq8&apos; ::regclass);</span><br><span class="line"> </span><br><span class="line">-- 原来的sequence 可以删除</span><br><span class="line">drop sequence bw_data_dataid_seq;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    Sequence &quot;public.bw_data_dataid_seq8&quot;</span><br><span class="line">  Type  |   Start   | Minimum |       Maximum       | Increment | Cycles? | Cache</span><br><span class="line">--------+-----------+---------+---------------------+-----------+---------+-------</span><br><span class="line"> bigint | 265432104 |       1 | 9223372036854775807 |         1 | no      |     1</span><br></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://blog.csdn.net/kampoo/article/details/113628598" target="_blank" rel="noopener">https://blog.csdn.net/kampoo/article/details/113628598</a></li>
</ol>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm操作flask的坑</title>
    <url>/2021/03/27/pycharm%E6%93%8D%E4%BD%9Cflask%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h3 id="标题pycharm操作Flask的app-run-的坑"><a href="#标题pycharm操作Flask的app-run-的坑" class="headerlink" title="标题pycharm操作Flask的app.run()的坑"></a>标题pycharm操作Flask的app.run()的坑</h3><p>我们如果自定义配置了app.run()中debug、host、port直接点击pycharm的运行flask，默认是不会起任何作用的。</p>
<p><img src="/2021/03/27/pycharm操作flask的坑/pycharm1.png" alt="avatar"></p>
<p>解决办法是有两种：<br><strong>1.直接在pycharm的终端中运行，修改的配置则生效。</strong>但每次需要手动输入命令。</p>
<p><img src="/2021/03/27/pycharm操作flask的坑/pycharm2.png" alt="avatar"></p>
<p>2.修改pycharm中flask的配置，然后点击pycharm运行就可以了。<br>首先找到配置</p>
<p><img src="/2021/03/27/pycharm操作flask的坑/pycharm3.png" alt="avatar"></p>
<h3 id="pycharm-中-python3-的环境编码是-ASCII-转化为utf-8"><a href="#pycharm-中-python3-的环境编码是-ASCII-转化为utf-8" class="headerlink" title="pycharm 中 python3 的环境编码是 ASCII 转化为utf-8"></a>pycharm 中 python3 的环境编码是 ASCII 转化为utf-8</h3><p>Click will abort further execution because Python 3 was configured to use ASCII as encoding for the environment<br>If you are trying to execute tests case you must set the following environment variables each time:</p>
<p>export LC_ALL=en_US.utf-8<br>export LANG=en_US.utf-8<br>Doing this each time will resolve the error.<br>It may also be possible to set this in your IDE if you are using one. For example see the following setting in PyCharm 2016.</p>
<p><img src="/2021/03/27/pycharm操作flask的坑/pycharm4.png" alt="avatar"></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python3中re模块</title>
    <url>/2020/08/26/python3%E4%B8%ADre%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p><strong>常用的正则表达式符号</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  &apos;.&apos;      # 默认匹配换行符(\n)之外的任意一个字符；flags=re.DOTALL(将换行符也匹配出来)</span><br><span class="line">2  &apos;^&apos;      # 匹配字符串开头；flags=re.MULTILINE(如果开头为换行符或者其他特殊，可以从换行符后面开始匹配)</span><br><span class="line">3  &apos;$&apos;      #匹配字符串结尾；flags=re.MULTILINE(如果字符串有换行符的话换行符前的字符也可以在行尾匹配)</span><br><span class="line">4  &apos;*&apos;      #匹配*号前面的字符0次或者多次[0, +oo]</span><br><span class="line">5  &apos;+&apos;      #匹配前一个字符1次或者多次[1, +oo]</span><br><span class="line">6  &apos;?&apos;      #匹配前一个字符1次或者0次</span><br><span class="line">7  &apos;&#123;m&#125;&apos;    #匹配前一个字符m次</span><br><span class="line">8  &apos;&#123;n, m&#125;&apos; #匹配前一个字符n到m次</span><br><span class="line">9  &apos;|&apos;      #匹配|左边或者|右边的字符</span><br><span class="line">10 &apos;(...)&apos;  #匹配括号中的任意正则表达式</span><br></pre></td></tr></table></figure>
<p><strong>包含’\’的正则表达式特殊序列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\d  #匹配任何十进制数：它相当于类[0-9]</span><br><span class="line">\D  #匹配任何非数字字符：它相当于[^0-9]</span><br><span class="line">\s  #匹配任何空白字符：它相当于类[ \t\n\r\f\v]</span><br><span class="line">\S  #匹配任何非空白字符：它相当于类[^ \t\n\r\f\v]</span><br><span class="line">\w  #匹配任何字母数字字符：它相当于类[a-zA-Z0-9]</span><br><span class="line">\W  #匹配任何非数字字母字符：它相当于[^a-zA-Z0-9]</span><br><span class="line">\b  #匹配一个单词边界，也就是指单词和空格间的位置</span><br></pre></td></tr></table></figure>
<p><strong>常用的语法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re #放在文件头以下省略</span><br><span class="line">re.findall     #把所有匹配的字符以元素的形式放入列表，返回一个列表                      </span><br><span class="line">    print(re.findall(&apos;^a&apos;, &apos;\nabc&apos;))    #[]</span><br><span class="line">    print(re.findall(&apos;^a&apos;, &apos;\nabc&apos;, flags=re.MULTILINE))   #[&apos;a&apos;]</span><br><span class="line">    print(re.findall(&apos;.&apos;, &apos;\nabc&apos;))    #[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">    print(re.findall(&apos;.&apos;, &apos;\nabc&apos;, flags=re.DOTALL))   #[&apos;\n&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line"></span><br><span class="line">re.search      #查找字符串中于正则表达式匹配的第一个位置，返回相应的MatchObject实例,后缀 .group() 方法可以取得相应的str型值                           </span><br><span class="line">    print(re.search(&apos;a&apos;, &apos;\nabdgc ddaad&apos;))  #&lt;re.Match object; span=(1, 2), match=&apos;a&apos;&gt;</span><br><span class="line">    print(re.search(&apos;a&apos;, &apos;\nabdgc ddaad&apos;).group())  #a   #直接以字符出返回</span><br><span class="line"></span><br><span class="line">re.sub         #将匹配到的字符替换</span><br><span class="line">    print(re.sub(&apos;正则表达式&apos;, &apos;用来替代的字符串&apos;, &apos;字符串&apos;))  #返回替换后的字符串                          </span><br><span class="line">    print(re.sub(&apos;.&apos;, &apos;a&apos;, &apos;\nabdgc ddaad&apos;))  #aaaaaaaaaaa</span><br><span class="line"></span><br><span class="line">re.split       #将匹配到的字符当做列表分隔符，将分隔开的元素放在列表中返回                                   </span><br><span class="line">    print(re.split(&apos;abc&apos;, &apos;sldkleabcdklsabcd&apos;))  #[&apos;sldkle&apos;, &apos;dkls&apos;, &apos;d&apos;]</span><br><span class="line"></span><br><span class="line">re.match       #只在字符串开头位置开始匹配，返回MatchObject实例,使用.group()获取值                                 </span><br><span class="line">    print(re.match(&apos;abc&apos;, &apos;sldkleabcdklsabcd&apos;))  #None  #匹配不到返回None</span><br><span class="line">    print(re.match(&apos;abc&apos;, &apos;abcabcsldkledklsabcd&apos;))  #&lt;re.Match object; span=(0, 3), match=&apos;abc&apos;&gt;</span><br><span class="line">    print(re.match(&apos;abc&apos;, &apos;abcabcsldkledklsabcd&apos;).group())  #abc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>#*,+,?都是贪婪匹配，也就是尽可能的匹配 后面加？使其变成惰性匹配</p>
</blockquote>
<p><strong>转义字符反斜杠</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#   \   :反斜杠后边跟元字符去除特殊功能</span><br><span class="line">#        反斜杠后面跟普通字符实现特殊功能（某些普通字符d、w、等）</span><br><span class="line">#        在编程中想要匹配字符串中的&apos;\&apos;需要四个反斜杠&apos;\\\\&apos;因为编程语言将四个反斜杠变为两个，而正则表达式使用两个反斜杠来匹配这一个反斜杠</span><br><span class="line">import re                              </span><br><span class="line">print(re.findall(&apos;\\\\&apos;, &apos;sdas\dadas&apos;))  #[&apos;\\&apos;] #这里输出编程语言两个反斜杠相当于字符串中一个斜杠</span><br><span class="line">上面等价于</span><br><span class="line">print(re.findall(r&apos;\\&apos;, &apos;sdas\dadas&apos;))  #[&apos;\\&apos;]  #原生字符串</span><br></pre></td></tr></table></figure>
<p><strong>参考文献</strong></p>
<p><a href="https://www.jianshu.com/p/d2a03a5945ea" target="_blank" rel="noopener">https://www.jianshu.com/p/d2a03a5945ea</a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python3中的deque</title>
    <url>/2020/08/24/python3%E4%B8%AD%E7%9A%84deque/</url>
    <content><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><strong>创建双向队列</strong></p>
<p>使用 deque(maxlen=N) 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。</p>
<p>更一般的， deque 类可以被用在任何你只需要一个简单队列数据结构的场合。 如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作。</p>
<p>在队列两端插入或删除元素时间复杂度都是 O(1) ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 O(N) 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br></pre></td></tr></table></figure>
<p><strong>append(往右边添加一个元素)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.append(1)</span><br><span class="line">d.append(2)</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">#输出：deque([1, 2])</span><br></pre></td></tr></table></figure>
<p><strong>appendleft（往左边添加一个元素）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.append(1)</span><br><span class="line">d.appendleft(2)</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">#输出：deque([2, 1])</span><br></pre></td></tr></table></figure>
<p><strong>clear(清空队列)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.append(1)</span><br><span class="line">d.clear()</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">#输出：deque([])</span><br></pre></td></tr></table></figure>
<p><strong>copy(浅拷贝)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.append(1)</span><br><span class="line">new_d = d.copy()</span><br><span class="line">print(new_d)</span><br><span class="line"></span><br><span class="line">#输出：deque([1])</span><br></pre></td></tr></table></figure>
<p><strong>count(返回指定元素的出现次数)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.append(1)</span><br><span class="line">d.append(1)</span><br><span class="line">print(d.count(1))</span><br><span class="line"></span><br><span class="line">#输出：2</span><br></pre></td></tr></table></figure>
<p><strong>extend(从队列右边扩展一个列表的元素)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.append(1)</span><br><span class="line">d.extend([3,4,5])</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">#输出：deque([1, 3, 4, 5])</span><br></pre></td></tr></table></figure>
<p><strong>extendleft(从队列左边扩展一个列表的元素)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.append(1)</span><br><span class="line">d.extendleft([3,4,5])</span><br><span class="line">print(d)</span><br><span class="line">#</span><br><span class="line"># #输出：deque([5, 4, 3, 1])</span><br></pre></td></tr></table></figure>
<p><strong>index（查找某个元素的索引位置）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.extend([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])</span><br><span class="line">print(d)</span><br><span class="line">print(d.index(&apos;e&apos;))</span><br><span class="line">print(d.index(&apos;c&apos;,0,3))  #指定查找区间</span><br><span class="line"></span><br><span class="line">#输出：deque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;])</span><br><span class="line">#     4</span><br><span class="line">#     2</span><br></pre></td></tr></table></figure>
<p><strong>insert（在指定位置插入元素）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.extend([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])</span><br><span class="line">d.insert(2,&apos;z&apos;)</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">#输出：deque([&apos;a&apos;, &apos;b&apos;, &apos;z&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;])</span><br></pre></td></tr></table></figure>
<p><strong>pop（获取最右边一个元素，并在队列中删除）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.extend([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])</span><br><span class="line">x = d.pop()</span><br><span class="line">print(x,d)</span><br><span class="line"></span><br><span class="line">#输出：e deque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])</span><br></pre></td></tr></table></figure>
<p><strong>popleft（获取最左边一个元素，并在队列中删除）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.extend([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])</span><br><span class="line">x = d.popleft()</span><br><span class="line">print(x,d)</span><br><span class="line"></span><br><span class="line">#输出：a deque([&apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;])</span><br></pre></td></tr></table></figure>
<p><strong>remove（删除指定元素）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.extend([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])</span><br><span class="line">d.remove(&apos;c&apos;)</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">#输出：deque([&apos;a&apos;, &apos;b&apos;, &apos;d&apos;, &apos;e&apos;])</span><br></pre></td></tr></table></figure>
<p><strong>reverse（队列反转）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.extend([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])</span><br><span class="line">d.reverse()</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">#输出：deque([&apos;e&apos;, &apos;d&apos;, &apos;c&apos;, &apos;b&apos;, &apos;a&apos;])</span><br></pre></td></tr></table></figure>
<p><strong>rotate（把右边元素放到左边）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">d = collections.deque()</span><br><span class="line">d.extend([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])</span><br><span class="line">d.rotate(2)   #指定次数，默认1次</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">#输出：deque([&apos;d&apos;, &apos;e&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/saolv/p/9839711.html" target="_blank" rel="noopener">https://www.cnblogs.com/saolv/p/9839711.html</a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中@property属性详解</title>
    <url>/2021/03/19/python%E4%B8%AD-property%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Python内置有三大装饰器：@staticmethod(静态方法)、@classmethod(类方法)、@property(描述符)，其中静态方法就是定义在类里的函数，并没有非要定义的必要；类方法则是在调用类属性、传递类对象时使用；而@property则是一个非常好用的语法糖。@property最大的好处就是在类中把一个方法变成属性调用，起到既能检查属性，还能用属性的方式来访问该属性的作用。</p>
<h3 id="property应用"><a href="#property应用" class="headerlink" title="@property应用"></a>@property应用</h3><p>让我们先看下@property的应用，其功能1是可定义只读属性，也就是真正意义上的私有属性(属性前双下划线的私有属性也是可以访问的，具体参照这篇文章：私有属性真的是私有的吗？)。实例需求是定义类Person，具有年龄和姓名，要求年龄必须等于18，则代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, name, age=18):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = 18</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return self.__age</span><br><span class="line">        </span><br><span class="line">xm = Person(&apos;xiaoming&apos;)  #定义一个人名小明</span><br><span class="line">print(xm.age)	#结果为18</span><br><span class="line">xm.age = -4	#报错无法给年龄赋值</span><br><span class="line">print(xm.age)</span><br></pre></td></tr></table></figure>
<p>在python中定义只读属性非@property莫属，如果细心留意大部分源码，都跑不了@property的身影。而定义只读属性也很简单：以需要定义的属性为方法名(上例age属性定义为方法)，其上装饰内置装饰器@property就ok了。</p>
<p>@property真正强大的是可以限制属性的定义。往往我们定义类，希望其中的属性必须符合实际，但因为在<strong>init</strong>里定义的属性可以随意的修改，导致很难实现。如我想实现Person类，规定每个人(即创建的实例)的年龄必须大于18岁，正常实现的话，则必须将属性age设为只读属性，然后通过方法来赋值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = 18</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return self.__age</span><br><span class="line"></span><br><span class="line">    def set_age(self, age): #定义函数来给self.__age赋值</span><br><span class="line">        if age &lt; 18:</span><br><span class="line">            print(&apos;年龄必须大于18岁&apos;)</span><br><span class="line">            return</span><br><span class="line">        self.__age = age</span><br><span class="line">        return self.__age</span><br><span class="line">     </span><br><span class="line">     xm = Person(&apos;xiaoming&apos;, 20)</span><br><span class="line">     </span><br><span class="line">print(xm.age)</span><br><span class="line">print(&apos;----------&apos;)</span><br><span class="line">xm.set_age(10)</span><br><span class="line">print(xm.age)</span><br><span class="line">print(&apos;----------&apos;)</span><br><span class="line">xm.set_age(20)</span><br><span class="line">print(xm.age)</span><br></pre></td></tr></table></figure>
<p>可以看到，通过方法的确能限制输入，但是不是每个人都记得方法名，有什么简化的方法呢？@property就能很轻松办到，修改代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = 18</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return self.__age</span><br><span class="line"></span><br><span class="line">    @age.setter</span><br><span class="line">    def age(self, age):</span><br><span class="line">        if age &lt; 18:</span><br><span class="line">            print(&apos;年龄必须大于18岁&apos;)</span><br><span class="line">            return</span><br><span class="line">        self.__age = age</span><br><span class="line">        return self.__age</span><br><span class="line"></span><br><span class="line">xm = Person(&apos;xiaoming&apos;, 20)</span><br><span class="line">print(xm.age)</span><br><span class="line">print(&apos;----------&apos;)</span><br><span class="line">xm.age = 10</span><br><span class="line">print(xm.age)</span><br><span class="line">print(&apos;----------&apos;)</span><br><span class="line">xm.age = 20</span><br><span class="line">print(xm.age)</span><br></pre></td></tr></table></figure></p>
<p>结果和上图一致。两段代码变化的内容：将set_age修改为age，并且在上方加入装饰器@age.setter。这就是@property定义可访问属性的语法，即仍旧以属性名为方法名，并在方法名上增加@属性.setter就行了。</p>
<h3 id="property实现原理"><a href="#property实现原理" class="headerlink" title="@property实现原理"></a>@property实现原理</h3><p>在开头说过，@property是个描述符(decorator)，实际上他本身是类，不信的话，可以将上述代码修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = 18</span><br><span class="line"></span><br><span class="line">    def get_age(self): #恢复用方法名来获取以及定义</span><br><span class="line">        return self.__age</span><br><span class="line"></span><br><span class="line">    def set_age(self, age): </span><br><span class="line">        if age &lt; 18:</span><br><span class="line">            print(&apos;年龄必须大于18岁&apos;)</span><br><span class="line">            return</span><br><span class="line">        self.__age = age</span><br><span class="line">        return self.__age</span><br><span class="line"></span><br><span class="line">    age = property(get_age, set_age)  #增加property类</span><br></pre></td></tr></table></figure>
<p> 上述代码的运行结果和前面一致，将@property装饰的属性方法再次修改回定义方法名，然后再类的最下方，定义：属性=property(get,set,del).</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  关于@property的介绍到此为止，@property装饰器就是一个语法糖(语法糖指那些没有给计算机语言添加新功能，而只是对人类来说更“甜蜜”的语法。 语法糖往往给程序员提供了更实用的编码方式，有益于更好的编码风格，更易读。)。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中dict用法</title>
    <url>/2021/02/04/python%E4%B8%ADdict%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h3 id="dict基本使用"><a href="#dict基本使用" class="headerlink" title="dict基本使用"></a>dict基本使用</h3><p>以一个例子开始：统计一个列表里各单词重复次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">words = [&apos;hello&apos;, &apos;world&apos;, &apos;nice&apos;, &apos;world&apos;]</span><br><span class="line">counter = dict()</span><br><span class="line">for kw in words:</span><br><span class="line">    counter[kw] += 1</span><br></pre></td></tr></table></figure>
<p>这样写肯定会报错的，因为各词的个数都没有初始值，引发KeyError</p>
<p>第二种方式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word=[&quot;hello&quot;,&quot;world&quot;,&quot;my&quot;,&quot;friend&quot;,&quot;my&quot;]</span><br><span class="line">result=dict()</span><br><span class="line">for key in word:</span><br><span class="line">    if key in result.keys():</span><br><span class="line">       value = result.get(key)+1</span><br><span class="line">    else:</span><br><span class="line">       value=1</span><br><span class="line">    result[key]=value</span><br><span class="line"></span><br><span class="line">for key,value in result.items():</span><br><span class="line">    print(&quot;key is &#123;&#125;,value is &#123;&#125;&quot;.format(key,value))</span><br></pre></td></tr></table></figure></p>
<p>使用setdefault()方法设置默认值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word=[&quot;hello&quot;,&quot;world&quot;,&quot;my&quot;,&quot;friend&quot;,&quot;my&quot;]</span><br><span class="line">result=dict()</span><br><span class="line">for key in word:</span><br><span class="line">    result.setdefault(key,0)</span><br><span class="line">    result[key] +=1</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>setdefault()，需提供两个参数，第一个参数是键值，第二个参数是默认值，每次调用都有一个返回值，如果字典中不存在该键则返回默认值，如果存在该键则返回该值，利用返回值可再次修改代码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word=[&quot;hello&quot;,&quot;world&quot;,&quot;my&quot;,&quot;friend&quot;,&quot;my&quot;]</span><br><span class="line">result=dict()</span><br><span class="line">for key in word:</span><br><span class="line">    </span><br><span class="line">    result[key] = result.setdefault(key,0) +1</span><br></pre></td></tr></table></figure>
<h3 id="如何使用defaultdict"><a href="#如何使用defaultdict" class="headerlink" title="如何使用defaultdict"></a>如何使用defaultdict</h3><p>defaultdict接受一个工厂函数作为参数，如下来构造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict =defaultdict( factory_function)</span><br></pre></td></tr></table></figure>
<p>这个factory_function可以是list、set、str等等，作用是当key不存在时，返回的是工厂函数的默认值，比如list对应[ ]，str对应的是空字符串，set对应set( )，int对应0，如下举例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line">dict1 = defaultdict(int)</span><br><span class="line">dict2 = defaultdict(set)</span><br><span class="line">dict3 = defaultdict(str)</span><br><span class="line">dict4 = defaultdict(list)</span><br><span class="line">dict1[2] =&apos;two&apos;</span><br><span class="line"></span><br><span class="line">print(dict1[1])</span><br><span class="line">print(dict2[1])</span><br><span class="line">print(dict3[1])</span><br><span class="line">print(dict4[1])</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">set()</span><br><span class="line"></span><br><span class="line">[]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import defaultdict</span><br><span class="line">&gt;&gt;&gt; def zero():</span><br><span class="line">...     return 0</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; dd = defaultdict(zero)</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">defaultdict(&lt;function zero at 0xb7ed2684&gt;, &#123;&#125;)</span><br><span class="line">&gt;&gt;&gt; dd[&apos;foo&apos;]</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; dd</span><br><span class="line">defaultdict(&lt;function zero at 0xb7ed2684&gt;, &#123;&apos;foo&apos;: 0&#125;)</span><br></pre></td></tr></table></figure>
<p>最终代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line">words = [&apos;hello&apos;, &apos;world&apos;, &apos;nice&apos;, &apos;world&apos;]</span><br><span class="line">#使用lambda来定义简单的函数</span><br><span class="line">counter = defaultdict(lambda: 0) </span><br><span class="line">for kw in words:</span><br><span class="line">    counter[kw] += 1</span><br></pre></td></tr></table></figure></p>
<h3 id="dict其他函数"><a href="#dict其他函数" class="headerlink" title="dict其他函数"></a>dict其他函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">seq = (&apos;Google&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;)</span><br><span class="line"> </span><br><span class="line">dict = dict.fromkeys(seq)</span><br><span class="line">print &quot;新字典为 : %s&quot; %  str(dict)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">l2=[1,2,3]</span><br><span class="line">d1=dict(zip(l1,l2))</span><br><span class="line">print(d1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict = &#123;&apos;Name&apos;: &apos;Zara&apos;, &apos;Age&apos;: 7&#125;</span><br><span class="line">dict2 = &#123;&apos;Sex&apos;: &apos;female&apos; &#125;</span><br><span class="line"></span><br><span class="line">dict.update(dict2)</span><br><span class="line">print &quot;Value : %s&quot; %  dict</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中eval函数</title>
    <url>/2021/04/28/python%E4%B8%ADeval%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="用法简介"><a href="#用法简介" class="headerlink" title="用法简介"></a>用法简介</h4><p>函数原型：</p>
<p>eval(expression, globals=None, locals=None)</p>
<p>参数：</p>
<p>expression：这个参数是一个字符串，python会使用globals字典和locals字典作为全局和局部的命名空间，将expression当做一个python表达式（从技术上讲，是一个条件列表）进行解析和计算。</p>
<p>globals:这个参数管控的是一个全局的命名空间，也就是我们在计算表达式的时候可以使用全局的命名空间中的函数，如果这个参数被提供了，并且没有提供自定义的<strong>builtins</strong>，那么会将当前环境中的<strong>builtins</strong>拷贝到自己提供的globals里，然后才会进行计算。关于<strong>builtins</strong>，它是python的内建模块，也就是python自带的模块，不需要我们import就可以使用的，例如我们平时使用的int、str、abs等都在这个模块中。关于它的说明可以参照这篇文章：点击打开链接。如果globals没有被提供，则使用python的全局命名空间。</p>
<p>locals：这个参数管控的是一个局部的命名空间，和globals类似，不过当它和globals中有重复的部分时，locals里的定义会覆盖掉globals中的，也就是当globals和locals中有冲突的部分时，locals说了算，它有决定权，以它的为准。如果locals没有被 提供的话，则默认为globals。</p>
<p>eval函数也可以被用来执行任意的代码对象（如那些由compile()创建的对象）。在这种情况下，expression参数是一个代码对象而不是一个字符串。如果代码对象已经被‘exec‘编译为模式参数，eavl（）的返回值是None。</p>
<p>三个参数的使用：</p>
<p><strong>1、在前两个参数省略的情况下，eval在当前的作用域执行：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a=10;</span><br><span class="line">print(eval(&quot;a+1&quot;))</span><br></pre></td></tr></table></figure>
<p>执行结果为：11</p>
<p><strong>2、在globals指定的情况下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a=10;</span><br><span class="line">g=&#123;&apos;a&apos;:4&#125;</span><br><span class="line">print(eval(&quot;a+1&quot;,g))</span><br></pre></td></tr></table></figure>
<p>执行结果为：5</p>
<p>这里面可能有点绕啊，初学者得理理清楚。在这次的代码中，我们在 eval中提供了globals参数，这时候eval的作用域就是g指定的这个字典了，也就是外面的a=10被屏蔽掉了，eval是看不见的，所以使用了a为4的值。</p>
<p><strong>3、在 locals指定的情况下 ：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">c=30</span><br><span class="line">g=&#123;&apos;a&apos;:6,&apos;b&apos;:8&#125;</span><br><span class="line">t=&#123;&apos;b&apos;:100,&apos;c&apos;:10&#125;</span><br><span class="line">print(eval(&apos;a+b+c&apos;,g,t))</span><br></pre></td></tr></table></figure>
<p>执行的结果为：116</p>
<p>这里面就更有点绕人了，此次执行的结果中，a是6，b是100，c是10。我们首先来看一下，对于a为6我们是没有疑问的，因为在上个例子中已经说了，g会屏蔽程序中的全局变量的，而这里最主要的是为什么b是100呢？还记得我们在参数介绍的时候说过，当locals和globals起冲突时，locals是起决定作用的，这在很多编程语言里都是一样的，是作用域的覆盖问题，当前指定的小的作用域会覆盖以前大的作用域，这可以理解为一张小的纸盖在了一张大的纸上，纸是透明的，上面写的东西是不透明的，而它们重合的地方就可以理解成两个作用域冲突的地方，自然是小的显现出来了。</p>
<p><strong>使用的场合</strong></p>
<p>对于eval的使用，我们一定要确保第一个参数expression满足表达式的要求，它是可以被解析然后计算的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s=&quot;abck&quot;</span><br><span class="line">print(eval(s))</span><br></pre></td></tr></table></figure>
<p>执行的结果为：NameError: name ‘abck’ is not defined</p>
<p>对于当面的代码，我们可以看到，字符串s并不满足表达式的要求。当eval剥去了”abck”的外面的引号的时候，它会对它进行解析，然后满足要求后进行计算，然后它解析到的是abcd，请注意，程序报出的错误是NameError，也就是说，当它解析到这个表达式是不可以计算后，它就会查找它是不是一个变量的名字，如果是一个变量的名字，那么它会输出这个变量的内容，否则就会产生这种报错。</p>
<h4 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = &quot;[[1,2], [3,4], [5,6], [7,8], [9,0]]&quot;</span><br><span class="line">b = eval(a)</span><br><span class="line">b</span><br><span class="line">Out[3]: [[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]]</span><br><span class="line">type(b)</span><br><span class="line">Out[4]: list</span><br><span class="line">a = &quot;&#123;1: &apos;a&apos;, 2: &apos;b&apos;&#125;&quot;</span><br><span class="line">b = eval(a)</span><br><span class="line">b</span><br><span class="line">Out[7]: &#123;1: &apos;a&apos;, 2: &apos;b&apos;&#125;</span><br><span class="line">type(b)</span><br><span class="line">Out[8]: dict</span><br><span class="line">a = &quot;([1,2], [3,4], [5,6], [7,8], (9,0))&quot;</span><br><span class="line">b = eval(a)</span><br><span class="line">b</span><br><span class="line">Out[11]: ([1, 2], [3, 4], [5, 6], [7, 8], (9, 0))</span><br></pre></td></tr></table></figure>
<h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>eval虽然方便，但是要注意安全性，可以将字符串转成表达式并执行，就可以利用执行系统命令，删除文件等操作。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval(&quot;__import__(&apos;os&apos;).system(&apos;ls /Users/chunming.liu/Downloads/&apos;)&quot;)</span><br><span class="line"></span><br><span class="line">os.system(&apos;ls /Users/chunming.liu/Downloads/&apos;)</span><br></pre></td></tr></table></figure></p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol>
<li><a href="https://blog.csdn.net/qq_29883591/article/details/53443062" target="_blank" rel="noopener">https://blog.csdn.net/qq_29883591/article/details/53443062</a></li>
<li><a href="https://blog.csdn.net/liuchunming033/article/details/87643041" target="_blank" rel="noopener">https://blog.csdn.net/liuchunming033/article/details/87643041</a></li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中基本用法</title>
    <url>/2020/09/12/python%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="传递元组"><a href="#传递元组" class="headerlink" title="传递元组"></a>传递元组</h2><p>你可曾希望从一个函数中返回两个不同的值？你能做到的。只需要使用一个元组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def get_error_details():</span><br><span class="line">...     return (2, &apos;details&apos;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; errnum, errstr = get_error_details()</span><br><span class="line">&gt;&gt;&gt; errnum</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; errstr</span><br><span class="line">&apos;details&apos;</span><br></pre></td></tr></table></figure>
<p>要注意到 a, b = <some expression> 的用法会将表达式的结果解释为具有两个值的一个元组。</some></p>
<p>这也意味着在 Python 中交换两个变量的最快方法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 5; b = 8</span><br><span class="line">&gt;&gt;&gt; a, b</span><br><span class="line">(5, 8)</span><br><span class="line">&gt;&gt;&gt; a, b = b, a</span><br><span class="line">&gt;&gt;&gt; a, b</span><br><span class="line">(8, 5)</span><br></pre></td></tr></table></figure>
<h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>诸如 <strong>init</strong> 和 <strong>del</strong> 等一些方法对于类来说有特殊意义。</p>
<p>特殊方法用来模拟内置类型的某些行为。举个例子，如果你希望为你的类使用 x[key] 索引操作（就像你在列表与元组中使用的那样），那么你所需要做的只不过是实现 <strong>getitem</strong>() 方法，然后你的工作就完成了。如果你试图理解它，就想想 Python 就是对 list 类这样做的！</p>
<p>下面的表格列出了一些有用的特殊方法。如果你想了解所有的特殊方法，请参阅手册。</p>
<p><strong>init</strong>(self, …)</p>
<p>这一方法在新创建的对象被返回准备使用时被调用。<br><strong>del</strong>(self)</p>
<p>这一方法在对象被删除之前调用（它的使用时机不可预测，所以避免使用它）<br><strong>str</strong>(self)</p>
<p>当我们使用 print 函数时，或 str() 被使用时就会被调用。<br><strong>lt</strong>(self, other)</p>
<p>当小于运算符（&lt;）被使用时被调用。类似地，使用其它所有运算符（+、&gt; 等等）时都会有特殊方法被调用。<br><strong>getitem</strong>(self, key)</p>
<p>使用 x[key] 索引操作时会被调用。<br><strong>len</strong>(self)</p>
<p>当针对序列对象使用内置 len() 函数时会被调用</p>
<h2 id="单语句块"><a href="#单语句块" class="headerlink" title="单语句块"></a>单语句块</h2><p>我们已经见识过每一个语句块都由其自身的缩进级别与其它部分相区分。 是这样没错，不过有一个小小的警告。如果你的语句块只包括单独的一句语句，那么你可以在同一行指定它，例如条件语句与循环语句。下面这个例子应该能比较清楚地解释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; flag = True</span><br><span class="line">&gt;&gt;&gt; if flag: print(&apos;Yes&apos;)</span><br><span class="line">...</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>
<p>注意，单个语句是在原地立即使用的，它不会被看作一个单独的块。尽管，你可以通过这种方式来使你的程序更加小巧，但除非是为了检查错误，我强烈建议你避免使用这种快捷方法，这主要是因为如果你不小心使用了一个“恰到好处”的缩进，它就很容易添加进额外的语句。</p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>lambda 语句可以创建一个新的函数对象。从本质上说，lambda 需要一个参数，后跟一个表达式作为函数体，这一表达式执行的值将作为这个新函数的返回值。</p>
<p>案例（保存为 more_lambda.py）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">points = [&#123;&apos;x&apos;: 2, &apos;y&apos;: 3&#125;,</span><br><span class="line">          &#123;&apos;x&apos;: 4, &apos;y&apos;: 1&#125;]</span><br><span class="line">points.sort(key=lambda i: i[&apos;y&apos;])</span><br><span class="line">print(points)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python more_lambda.py</span><br><span class="line">[&#123;&apos;y&apos;: 1, &apos;x&apos;: 4&#125;, &#123;&apos;y&apos;: 3, &apos;x&apos;: 2&#125;]</span><br></pre></td></tr></table></figure>
<p>它是如何工作的</p>
<p>要注意到一个 list 的 sort 方法可以获得一个 key 参数，用以决定列表的排序方式（通常我们只知道升序与降序）。在我们的案例中，我们希望进行一次自定义排序，为此我们需要编写一个函数，但是又不是为函数编写一个独立的 def 块，只在这一个地方使用，因此我们使用 Lambda 表达式来创建一个新函数。</p>
<h2 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h2><p>列表推导（List Comprehension）用于从一份现有的列表中得到一份新列表。想象一下，现在你已经有了一份数字列表，你想得到一个相应的列表，其中的数字在大于 2 的情况下将乘以 2。列表推导就是这类情况的理想选择。</p>
<p>案例（保存为 more_list_comprehension.py）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listone = [2, 3, 4]</span><br><span class="line">listtwo = [2*i for i in listone if i &gt; 2]</span><br><span class="line">print(listtwo)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python more_list_comprehension.py</span><br><span class="line">[6, 8]</span><br></pre></td></tr></table></figure>
<p>它是如何工作的</p>
<p>在本案例中，当满足了某些条件时（if i &gt; 2），我们进行指定的操作（2*i），以此来获得一份新的列表。要注意到原始列表依旧保持不变。</p>
<p>使用列表推导的优点在于，当我们使用循环来处理列表中的每个元素并将其存储到新的列表中时时，它能减少样板（Boilerplate）代码的数量。</p>
<h2 id="在函数中接收元组与字典"><a href="#在函数中接收元组与字典" class="headerlink" title="在函数中接收元组与字典"></a>在函数中接收元组与字典</h2><p>有一种特殊方法，即分别使用 * 或 ** 作为元组或字典的前缀，来使它们作为一个参数为函数所接收。当函数需要一个可变数量的实参时，这将颇为有用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def powersum(power, *args):</span><br><span class="line">...     &apos;&apos;&apos;Return the sum of each argument raised to the specified power.&apos;&apos;&apos;</span><br><span class="line">...     total = 0</span><br><span class="line">...     for i in args:</span><br><span class="line">...         total += pow(i, power)</span><br><span class="line">...     return total</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; powersum(2, 3, 4)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; powersum(2, 10)</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<p>因为我们在 args 变量前添加了一个 * 前缀，函数的所有其它的额外参数都将传递到 args 中，并作为一个元组予以储存。如果采用的是 ** 前缀，则额外的参数将被视为字典的键值—值配对。</p>
<h2 id="assert-语句"><a href="#assert-语句" class="headerlink" title="assert 语句"></a>assert 语句</h2><p>assert 语句用以断言（Assert）某事是真的。例如说你非常确定你正在使用的列表中至少包含一个元素，并想确认这一点，如果其不是真的，就抛出一个错误，assert 语句就是这种情况下的理想选择。当语句断言失败时，将会抛出 AssertionError。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; mylist = [&apos;item&apos;]</span><br><span class="line">&gt;&gt;&gt; assert len(mylist) &gt;= 1</span><br><span class="line">&gt;&gt;&gt; mylist.pop()</span><br><span class="line">&apos;item&apos;</span><br><span class="line">&gt;&gt;&gt; assert len(mylist) &gt;= 1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure>
<p>你应该明智地选用 assert 语句。在大多数情况下，它好过捕获异常，也好过定位问题或向用户显示错误信息然后退出。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器（Decorators）是应用包装函数的快捷方式。这有助于将某一功能与一些代码一遍又一遍地“包装”。举个例子，我为自己创建了一个 retry 装饰器，这样我可以将其运用到任何函数之中，如果在一次运行中抛出了任何错误，它就会尝试重新运行，直到最大次数 5 次，并且每次运行期间都会有一定的延迟。这对于你在对一台远程计算机进行网络调用的情况十分有用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from time import sleep</span><br><span class="line">from functools import wraps</span><br><span class="line">import logging</span><br><span class="line">logging.basicConfig()</span><br><span class="line">log = logging.getLogger(&quot;retry&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def retry(f):</span><br><span class="line">    @wraps(f)</span><br><span class="line">    def wrapped_f(*args, **kwargs):</span><br><span class="line">        MAX_ATTEMPTS = 5</span><br><span class="line">        for attempt in range(1, MAX_ATTEMPTS + 1):</span><br><span class="line">            try:</span><br><span class="line">                return f(*args, **kwargs)</span><br><span class="line">            except:</span><br><span class="line">                log.exception(&quot;Attempt %s/%s failed : %s&quot;,</span><br><span class="line">                              attempt,</span><br><span class="line">                              MAX_ATTEMPTS,</span><br><span class="line">                              (args, kwargs))</span><br><span class="line">                sleep(10 * attempt)</span><br><span class="line">        log.critical(&quot;All %s attempts failed : %s&quot;,</span><br><span class="line">                     MAX_ATTEMPTS,</span><br><span class="line">                     (args, kwargs))</span><br><span class="line">    return wrapped_f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">counter = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@retry</span><br><span class="line">def save_to_database(arg):</span><br><span class="line">    print(&quot;Write to a database or make a network call or etc.&quot;)</span><br><span class="line">    print(&quot;This will be automatically retried if exception is thrown.&quot;)</span><br><span class="line">    global counter</span><br><span class="line">    counter += 1</span><br><span class="line">    # 这将在第一次调用时抛出异常</span><br><span class="line">    # 在第二次运行时将正常工作（也就是重试）</span><br><span class="line">    if counter &lt; 2:</span><br><span class="line">        raise ValueError(arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    save_to_database(&quot;Some bad value&quot;)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python more_decorator.py</span><br><span class="line">Write to a database or make a network call or etc.</span><br><span class="line">This will be automatically retried if exception is thrown.</span><br><span class="line">ERROR:retry:Attempt 1/5 failed : ((&apos;Some bad value&apos;,), &#123;&#125;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;more_decorator.py&quot;, line 14, in wrapped_f</span><br><span class="line">    return f(*args, **kwargs)</span><br><span class="line">  File &quot;more_decorator.py&quot;, line 39, in save_to_database</span><br><span class="line">    raise ValueError(arg)</span><br><span class="line">ValueError: Some bad value</span><br><span class="line">Write to a database or make a network call or etc.</span><br><span class="line">This will be automatically retried if exception is thrown.</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中正则表达式</title>
    <url>/2021/03/25/python%E4%B8%AD%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><p><strong>re模块的使用过程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line"># 导入re模块</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"># 使用match方法进行匹配操作</span><br><span class="line">result = re.match(正则表达式,要匹配的字符串)</span><br><span class="line"></span><br><span class="line"># 如果上一步匹配到数据的话，可以使用group方法来提取数据</span><br><span class="line">result.group()</span><br></pre></td></tr></table></figure>
<p>re.match是用来进行正则匹配检查的方法，若字符串匹配正则表达式，则match方法返回匹配对象（Match Object），否则返回None（注意不是空字符串””）。</p>
<p>匹配对象Macth Object具有group方法，用来返回字符串的匹配部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">result = re.match(&quot;itcast&quot;,&quot;itcast.cn&quot;)</span><br><span class="line"></span><br><span class="line">result.group()</span><br><span class="line"></span><br><span class="line">运行结果为：</span><br><span class="line">itcast</span><br></pre></td></tr></table></figure>
<h4 id="表示字符"><a href="#表示字符" class="headerlink" title="表示字符"></a>表示字符</h4><p>本小节，将要讲解正则表达式的单字符匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.	 : 匹配任意1个字符（除了\n）</span><br><span class="line">[ ]	 : 匹配[ ]中列举的字符</span><br><span class="line">\d	 : 匹配数字，即0-9</span><br><span class="line">\D	 : 匹配非数字，即不是数字</span><br><span class="line">\s	 : 匹配空白，即 空格，tab键</span><br><span class="line">\S	 : 匹配非空白</span><br><span class="line">\w	 : 匹配单词字符，即a-z、A-Z、0-9、_</span><br><span class="line">\W	 : 匹配非单词字符</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">ret = re.match(&quot;.&quot;,&quot;a&quot;)</span><br><span class="line">ret.group()</span><br><span class="line"></span><br><span class="line">ret = re.match(&quot;[hH]&quot;,&quot;hello Python&quot;)</span><br><span class="line">ret.group()</span><br><span class="line"></span><br><span class="line">ret = re.match(&quot;[0-9]&quot;,&quot;7Hello Python&quot;)</span><br><span class="line">ret.group()</span><br><span class="line"></span><br><span class="line">ret = re.match(&quot;嫦娥\d号&quot;,&quot;嫦娥3号发射成功&quot;)</span><br><span class="line">ret.group()</span><br></pre></td></tr></table></figure>
<h4 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h4><p>Python中字符串前面加上 r 表示原生字符串，</p>
<p>与大多数编程语言相同，正则表达式里使用”\”作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\”，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\”：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。</p>
<p>Python里的原生字符串很好地解决了这个问题，有了原始字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; ret = re.match(r&quot;c:\\a&quot;,mm).group()</span><br><span class="line">&gt;&gt;&gt; print(ret)</span><br><span class="line">c:\a</span><br></pre></td></tr></table></figure>
<h4 id="表示数量"><a href="#表示数量" class="headerlink" title="表示数量"></a>表示数量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* : 匹配前一个字符出现0次或者无限次，即可有可无</span><br><span class="line">+ : 匹配前一个字符出现1次或者无限次，即至少有1次</span><br><span class="line">? : 匹配前一个字符出现1次或者0次，即要么有1次，要么没有</span><br><span class="line">&#123;m&#125;	 : 匹配前一个字符出现m次</span><br><span class="line">&#123;m,&#125; : 匹配前一个字符至少出现m次</span><br><span class="line">&#123;m,n&#125; : 匹配前一个字符出现从m到n次</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">一个字符串第一个字母为大小字符，后面都是小写字母并且这些小写字母可有可无</span><br><span class="line">ret = re.match(&quot;[A-Z][a-z]*&quot;,&quot;Mm&quot;)</span><br><span class="line">ret.group()</span><br><span class="line"></span><br><span class="line">匹配出，变量名是否有效</span><br><span class="line">ret = re.match(&quot;[a-zA-Z_]+[\w_]*&quot;,&quot;_name&quot;)</span><br><span class="line">ret.group()</span><br><span class="line"></span><br><span class="line">匹配出，0到99之间的数字</span><br><span class="line">ret = re.match(&quot;[1-9]?[0-9]&quot;,&quot;7&quot;)</span><br><span class="line">ret.group()</span><br><span class="line"></span><br><span class="line">匹配出，8到20位的密码，可以是大小写英文字母、数字、下划线</span><br><span class="line">ret = re.match(&quot;[a-zA-Z0-9_]&#123;6&#125;&quot;,&quot;12a3g45678&quot;)</span><br><span class="line">ret.group()</span><br></pre></td></tr></table></figure>
<h4 id="表示边界"><a href="#表示边界" class="headerlink" title="表示边界"></a>表示边界</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^  : 匹配字符串开头</span><br><span class="line">$  : 匹配字符串结尾</span><br><span class="line">\b : 匹配一个单词的边界</span><br><span class="line">\B : 匹配非单词边界</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 通过$来确定末尾</span><br><span class="line">ret = re.match(&quot;[\w]&#123;4,20&#125;@163\.com$&quot;, &quot;xiaoWang@163.comheihei&quot;)</span><br><span class="line">ret.group()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; re.match(r&quot;.*\bver\b&quot;, &quot;ho ver abc&quot;).group()</span><br><span class="line">&apos;ho ver&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; re.match(r&quot;.*\Bver\B&quot;, &quot;hoverabc&quot;).group()</span><br><span class="line">&apos;hover&apos;</span><br></pre></td></tr></table></figure>
<h4 id="匹配分组"><a href="#匹配分组" class="headerlink" title="匹配分组"></a>匹配分组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\      : 匹配左右任意一个表达式</span><br><span class="line">(ab)   : 将括号中字符作为一个分组</span><br><span class="line">\num   : 引用分组num匹配到的字符串</span><br><span class="line">(?P&lt;name&gt;)	 : 分组起别名</span><br><span class="line">(?P=name)	: 引用别名为name分组匹配到的字符串</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加|</span><br><span class="line">ret = re.match(&quot;[1-9]?\d$|100&quot;,&quot;8&quot;)</span><br><span class="line">ret.group()</span><br><span class="line"></span><br><span class="line">ret = re.match(&quot;\w&#123;4,20&#125;@(163|126|qq)\.com&quot;, &quot;test@gmail.com&quot;)</span><br><span class="line">ret.group()</span><br><span class="line"></span><br><span class="line">匹配出&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">ret = re.match(r&quot;&lt;(\w*)&gt;&lt;(\w*)&gt;.*&lt;/\2&gt;&lt;/\1&gt;&quot;, &quot;&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h2&gt;&lt;/html&gt;&quot;)</span><br><span class="line">ret.group()</span><br></pre></td></tr></table></figure>
<h4 id="re模块的高级用法"><a href="#re模块的高级用法" class="headerlink" title="re模块的高级用法"></a>re模块的高级用法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret = re.search(r&quot;\d+&quot;, &quot;阅读次数为 9999&quot;)</span><br><span class="line">ret.group()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = re.findall(r&quot;\d+&quot;, &quot;python = 9999, c = 7890, c++ = 12345&quot;)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">ret = re.sub(r&quot;\d+&quot;, &apos;998&apos;, &quot;python = 997&quot;)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">ret = re.split(r&quot;:| &quot;,&quot;info:xiaoZhang 33 shandong&quot;)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>
<h3 id="python贪婪和非贪婪"><a href="#python贪婪和非贪婪" class="headerlink" title="python贪婪和非贪婪"></a>python贪婪和非贪婪</h3><p>Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；</p>
<p>非贪婪则相反，总是尝试匹配尽可能少的字符。</p>
<p>在”*”,”?”,”+”,”{m,n}”后面加上？，使贪婪变成非贪婪。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s=&quot;This is a number 234-235-22-423&quot;</span><br><span class="line">&gt;&gt;&gt; r=re.match(&quot;.+(\d+-\d+-\d+-\d+)&quot;,s)</span><br><span class="line">&gt;&gt;&gt; r.group(1)</span><br><span class="line">&apos;4-235-22-423&apos;</span><br><span class="line">&gt;&gt;&gt; r=re.match(&quot;.+?(\d+-\d+-\d+-\d+)&quot;,s)</span><br><span class="line">&gt;&gt;&gt; r.group(1)</span><br><span class="line">&apos;234-235-22-423&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>正则表达式模式中使用到通配字，那它在从左到右的顺序求值时，会尽量“抓取”满足匹配最长字符串，在我们上面的例子里面，“.+”会从字符串的启始处抓取满足模式的最长字符，其中包括我们想得到的第一个整型字段的中的大部分，“\d+”只需一位字符就可以匹配，所以它匹配了数字“4”，而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&quot;aa(\d+)&quot;,&quot;aa2343ddd&quot;).group(1)</span><br><span class="line">&apos;2343&apos;</span><br><span class="line">&gt;&gt;&gt; re.match(r&quot;aa(\d+?)&quot;,&quot;aa2343ddd&quot;).group(1)</span><br><span class="line">&apos;2&apos;</span><br><span class="line">&gt;&gt;&gt; re.match(r&quot;aa(\d+)ddd&quot;,&quot;aa2343ddd&quot;).group(1) </span><br><span class="line">&apos;2343&apos;</span><br><span class="line">&gt;&gt;&gt; re.match(r&quot;aa(\d+?)ddd&quot;,&quot;aa2343ddd&quot;).group(1)</span><br><span class="line">&apos;2343&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的itertools模块</title>
    <url>/2021/02/03/python%E4%B8%AD%E7%9A%84itertools%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>itertools标准化了一个快速、高效利用内存的核心工具集，这些工具本身或组合都很有用。它们一起形成了“迭代器代数”，这使得在纯Python中有可能创建简洁又高效的专用工具。</p>
<h3 id="“无限”迭代器"><a href="#“无限”迭代器" class="headerlink" title="“无限”迭代器"></a>“无限”迭代器</h3><p>count()会创建一个无限的迭代器，所以上述代码会打印出自然数序列，根本停不下来，只能按Ctrl+C退出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; natuals = itertools.count(1)</span><br><span class="line">&gt;&gt;&gt; for n in natuals:</span><br><span class="line">...     print(n)</span><br></pre></td></tr></table></figure></p>
<p>cycle()会把传入的一个序列无限重复下去<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; cs = itertools.cycle(&apos;ABC&apos;) # 注意字符串也是序列的一种</span><br><span class="line">&gt;&gt;&gt; for c in cs:</span><br><span class="line">...     print(c)</span><br></pre></td></tr></table></figure></p>
<p>repeat()负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; ns = itertools.repeat(&apos;A&apos;, 3)</span><br><span class="line">&gt;&gt;&gt; for n in ns:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="根据最短输入序列长度停止的迭代器"><a href="#根据最短输入序列长度停止的迭代器" class="headerlink" title="根据最短输入序列长度停止的迭代器"></a>根据最短输入序列长度停止的迭代器</h3><p>accumulate()创建一个迭代器，返回累积汇总值或其他双目运算函数的累积结果值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; ns = itertools.accumulate((1,2,3,4))</span><br><span class="line">&gt;&gt;&gt; for n in ns:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>chain()可以把一组迭代对象串联起来，形成一个更大的迭代器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for c in itertools.chain(&apos;ABC&apos;, &apos;XYZ&apos;):</span><br><span class="line">...     print(c)</span><br><span class="line"># 迭代效果：&apos;A&apos; &apos;B&apos; &apos;C&apos; &apos;X&apos; &apos;Y&apos; &apos;Z&apos;</span><br></pre></td></tr></table></figure></p>
<p>groupby()把迭代器中相邻的重复元素挑出来放在一起：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for key, group in itertools.groupby(&apos;AAABBBCCAAA&apos;):</span><br><span class="line">...     print(key, list(group))</span><br><span class="line">...</span><br><span class="line">A [&apos;A&apos;, &apos;A&apos;, &apos;A&apos;]</span><br><span class="line">B [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;]</span><br><span class="line">C [&apos;C&apos;, &apos;C&apos;]</span><br><span class="line">A [&apos;A&apos;, &apos;A&apos;, &apos;A&apos;]</span><br></pre></td></tr></table></figure></p>
<p>chain.from_iterable 构建类似 chain() 迭代器的另一个选择。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; abc=itertools.chain.from_iterable([&quot;abc&quot;,&quot;cde&quot;])</span><br><span class="line">&gt;&gt;&gt; for a in abc:</span><br><span class="line">...     print(a)</span><br><span class="line">...</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.chain.from_iterable" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/itertools.html#itertools.chain.from_iterable</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017783145987360" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017783145987360</a></li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的yield关键字</title>
    <url>/2020/08/03/python%E4%B8%AD%E7%9A%84yield%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>Python 是非常灵活的语言，其中 yield 关键字是普遍容易困惑的概念。</p>
<p>此篇将介绍 yield 关键字，及其相关的概念。</p>
<h2 id="迭代、可迭代、迭代器"><a href="#迭代、可迭代、迭代器" class="headerlink" title="迭代、可迭代、迭代器"></a>迭代、可迭代、迭代器</h2><p><strong>迭代（iteration）与可迭代（iterable）</strong></p>
<blockquote>
<p>迭代是一种操作；可迭代是对象的一种特性。</p>
</blockquote>
<p>很多数据都是「容器」；它们包含了很多其他类型的元素。实际使用容器时，我们常常需要逐个获取其中的元素。逐个获取元素的过程，就是「迭代」。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># iteration</span><br><span class="line">a_list = [1, 2, 3]</span><br><span class="line">for i in a_list:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>如果我们可以从一个对象中，逐个地获取元素，那么我们就说这个对象是「可迭代的」。</p>
<p>Python 中的顺序类型，都是可迭代的（list, tuple, string）。其余包括 dict, set, file 也是可迭代的。对于用户自己实现的类型，如果提供了 <strong>iter</strong>() 或者 <strong>getitem</strong>() 方法，那么该类的对象也是可迭代的。</p>
<p><strong>迭代器（iterator）</strong></p>
<blockquote>
<p>迭代器是一种对象。</p>
</blockquote>
<p>迭代器抽象的是一个「数据流」，是只允许迭代一次的对象。对迭代器不断调用 next() 方法，则可以依次获取下一个元素；当迭代器中没有元素时，调用 next() 方法会抛出 StopIteration 异常。迭代器的 <strong>iter</strong>() 方法返回迭代器自身；因此迭代器也是可迭代的。</p>
<p><strong>迭代器协议（iterator protocol）</strong></p>
<blockquote>
<p>迭代器协议指的是容器类需要包含一个特殊方法。</p>
</blockquote>
<p>如果一个容器类提供了 <strong>iter</strong>() 方法，并且该方法能返回一个能够逐个访问容器内所有元素的迭代器，则我们说该容器类实现了迭代器协议。</p>
<p>Python 中的迭代器协议和 Python 中的 for 循环是紧密相连的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># iterator protocol and for loop</span><br><span class="line">for x in something:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>Python 处理 for 循环时，首先会调用内建函数 iter(something)，它实际上会调用 something.<strong>iter</strong>()，返回 something 对应的迭代器。而后，for 循环会调用内建函数 next()，作用在迭代器上，获取迭代器的下一个元素，并赋值给 x。此后，Python 才开始执行循环体。</p>
<h2 id="生成器、yield-表达式"><a href="#生成器、yield-表达式" class="headerlink" title="生成器、yield 表达式"></a>生成器、yield 表达式</h2><p><strong>生成器函数（generator function）和生成器（generator）</strong></p>
<blockquote>
<p>生成器函数是一种特殊的函数；生成器则是特殊的迭代器。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    return 1</span><br><span class="line"></span><br><span class="line">def gen():</span><br><span class="line">    yield 1</span><br><span class="line"></span><br><span class="line">print(type(func))   # &lt;class &apos;function&apos;&gt;</span><br><span class="line">print(type(gen))    # &lt;class &apos;function&apos;&gt;</span><br><span class="line"></span><br><span class="line">print(type(func())) # &lt;class &apos;int&apos;&gt;</span><br><span class="line">print(type(gen()))  # &lt;class &apos;generator&apos;&gt;</span><br></pre></td></tr></table></figure>
<p>如上，生成器 gen 看起来和普通的函数没有太大区别。仅只是将 return 换成了 yield。用 type() 函数打印二者的类型也能发现，func 和 gen 都是函数。然而，二者的返回值的类型就不同了。func() 是一个 int 类型的对象；而 gen() 则是一个生成器对象。</p>
<p><strong>yield 表达式</strong></p>
<p>如前所述，如果一个函数定义中包含 yield 表达式，那么该函数是一个生成器函数（而非普通函数）。实际上，yield 仅能用于定义生成器函数。</p>
<p>与普通函数不同，生成器函数被调用后，其函数体内的代码并不会立即执行，而是返回一个生成器（generator-iterator）。当返回的生成器调用成员方法时，相应的生成器函数中的代码才会执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def square():</span><br><span class="line">    for x in range(4):</span><br><span class="line">        yield x ** 2</span><br><span class="line">square_gen = square()</span><br><span class="line">for x in square_gen:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>前面说到，for 循环会调用 iter() 函数，获取一个生成器；而后调用 next() 函数，将生成器中的下一个值赋值给 x；再执行循环体。因此，上述 for 循环基本等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">genitor = square_gen.__iter__()</span><br><span class="line">while True:</span><br><span class="line">    x = geniter.next() # Python 3 是 __next__()</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>注意到，square 是一个生成器函数；作为它的返回值，square_gen 已经是一个迭代器；迭代器的 <strong>iter</strong>() 返回它自己。因此 geniter 对应的生成器函数，即是 square。</p>
<p>每次执行到 x = geniter.next() 时，square 函数会从上一次暂停的位置开始，一直执行到下一个 yield 表达式，将 yield 关键字后的表达式列表返回给调用者，并再次暂停。注意，每次从暂停恢复时，生成器函数的内部变量、指令指针、内部求值栈等内容和暂停时完全一致。</p>
<p><strong>生成器的方法</strong></p>
<p>生成器有一些方法。调用这些方法可以控制对应的生成器函数；不过，若是生成器函数已在执行过程中，调用这些方法则会抛出 ValueError 异常。</p>
<ul>
<li>generator.next()：从上一次在 yield 表达式暂停的状态恢复，继续执行到下一次遇见 yield 表达式。当该方法被调用时，当前 yield 表达式的值为 None，下一个 yield 表达式中的表达式列表会被返回给该方法的调用者。若没有遇到 yield 表达式，生成器函数就已经退出，那么该方法会抛出 StopIterator 异常。</li>
<li>generator.send(value)：和 generator.next() 类似，差别仅在与它会将当前 yield 表达式的值设置为 value。</li>
<li>generator.throw(type[, value[, traceback]])：向生成器函数抛出一个类型为 type 值为 value 调用栈为 traceback 的异常，而后让生成器函数继续执行到下一个 yield 表达式。其余行为与 generator.next() 类似。</li>
<li>generator.close()：告诉生成器函数，当前生成器作废不再使用。</li>
</ul>
<h2 id="举例和说明"><a href="#举例和说明" class="headerlink" title="举例和说明"></a>举例和说明</h2><p><strong>如果你看不懂生成器函数</strong></p>
<p>如果你还是不太能理解生成器函数，那么大致上你可以这样去理解。</p>
<ul>
<li>在函数开始处，加入 result = list()；</li>
<li>将每个 yield 表达式 yield expr 替换为 result.append(expr)；</li>
<li>在函数末尾处，加入 return result。</li>
</ul>
<p><strong>关于「下一个」yield 表达式</strong></p>
<p>介绍「生成器的方法」时，我们说当调用 generator.next() 时，生成器函数会从当前位置开始执行到下一个 yield 表达式。这里的「下一个」指的是执行逻辑的下一个。因此</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f123():</span><br><span class="line">    yield 1</span><br><span class="line">    yield 2</span><br><span class="line">    yield 3</span><br><span class="line"></span><br><span class="line">for item in f123(): # 1, 2, and 3, will be printed</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line">def f13():</span><br><span class="line">    yield 1</span><br><span class="line">    while False:</span><br><span class="line">        yield 2</span><br><span class="line">    yield 3</span><br><span class="line"></span><br><span class="line">for item in f13(): # 1 and 3, will be printed</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>
<h2 id="yield-的好处"><a href="#yield-的好处" class="headerlink" title="yield 的好处"></a>yield 的好处</h2><p>Python 的老用户应该会熟悉 Python 2 中的一个特性：内建函数 range 和 xrange。其中，range 函数返回的是一个列表，而 xrange 返回的是一个迭代器。</p>
<blockquote>
<p>在 Python 3 中，range 相当于 Python 2 中的 xrange；而 Python 2 中的 range 可以用 list(range()) 来实现。</p>
</blockquote>
<p>Python 之所以要提供这样的解决方案，是因为在很多时候，我们只是需要逐个顺序访问容器内的元素。大多数时候，我们不需要「一口气获取容器内所有的元素」。比方说，顺序访问容器内的前 5 个元素，可以有两种做法：</p>
<p>获取容器内的所有元素，然后取出前 5 个；</p>
<ul>
<li>从头开始，逐个迭代容器内的元素，迭代 5 个元素之后停止。</li>
<li>显而易见，如果容器内的元素数量非常多（比如有 10 ** 8 个），或者容器内的元素体积非常大，那么后一种方案能节省巨大的时间、空间开销。</li>
</ul>
<p>现在假设，我们有一个函数，其产出（返回值）是一个列表。而若我们知道，调用者对该函数的返回值，只有逐个迭代这一种方式。那么，如果函数生产列表中的每一个元素都需要耗费非常多的时间，或者生成所有元素需要等待很长时间，则使用 yield 把函数变成一个生成器函数，每次只产生一个元素，就能节省很多开销了。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>转自：<a href="https://liam.page/2017/06/30/understanding-yield-in-python/" target="_blank" rel="noopener">https://liam.page/2017/06/30/understanding-yield-in-python/</a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的元类</title>
    <url>/2021/04/28/python%E4%B8%AD%E7%9A%84%E5%85%83%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="类也是对象"><a href="#类也是对象" class="headerlink" title="类也是对象"></a>类也是对象</h4><p>在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class ObjectCreator(object):</span><br><span class="line">…       pass</span><br><span class="line">…</span><br><span class="line">&gt;&gt;&gt; my_object = ObjectCreator()</span><br><span class="line">&gt;&gt;&gt; print my_object</span><br><span class="line">&lt;__main__.ObjectCreator object at 0x8974f2c&gt;</span><br></pre></td></tr></table></figure>
<p>但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。</p>
<p>下面的代码段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class ObjectCreator(object):</span><br><span class="line">…       pass</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<p>将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作：</p>
<ol>
<li>可以将它赋值给一个变量</li>
<li>可以拷贝它</li>
<li>可以为它增加属性</li>
<li>可以将它作为函数参数进行传递</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print ObjectCreator     # 你可以打印一个类，因为它其实也是一个对象</span><br><span class="line">&lt;class &apos;__main__.ObjectCreator&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; def echo(o):</span><br><span class="line">…       print o</span><br><span class="line">…</span><br><span class="line">&gt;&gt;&gt; echo(ObjectCreator)                 # 你可以将类做为参数传给函数</span><br><span class="line">&lt;class &apos;__main__.ObjectCreator&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; print hasattr(ObjectCreator, &apos;new_attribute&apos;)</span><br><span class="line">Fasle</span><br><span class="line">&gt;&gt;&gt; ObjectCreator.new_attribute = &apos;foo&apos; #  你可以为类增加属性</span><br><span class="line">&gt;&gt;&gt; print hasattr(ObjectCreator, &apos;new_attribute&apos;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; print ObjectCreator.new_attribute</span><br><span class="line">foo</span><br><span class="line">&gt;&gt;&gt; ObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量</span><br><span class="line">&gt;&gt;&gt; print ObjectCreatorMirror()</span><br><span class="line">&lt;__main__.ObjectCreator object at 0x8997b4c&gt;</span><br></pre></td></tr></table></figure>
<h4 id="动态地创建类"><a href="#动态地创建类" class="headerlink" title="动态地创建类"></a>动态地创建类</h4><p>因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def choose_class(name):</span><br><span class="line">…       if name == &apos;foo&apos;:</span><br><span class="line">…           class Foo(object):</span><br><span class="line">…               pass</span><br><span class="line">…           return Foo     # 返回的是类，不是类的实例</span><br><span class="line">…       else:</span><br><span class="line">…           class Bar(object):</span><br><span class="line">…               pass</span><br><span class="line">…           return Bar</span><br><span class="line">…</span><br><span class="line">&gt;&gt;&gt; MyClass = choose_class(&apos;foo&apos;)</span><br><span class="line">&gt;&gt;&gt; print MyClass              # 函数返回的是类，不是类的实例</span><br><span class="line">&lt;class &apos;__main__&apos;.Foo&gt;</span><br><span class="line">&gt;&gt;&gt; print MyClass()            # 你可以通过这个类创建类实例，也就是对象</span><br><span class="line">&lt;__main__.Foo object at 0x89c6d4c&gt;</span><br></pre></td></tr></table></figure>
<p>但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。还记得内建函数type吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print type(1)</span><br><span class="line">&lt;type &apos;int&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; print type(&quot;1&quot;)</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; print type(ObjectCreator)</span><br><span class="line">&lt;type &apos;type&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; print type(ObjectCreator())</span><br><span class="line">&lt;class &apos;__main__.ObjectCreator&apos;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用type创建类"><a href="#使用type创建类" class="headerlink" title="使用type创建类"></a>使用type创建类</h4><p><strong>type有一种完全不同的功能，动态的创建类。</strong><br>type可以接受一个类的描述作为参数，然后返回一个类。（我知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）<br>type可以像这样工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type(类名, 由父类名称组成的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</span><br></pre></td></tr></table></figure>
<p>比如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyShinyClass(object):</span><br><span class="line">…       pass</span><br></pre></td></tr></table></figure>
<p>可以手动像这样创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; MyShinyClass = type(&apos;MyShinyClass&apos;, (), &#123;&#125;)  # 返回一个类对象</span><br><span class="line">&gt;&gt;&gt; print MyShinyClass</span><br><span class="line">&lt;class &apos;__main__.MyShinyClass&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; print MyShinyClass()  #  创建一个该类的实例</span><br><span class="line">&lt;__main__.MyShinyClass object at 0x8997cec&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用type创建带有属性的类"><a href="#使用type创建带有属性的类" class="headerlink" title="使用type创建带有属性的类"></a>使用type创建带有属性的类</h4><p>type 接受一个字典来为类定义属性，因此</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class Foo(object):</span><br><span class="line">…       bar = True</span><br><span class="line"></span><br><span class="line">可以翻译为：</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Foo = type(&apos;Foo&apos;, (), &#123;&apos;bar&apos;:True&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="使用type创建带有方法的类"><a href="#使用type创建带有方法的类" class="headerlink" title="使用type创建带有方法的类"></a>使用type创建带有方法的类</h4><p>最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。</p>
<p><strong>添加实例方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [46]: def echo_bar(self):</span><br><span class="line">    ...:     print self.bar</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [47]: FooChild = type(&apos;FooChild&apos;, (Foo,), &#123;&apos;echo_bar&apos;: echo_bar&#125;)</span><br><span class="line"></span><br><span class="line">In [48]: hasattr(Foo, &apos;echo_bar&apos;)</span><br><span class="line">Out[48]: False</span><br><span class="line"></span><br><span class="line">In [49]:</span><br><span class="line"></span><br><span class="line">In [49]: hasattr(FooChild, &apos;echo_bar&apos;)</span><br><span class="line">Out[49]: True</span><br><span class="line"></span><br><span class="line">In [50]: my_foo = FooChild()</span><br><span class="line"></span><br><span class="line">In [51]: my_foo.echo_bar()</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p><strong>添加静态方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [36]: @staticmethod</span><br><span class="line">    ...: def testStatic():</span><br><span class="line">    ...:     print(&quot;static method ....&quot;)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [37]: Foochild = type(&apos;Foochild&apos;, (Foo,), &#123;&quot;echo_bar&quot;:echo_bar, &quot;testStatic&quot;:</span><br><span class="line">    ...: testStatic&#125;)</span><br><span class="line"></span><br><span class="line">In [38]: fooclid = Foochild()</span><br><span class="line"></span><br><span class="line">In [39]: fooclid.testStatic</span><br><span class="line">Out[39]: &lt;function __main__.testStatic&gt;</span><br><span class="line"></span><br><span class="line">In [40]: fooclid.testStatic()</span><br><span class="line">static method ....</span><br><span class="line"></span><br><span class="line">In [41]: fooclid.echo_bar()</span><br><span class="line">True</span><br><span class="line">添加类方法</span><br><span class="line"></span><br><span class="line">In [42]: @classmethod</span><br><span class="line">    ...: def testClass(cls):</span><br><span class="line">    ...:     print(cls.bar)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [43]:</span><br><span class="line"></span><br><span class="line">In [43]: Foochild = type(&apos;Foochild&apos;, (Foo,), &#123;&quot;echo_bar&quot;:echo_bar, &quot;testStatic&quot;:</span><br><span class="line">    ...: testStatic, &quot;testClass&quot;:testClass&#125;)</span><br><span class="line"></span><br><span class="line">In [44]:</span><br><span class="line"></span><br><span class="line">In [44]: fooclid = Foochild()</span><br><span class="line"></span><br><span class="line">In [45]: fooclid.testClass()</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<h4 id="什么是元类"><a href="#什么是元类" class="headerlink" title="什么是元类"></a>什么是元类</h4><p>元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。好吧，元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyClass = MetaClass() #使用元类创建出一个对象，这个对象称为“类”</span><br><span class="line">MyObject = MyClass() #使用“类”来创建出实例对象</span><br></pre></td></tr></table></figure>
<p>你已经看到了type可以让你像这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyClass = type(&apos;MyClass&apos;, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查<strong>class</strong>属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来，这个类就是type。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的动态导入</title>
    <url>/2020/12/03/python%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一个函数运行需要根据不同项目的配置，动态导入对应的配置文件运行。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件结构</span><br><span class="line"></span><br><span class="line">a #文件夹</span><br><span class="line">	│a.py</span><br><span class="line">	│__init__.py</span><br><span class="line">b #文件夹</span><br><span class="line">	│b.py</span><br><span class="line">	│__init__.py</span><br><span class="line">	├─c#文件夹</span><br><span class="line">		│c.py</span><br><span class="line">		│__init__.py</span><br><span class="line"></span><br><span class="line"># c.py 中内容</span><br><span class="line">args = &#123;&apos;a&apos;:1&#125;</span><br><span class="line"></span><br><span class="line">class C:</span><br><span class="line">    </span><br><span class="line">    def c(self):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>向a模块中导入c.py 中的对象</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import importlib</span><br><span class="line"></span><br><span class="line">params = importlib.import_module(&apos;b.c.c&apos;) #绝对导入</span><br><span class="line">params_ = importlib.import_module(&apos;.c.c&apos;,package=&apos;b&apos;) #相对导入</span><br><span class="line"></span><br><span class="line"># 对象中取出需要的对象</span><br><span class="line">params.args #取出变量</span><br><span class="line">params.C  #取出class C</span><br><span class="line">params.C.c  #取出class C 中的c 方法</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的异常</title>
    <url>/2020/09/19/python%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>当你的程序出现例外情况时就会发生异常（Exception）。例如，当你想要读取一个文件时，而那个文件却不存在，怎么办？又或者你在程序执行时不小心把它删除了，怎么办？这些通过使用异常来进行处理。</p>
<p>类似地，如果你的程序中出现了一些无效的语句该怎么办？Python 将会对此进行处理，举起（Raises）1它的小手来告诉你哪里出现了一个错误（Error）。</p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>你可以想象一个简单的 print 函数调用。如果我们把 print 误拼成 Print 会怎样？你会注意到它的首字母是大写。在这一例子中，Python 会抛出（Raise）一个语法错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Print(&quot;Hello World&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: name &apos;Print&apos; is not defined</span><br><span class="line">&gt;&gt;&gt; print(&quot;Hello World&quot;)</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p>你会注意到一个 NameError 错误被抛出，同时 Python 还会打印出检测到的错误发生的位置。这就是一个错误错误处理器（Error Handler）2 为这个错误所做的事情。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>我们将尝试（Try）去读取用户的输入内容。按下 [ctrl-d] 来看看会发生什么事情。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = input(&apos;Enter something --&gt; &apos;)</span><br><span class="line">Enter something --&gt; Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">EOFError</span><br></pre></td></tr></table></figure>
<p>此处 Python 指出了一个称作 EOFError 的错误，代表着它发现了一个文件结尾（End of File）符号（由 ctrl-d 实现）在不该出现的时候出现了。</p>
<h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><p>我们可以通过使用 try..except 来处理异常状况。一般来说我们会把通常的语句放在 try 代码块中，将我们的错误处理器代码放置在 except 代码块中。</p>
<p>案例（保存文 exceptions_handle.py）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    text = input(&apos;Enter something --&gt; &apos;)</span><br><span class="line">except EOFError:</span><br><span class="line">    print(&apos;Why did you do an EOF on me?&apos;)</span><br><span class="line">except KeyboardInterrupt:</span><br><span class="line">    print(&apos;You cancelled the operation.&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;You entered &#123;&#125;&apos;.format(text))</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"># Press ctrl + d</span><br><span class="line">$ python exceptions_handle.py</span><br><span class="line">Enter something --&gt; Why did you do an EOF on me?</span><br><span class="line"></span><br><span class="line"># Press ctrl + c</span><br><span class="line">$ python exceptions_handle.py</span><br><span class="line">Enter something --&gt; ^CYou cancelled the operation.</span><br><span class="line"></span><br><span class="line">$ python exceptions_handle.py</span><br><span class="line">Enter something --&gt; No exceptions</span><br><span class="line">You entered No exceptions</span><br></pre></td></tr></table></figure>
<p>我们将所有可能引发异常或错误的语句放在 try 代码块中，并将相应的错误或异常的处理器（Handler）放在 except 子句或代码块中。except 子句可以处理某种特定的错误或异常，或者是一个在括号中列出的错误或异常。如果没有提供错误或异常的名称，它将处理所有错误与异常。</p>
<p>要注意到必须至少有一句 except 字句与每一句 try 字句相关联。不然，有一个 try 代码块又有什么意义？</p>
<p>如果没有任何错误或异常被处理，那么将调用 Python 默认处理器，它只会终端程序执行并打印出错误信息。我们已经在前面的章节里见过了这种处理方式。</p>
<p>你还可以拥有一个 else 子句与 try..except 代码块相关联。else 子句将在没有发生异常的时候执行。</p>
<p>在下一个案例中，我们还将了解如何获取异常对象以便我们可以检索其他信息。</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>你可以通过 raise 语句来引发一次异常，具体方法是提供错误名或异常名以及要抛出（Thrown）异常的对象。</p>
<p>你能够引发的错误或异常必须是直接或间接从属于 Exception（异常） 类的派生类。</p>
<p>案例（保存为 exceptions_raise.py）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># encoding=UTF-8</span><br><span class="line"></span><br><span class="line">class ShortInputException(Exception):</span><br><span class="line">    &apos;&apos;&apos;一个由用户定义的异常类&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, length, atleast):</span><br><span class="line">        Exception.__init__(self)</span><br><span class="line">        self.length = length</span><br><span class="line">        self.atleast = atleast</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    text = input(&apos;Enter something --&gt; &apos;)</span><br><span class="line">    if len(text) &lt; 3:</span><br><span class="line">        raise ShortInputException(len(text), 3)</span><br><span class="line">    # 其他工作能在此处继续正常运行</span><br><span class="line">except EOFError:</span><br><span class="line">    print(&apos;Why did you do an EOF on me?&apos;)</span><br><span class="line">except ShortInputException as ex:</span><br><span class="line">    print((&apos;ShortInputException: The input was &apos; +</span><br><span class="line">           &apos;&#123;0&#125; long, expected at least &#123;1&#125;&apos;)</span><br><span class="line">          .format(ex.length, ex.atleast))</span><br><span class="line">else:</span><br><span class="line">    print(&apos;No exception was raised.&apos;)</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">$ python exceptions_raise.py</span><br><span class="line">Enter something --&gt; a</span><br><span class="line">ShortInputException: The input was 1 long, expected at least 3</span><br><span class="line"></span><br><span class="line">$ python exceptions_raise.py</span><br><span class="line">Enter something --&gt; abc</span><br><span class="line">No exception was raised.</span><br></pre></td></tr></table></figure>
<p>它是如何工作的</p>
<p>在本例中，我们创建了我们自己的异常类型。这一新的异常类型叫作 ShortInputException。它包含两个字段——获取给定输入文本长度的 length，程序期望的最小长度 atleast。</p>
<p>在 except 子句中，我们提及了错误类，将该类存储 as（为） 相应的错误名或异常名。这类似于函数调用中的形参与实参。在这个特殊的 except 子句中我们使用异常对象的 length 与 atleast 字段来向用户打印一条合适的信息。</p>
<h2 id="Try-…-Finally"><a href="#Try-…-Finally" class="headerlink" title="Try … Finally"></a>Try … Finally</h2><p>假设你正在你的读取中读取一份文件。你应该如何确保文件对象被正确关闭，无论是否会发生异常？这可以通过 finally 块来完成。</p>
<p>保存该程序为 exceptions_finally.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">f = None</span><br><span class="line">try:</span><br><span class="line">    f = open(&quot;poem.txt&quot;)</span><br><span class="line">    # 我们常用的文件阅读风格</span><br><span class="line">    while True:</span><br><span class="line">        line = f.readline()</span><br><span class="line">        if len(line) == 0:</span><br><span class="line">            break</span><br><span class="line">        print(line, end=&apos;&apos;)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">        print(&quot;Press ctrl+c now&quot;)</span><br><span class="line">        # 为了确保它能运行一段时间</span><br><span class="line">        time.sleep(2)</span><br><span class="line">except IOError:</span><br><span class="line">    print(&quot;Could not find file poem.txt&quot;)</span><br><span class="line">except KeyboardInterrupt:</span><br><span class="line">    print(&quot;!! You cancelled the reading from the file.&quot;)</span><br><span class="line">finally:</span><br><span class="line">    if f:</span><br><span class="line">        f.close()</span><br><span class="line">    print(&quot;(Cleaning up: Closed the file)&quot;)</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">$ python exceptions_finally.py</span><br><span class="line">Programming is fun</span><br><span class="line">Press ctrl+c now</span><br><span class="line">^C!! You cancelled the reading from the file.</span><br><span class="line">(Cleaning up: Closed the file)</span><br></pre></td></tr></table></figure>
<p>我们按照通常文件读取进行操作，但是我们同时通过使用 time.sleep 函数任意在每打印一行后插入两秒休眠，使得程序运行变得缓慢（在通常情况下 Python 运行得非常快速）。当程序在处在运行过过程中时，按下 ctrl + c 来中断或取消程序。</p>
<p>你会注意到 KeyboardInterrupt 异常被抛出，尔后程序退出。不过，在程序退出之前，finally 子句得到执行，文件对象总会被关闭。</p>
<p>另外要注意到我们在 print 之后使用了 sys.stout.flush()，以便它能被立即打印到屏幕上。</p>
<h2 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h2><p>在 try 块中获取资源，然后在 finally 块中释放资源是一种常见的模式。因此，还有一个 with 语句使得这一过程可以以一种干净的姿态得以完成。</p>
<p>保存为 exceptions_using_with.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&quot;poem.txt&quot;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        print(line, end=&apos;&apos;)</span><br></pre></td></tr></table></figure>
<p>程序输出的内容应与上一个案例所呈现的相同。本例的不同之处在于我们使用的是 open 函数与 with 语句——我们将关闭文件的操作交由 with open 来自动完成。</p>
<p>在幕后发生的事情是有一项 with 语句所使用的协议（Protocol）。它会获取由 open 语句返回的对象，在本案例中就是“thefile”。</p>
<p>它总会在代码块开始之前调用 thefile.<strong>enter</strong> 函数，并且总会在代码块执行完毕之后调用 thefile.<strong>exit</strong>。</p>
<p>因此，我们在 finally 代码块中编写的代码应该格外留心 <strong>exit</strong> 方法的自动操作。这能够帮助我们避免重复显式使用 try..finally 语句。</p>
<p>有关该话题的更多讨论已经超出了本书所能涉及的范围，因此请参考 PEP 343 来了解更加全面的解释。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的循环导入问题</title>
    <url>/2020/12/03/python%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>循环导入的最好的解决方法是从架构上优化，即调整模块和模块成员变量的设计。一个好的原则是：可导出的成员变量，都不应该依赖于导入进来的成员变量。<br>但是在业务开发的过程中，总会遇到通过架构层面解决不了的导入问题，这时候就只能通过语言层面来解决了。</p>
<p>目录结构（下面的案例的目录结构都是这样的）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root.py</span><br><span class="line">/pack1</span><br><span class="line">    __init__.py</span><br><span class="line">    module_a.py</span><br><span class="line">/pack2</span><br><span class="line">    __init__.py</span><br><span class="line">    module_b.py</span><br><span class="line">module_c.py</span><br><span class="line">module_d.py</span><br></pre></td></tr></table></figure></p>
<h2 id="循环导入例子"><a href="#循环导入例子" class="headerlink" title="循环导入例子"></a>循环导入例子</h2><p>首先看一下什么是循环导入和循环导入的原因。<br>root.py<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pack1.module_a import class_a</span><br></pre></td></tr></table></figure></p>
<p>module_a.py<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print &quot;start init module a&quot;</span><br><span class="line">from pack2.module_b import class_b</span><br><span class="line">class class_a():</span><br><span class="line">    def f(self):</span><br><span class="line">        class_b</span><br><span class="line">print &quot;init module a&quot;</span><br></pre></td></tr></table></figure></p>
<p>module_b.py<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print &quot;start init module b&quot;</span><br><span class="line">from pack1.module_a import class_a</span><br><span class="line">class class_b():</span><br><span class="line">    def f(self):</span><br><span class="line">        class_a</span><br><span class="line">print &quot;init module b&quot;</span><br></pre></td></tr></table></figure></p>
<p>会报错：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start init module a</span><br><span class="line">start init module b</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;E:/my_demo/demo2016/bѭ������/s2/root.py&quot;, line 2, in &lt;module&gt;</span><br><span class="line">    from pack1.module_a import class_a</span><br><span class="line">  File &quot;E:\my_demo\demo2016\bѭ������\s2\pack1\module_a.py&quot;, line 2, in &lt;module&gt;</span><br><span class="line">    from pack2.module_b import class_b</span><br><span class="line">  File &quot;E:\my_demo\demo2016\bѭ������\s2\pack2\module_b.py&quot;, line 2, in &lt;module&gt;</span><br><span class="line">    from pack1.module_a import class_a</span><br><span class="line">ImportError: cannot import name class_a</span><br></pre></td></tr></table></figure></p>
<p>代码执行的流程：</p>
<ol>
<li>执行root.py的from pack1.module_a import class_a，发现需要导入模块module_a</li>
<li>一个空的字典会被创建，对应module_a的globals</li>
<li>module_a的代码会被执行，当执行到from pack2.module_b import class_b时，发现需要导入模块module_b</li>
<li>一个空的字典会被创建，对应module_b的globals</li>
<li>module_b的代码会被执行，当执行到from pack1.module_a import class_a时，发现需要导入模块module_a，但是此时已经有module_a的globals了，所以直接访问字典里的class_a，但是由于module_a的globals还是空的，即里面没有class_a，所以抛出异常</li>
</ol>
<p>参考文档<br>所以根本原因是：在导入的时候，module_b需要访问module_a的变量class_a，但是class_a没有初始化完成<br>所以解决方法有两个：</p>
<p>在导入的时候，让module_b不要访问module_a的变量，也就是方案一<br>class_a初始化完成后，才让module_b访问module_a的变量，也就是方案二和三</p>
<h2 id="方案一、使用import-…代替-from…import…"><a href="#方案一、使用import-…代替-from…import…" class="headerlink" title="方案一、使用import …代替 from…import…"></a>方案一、使用import …代替 from…import…</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root.py</span><br><span class="line"></span><br><span class="line">import pack1.module_a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_a.py</span><br><span class="line"></span><br><span class="line">print &quot;start init module a&quot;</span><br><span class="line">import pack2.module_b </span><br><span class="line">class class_a():</span><br><span class="line">    def f(self):</span><br><span class="line">        m_b.class_b</span><br><span class="line">print &quot;init module a&quot;</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_b.py</span><br><span class="line"></span><br><span class="line">print &quot;start init module b&quot;</span><br><span class="line">import pack1.module_a </span><br><span class="line">class class_b():</span><br><span class="line">    def f(self):</span><br><span class="line">        pack1.module_a.class_a</span><br><span class="line">print &quot;init module b&quot;</span><br></pre></td></tr></table></figure>
<p>module_a和module_b都会被编译，终端会输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start init module a</span><br><span class="line">start init module b</span><br><span class="line">init module b</span><br><span class="line">init module a</span><br></pre></td></tr></table></figure>
<p>即首先编译a，编译过程中发现需要编译b，编译b完成后，编译a剩下的部分、</p>
<p>这个案例不使用from….import….，而使用import,这样是可以成功循环导入的，不过一个缺点是，每次访问module的时候，都需要写全路径，例如pack1.module_a.class_a，非常繁琐。<br>一个优化的方案是导入的时候，使用import….as… 例如：import pack1.module_a as m_a。但是很奇怪的是，在module_a中可以这样用，但是在module_b中不可以，否则就会导致报错。还有如果把roo.py改为import pack2.module_b,就会反过来，即module_b中可以这样用，但是在module_a中不可以。所以准确点应该是在root.py导入的模块中可以使用，但是在其他模块不能使用。所以import….as…这个方案并不好。<br>注意，import…只能import到模块，不能import模块里面的成员变量，例如import pack1.module_a.class_a 是不可以的</p>
<p>这个方案的缺点就是访问模块里面的成员变量太繁琐</p>
<h2 id="方案二、把导入放在后面"><a href="#方案二、把导入放在后面" class="headerlink" title="方案二、把导入放在后面"></a>方案二、把导入放在后面</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pack1.module_a import class_a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &quot;start init module a&quot;</span><br><span class="line">#from pack2.module_b import class_b #放在这里会报错</span><br><span class="line">class class_a():</span><br><span class="line">    def f(self):</span><br><span class="line">        # m_b.class_b</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">from pack2.module_b import class_b #放在这里不会</span><br><span class="line">class class_c():</span><br><span class="line">    def f(self):</span><br><span class="line">        class_b</span><br><span class="line">print &quot;init module a&quot;</span><br></pre></td></tr></table></figure>
<p>当存在类似的依赖关系：class_c依赖class_b依赖class_a，然后class_a和class_c在同一个模块时，可以使用这种方案。<br>把from pack2.module_b import class_b这句放在class_a后面，这样在module_b中访问module_a.class_a是成功的，因为class_a的定义代码已经执行完成，并被添加到module_a的globals中。</p>
<h2 id="方案三、把导入语句放在语句块中"><a href="#方案三、把导入语句放在语句块中" class="headerlink" title="方案三、把导入语句放在语句块中"></a>方案三、把导入语句放在语句块中</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pack1.module_a import func_a</span><br><span class="line"></span><br><span class="line">print &apos;root start run func a&apos;</span><br><span class="line">func_a()</span><br><span class="line">print &apos;root end run func a&apos;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module_a.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &quot;start init module a&quot;</span><br><span class="line"></span><br><span class="line">def func_a():</span><br><span class="line">    from pack2.module_b import func_b</span><br><span class="line">    func_b()</span><br><span class="line">    print &apos;run func a&apos;</span><br><span class="line">print &quot;init module a&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module_b.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print &quot;start init module b&quot;</span><br><span class="line"></span><br><span class="line">def func_b():</span><br><span class="line">    from pack1.module_a import func_a</span><br><span class="line">    print &apos;run func b&apos;</span><br><span class="line"></span><br><span class="line">print &quot;init module b&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start init module a</span><br><span class="line">init module a</span><br><span class="line">root start run func a</span><br><span class="line">start init module b</span><br><span class="line">init module b</span><br><span class="line">run func b</span><br><span class="line">run func a</span><br><span class="line">root end run func a</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start init module a</span><br><span class="line">init module a</span><br><span class="line">root start run func a</span><br><span class="line">start init module b</span><br><span class="line">init module b</span><br><span class="line">run func b</span><br><span class="line">run func a</span><br><span class="line">root end run func a</span><br></pre></td></tr></table></figure>
<p>在需要使用func_b的时候，才进行导入操作，这样在执行module_b的时候，module_a已经初始化完成，module_a的globals已经有func_a了，所以导入不会报错。</p>
<p>查看已经导入的module情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from pack1.module_a import func_a</span><br><span class="line">print sys.modules  </span><br><span class="line"># &#123;&apos;pack1&apos;: &lt;module &apos;pack1&apos; from &apos;E:\my_demo\demo2016\bѭ������\s4\pack1\__init__.pyc&apos;&gt;,&#125;</span><br><span class="line">print sys.modules[&apos;pack1.module_a&apos;].__dict__</span><br><span class="line"># &#123;&apos;func_a&apos;: &lt;function func_a at 0x0254FB30&gt;, &apos;__doc__&apos;: None&#125;</span><br><span class="line">sys.modules[&apos;pack1.module_a&apos;].func_a_tmp=sys.modules[&apos;pack1.module_a&apos;].func_a</span><br></pre></td></tr></table></figure>
<p>通过sys.modules可以访问所有当前已导入的模块。<br>modules是一个字典，key是模块的路径，例如pack1.module_a,value是一个模块对象<br>模块对象中，属性名是模块中全局变量的名字，即sys.modules[‘pack1.module_a’].<strong>dict</strong>等于module_a里面的globals()</p>
<p>所以，当在module_b中执行from pack1.module_a import class_a时，相当于执行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">if &apos;pack1.module_a&apos; in sys.modules:</span><br><span class="line">    if hasattr(sys.modules[&apos;pack1.module_a&apos;],&quot;class_a&quot;):</span><br><span class="line">        sys.modules[&apos;pack2.module_b&apos;].class_a=sys.modules[&apos;pack1.module_a&apos;].class_a</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(u&quot;循环导入异常&quot;)</span><br><span class="line">else:</span><br><span class="line">    #执行导入pack1.module_a的操作，也就是初始化一个module对象，然后令sys.modules[&apos;pack1.module_a&apos;]=这个对象</span><br></pre></td></tr></table></figure>
<p>所以解决循环导入的问题，就相当于使上面的代码不会执行到raise Exception(u”循环导入异常”)这一句，方案一和方案二都是通过这种方法解决的。</p>
]]></content>
  </entry>
  <entry>
    <title>python中的魔法函数</title>
    <url>/2021/04/21/python%E4%B8%AD%E7%9A%84%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>在Python的类中，以两个下划线开头、两个下划线结尾的方法，如常见的 ：<strong>init</strong>、<strong>str</strong>、<strong>del</strong>等，就被称为「魔术方法」（Magic methods）。魔术方法在类或对象的某些事件出发后会自动执行，如果希望根据自己的程序定制特殊功能的类，那么就需要对这些方法进行重写。使用这些「魔法方法」，我们可以非常方便地给类添加特殊的功能。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>构造与初始化</li>
<li>类的表示</li>
<li>访问控制</li>
<li>比较操作</li>
<li>容器类操作</li>
<li>可调用对象</li>
<li>序列化</li>
</ul>
<h4 id="构造与初始化"><a href="#构造与初始化" class="headerlink" title="构造与初始化"></a>构造与初始化</h4><p><strong>1. <strong>new</strong>()</strong></p>
<ul>
<li><strong>new</strong>(cls, […]) 是在一个对象实例化的时候所调用的第一个方法，所以它才是真正意义上的构造方法。</li>
<li>它的第一个参数是这个类，其他的参数是用来直接传递给 <strong>init</strong> 方法。</li>
<li><strong>new</strong> 决定是否要使用该 <strong>init</strong> 方法，因为 <strong>new</strong> 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 <strong>new</strong> 没有返回实例对象，则 <strong>init</strong> 不会被调用。</li>
<li><strong>new</strong> 主要是用于继承一个不可变的类型比如一个 tuple 或者 string。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;__new__()方法被调用了&quot;)</span><br><span class="line">        print(&apos;这个是*agrs&apos;, *args)</span><br><span class="line">        print(&apos;这个是kwagrs&apos;, **kwargs)</span><br><span class="line">        </span><br><span class="line">        # cls表示这个类，剩余所有的参数传给__init__()方法，</span><br><span class="line">        # 若不返回，则__init__()不会被调用</span><br><span class="line">        return object.__new__(cls)</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        print(&quot;__init__()方法被调用了&quot;)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        print(self.name, self.age)</span><br><span class="line"></span><br><span class="line">p = Person(&quot;张三&quot;, 20)</span><br><span class="line"></span><br><span class="line"># Output:</span><br><span class="line"># __new__()方法被调用了</span><br><span class="line"># 这个是*agrs 张三 20</span><br><span class="line"># 这个是kwagrs</span><br><span class="line"># __init__()方法被调用了</span><br><span class="line"># 张三 20</span><br></pre></td></tr></table></figure>
<p><strong>2. <strong>init</strong>()</strong></p>
<p><strong>init</strong>()方法：构造器，当一个实例被创建的时候调用的初始化方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">p1 = Person(&apos;张三&apos;, 20)</span><br><span class="line">p2 = Person(&apos;李四&apos;, 22)</span><br></pre></td></tr></table></figure>
<p><strong>3. <strong>del</strong>()</strong></p>
<p><strong>del</strong>()方法：析构器，当一个实例被销毁时自动调用的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Washer:</span><br><span class="line">    def __del__(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        当删除对象时，解释器会自动调用del方法</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        print(&apos;对象已删除！&apos;)</span><br><span class="line"></span><br><span class="line">haier = Washer() </span><br><span class="line"># output:</span><br><span class="line"># 对象已删除！</span><br></pre></td></tr></table></figure>
<h4 id="类的表示"><a href="#类的表示" class="headerlink" title="类的表示"></a>类的表示</h4><p><strong>1. <strong>str</strong>() 和<strong>repr</strong>()</strong></p>
<p><strong>repr</strong>的结果是让解释器用的，<strong>str</strong>的结果是让人看的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Washer:</span><br><span class="line">    def __int__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;我是__repr__()魔法方法！&apos;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        这个str的作用就是：类的说明或对象状态的说明</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return &apos;我是__str__魔法方法！&apos;</span><br></pre></td></tr></table></figure>
<p><strong>3. <strong>bool</strong>()</strong></p>
<p>当调用 bool(obj) 时，会调用 <strong>bool</strong>() 方法，返回 True 或 False</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, uid):</span><br><span class="line">        self.uid = uid</span><br><span class="line"></span><br><span class="line">    def __bool__(self):</span><br><span class="line">        return self.uid &gt; 10</span><br><span class="line"></span><br><span class="line">p1 = Person(4)</span><br><span class="line">p2 = Person(14)</span><br><span class="line">print(bool(p1))  # False</span><br><span class="line">print(bool(p2))  # True</span><br></pre></td></tr></table></figure>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><ul>
<li><strong>setattr</strong>：定义当一个属性被设置时的行为</li>
<li><strong>getattr</strong>：定义当用户试图获取一个不存在的属性时的行为</li>
<li><strong>delattr</strong>：删除某个属性时调用</li>
<li><strong>getattribute</strong>：访问任意属性或方法时调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line"></span><br><span class="line">    def __setattr__(self, key, value):</span><br><span class="line">        &quot;&quot;&quot;属性赋值&quot;&quot;&quot;</span><br><span class="line">        if key not in (&apos;name&apos;, &apos;age&apos;):</span><br><span class="line">            return</span><br><span class="line">        if key == &apos;age&apos; and value &lt; 0:</span><br><span class="line">            raise ValueError()</span><br><span class="line">        super(Person, self).__setattr__(key, value)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, key):</span><br><span class="line">        &quot;&quot;&quot;访问某个不存在的属性&quot;&quot;&quot;</span><br><span class="line">        return &apos;unknown&apos;</span><br><span class="line"></span><br><span class="line">    def __delattr__(self, key):</span><br><span class="line">        &quot;&quot;&quot;删除某个属性&quot;&quot;&quot;</span><br><span class="line">        if key == &apos;name&apos;:</span><br><span class="line">            raise AttributeError()</span><br><span class="line">        super().__delattr__(key)</span><br><span class="line"></span><br><span class="line">    def __getattribute__(self, key):</span><br><span class="line">        &quot;&quot;&quot;所有属性/方法调用都经过这里&quot;&quot;&quot;</span><br><span class="line">        if key == &apos;money&apos;:</span><br><span class="line">            return 100</span><br><span class="line">        elif key == &apos;hello&apos;:</span><br><span class="line">            return self.say</span><br><span class="line">        return super().__getattribute__(key)</span><br><span class="line"></span><br><span class="line">p1 = Person()</span><br><span class="line">p1.name = &apos;张三&apos;  # 调用__setattr__</span><br><span class="line">p1.age = 20  # 调用__setattr__</span><br><span class="line">print(p1.name, p1.age)  # 张三 20</span><br></pre></td></tr></table></figure>
<h4 id="容器类操作"><a href="#容器类操作" class="headerlink" title="容器类操作"></a>容器类操作</h4><p>容器类的魔法方法，主要包括：</p>
<ul>
<li><p><strong>setitem</strong>(self, key, value)：定义设置容器中指定元素的行为，相当于 self[key] = value；</p>
</li>
<li><p><strong>getitem</strong>(self, key)： 定义获取容器中指定元素的行为，相当于 self[key]；</p>
</li>
<li><p><strong>delitem</strong>(self, key)：定义删除容器中指定元素的行为，相当于 del self[key]；</p>
</li>
<li><p><strong>len</strong>(self)：定义当被 len() 调用时的行为（返回容器中元素的个数）；</p>
</li>
<li><p><strong>iter</strong>(self)：定义当迭代容器中的元素的行为；</p>
</li>
<li><p><strong>contains</strong>(self, item)：定义当使用成员测试运算符（in 或 not in）时的行为；</p>
</li>
<li><p><strong>reversed</strong>(self)：定义当被 reversed() 调用时的行为。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyList(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, values=None):</span><br><span class="line">        self.values = values</span><br><span class="line">        self._index = 0</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        self.values[key] = value</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, key):</span><br><span class="line">        return self.values[key]</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        del self.values[key]</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self.values)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self._index &gt;= len(self.values):</span><br><span class="line">            raise StopIteration</span><br><span class="line">        value = self.values[self._index]</span><br><span class="line">        self._index += 1</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">    def __contains__(self, key):</span><br><span class="line">        return key in self.values</span><br><span class="line"></span><br><span class="line">    def __reversed__(self):</span><br><span class="line">        return list(reversed(self.values))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    my_list = MyList([1, 2, 3, 4, 5])</span><br><span class="line">    print(len(my_list))</span><br></pre></td></tr></table></figure>
<h4 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h4><p>在Python中，方法也是一种高等的对象。这意味着他们也可以像其他对象一样被传递到方法中，这是一个非常惊人的特性。 Python中有一个特殊的魔术方法可以让类的实例的行为表现的像函数一样，你可以调用他们，将一个函数当做一个参数传到另外一个函数中等等。这个魔法方法就是 <strong>call</strong>(self, [args…])。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Circle(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, x, y):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    def __call__(self, x, y):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">a = Circle(10, 20)	 # __init__</span><br><span class="line">print(a.x, a.y)	# 10 20</span><br><span class="line"></span><br><span class="line">a(100, 200)	# 此时a这个对象可以当做一个方法来执行，这是__call__魔法方法的功劳</span><br><span class="line">print(a.x, a.y)	 # 100 200</span><br></pre></td></tr></table></figure>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul>
<li><p><strong>getstate</strong>()</p>
</li>
<li><p><strong>setstate</strong>()</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pickle</span><br><span class="line"></span><br><span class="line">class Person(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age, birthday):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.birthday = birthday</span><br><span class="line"></span><br><span class="line">    def __getstate__(self):</span><br><span class="line">        # 执行 pick.dumps 时 忽略 age 属性</span><br><span class="line">        return &#123;</span><br><span class="line">            &apos;name&apos;: self.name,</span><br><span class="line">            &apos;birthday&apos;: self.birthday</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    def __setstate__(self, state):</span><br><span class="line">        # 执行 pick.loads 时 忽略 age 属性</span><br><span class="line">        self.name = state[&apos;name&apos;]</span><br><span class="line">        self.birthday = state[&apos;birthday&apos;]</span><br><span class="line"></span><br><span class="line">person = Person(&apos;李四&apos;, 20, (2017, 2, 23))</span><br><span class="line">pickled_person = pickle.dumps(person) # 自动执行 __getstate__ 方法</span><br><span class="line"></span><br><span class="line">p = pickle.loads(pickled_person) # 自动执行 __setstate__ 方法</span><br><span class="line">print(p.name, p.birthday)  # 李四 (2017, 2, 23)</span><br><span class="line"># 由于执行 pick.loads 时 忽略 age 属性，所以下面执行回报错</span><br><span class="line">print(p.age)  # AttributeError: &apos;Person&apos; object has no attribute &apos;age&apos;</span><br></pre></td></tr></table></figure>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://www.cnblogs.com/Jimmy1988/p/6801795.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jimmy1988/p/6801795.html</a></li>
<li><a href="https://www.jb51.net/article/85719.htm" target="_blank" rel="noopener">https://www.jb51.net/article/85719.htm</a></li>
<li><a href="https://blog.csdn.net/weixin_45901519/article/details/110482428" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45901519/article/details/110482428</a></li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础小结</title>
    <url>/2021/02/18/python%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h3 id="python中sys-argv函数精简概括"><a href="#python中sys-argv函数精简概括" class="headerlink" title="python中sys.argv函数精简概括"></a>python中sys.argv函数精简概括</h3><ul>
<li>sys.argv[0]：给定脚本名是 ‘-‘ （标准输入）时，sys.argv[0] 是 ‘-‘。使用 -c command 时，sys.argv[0] 是 ‘-c’。如果使用选项 -m module，sys.argv[0] 就是包含目录的模块全名。</li>
<li>sys.argv[1]：sys.argv[1]是输出了参数所组成的列表的第一个元素</li>
<li>sys.argv[1:]：sys.argv[1:]是输出了参数所组成的列表，空格分割</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">print(sys.argv[0])</span><br><span class="line">print(sys.argv[1])</span><br><span class="line">print(sys.argv[1:])</span><br></pre></td></tr></table></figure>
<h3 id="python文件编码说明"><a href="#python文件编码说明" class="headerlink" title="python文件编码说明"></a>python文件编码说明</h3><p>python 支持3种编码声明，一般常用能见到下面两种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.# -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">这种写法是为了兼容Emacs的编码声明</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.短一点，但Emacs不能用# coding=utf-8</span><br><span class="line"></span><br><span class="line">短一点，但Emacs不能用</span><br></pre></td></tr></table></figure>
<p>之所以要声明未编码类型 ，主要是中文出错的问题。</p>
<p>在python 文件开头（一般是第一行或第二行），用来说明你的Python源程序文件用使用的编码。缺省情况下你的程序需要使用ascii码来写，但如果在其中写中文的话，python解释器一般会报错，但如果加上你所用的文件编码，python就会自动处理不再报错。</p>
<p>这里要注意的是：</p>
<p>1.coding 后面使用 “:” 或 “=” 都可以</p>
<p>2.但是， “:” 或 “=” 必须和 coding之间没有空格。之前我就试过有空格声明失败，还是不支持中文。至于 “:” 或 “=” 后面，有没有空格就没所谓了。</p>
<h3 id="Python-c-执行命令"><a href="#Python-c-执行命令" class="headerlink" title="Python -c 执行命令"></a>Python -c 执行命令</h3><h4 id="1-查看-Python-版本"><a href="#1-查看-Python-版本" class="headerlink" title="1. 查看 Python 版本"></a>1. 查看 Python 版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strong@foreverstrong:~$ python -V</span><br><span class="line">Python 3.6.8</span><br><span class="line">strong@foreverstrong:~$ </span><br><span class="line"></span><br><span class="line">strong@foreverstrong:~$ python --version</span><br><span class="line">Python 3.6.8</span><br><span class="line">strong@foreverstrong:~$</span><br></pre></td></tr></table></figure>
<h4 id="2-查看-Python-安装路径"><a href="#2-查看-Python-安装路径" class="headerlink" title="2. 查看 Python 安装路径"></a>2. 查看 Python 安装路径</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strong@foreverstrong:~$ python -c &quot;import sys; print(sys.executable)&quot;</span><br><span class="line">/usr/bin/python</span><br><span class="line">strong@foreverstrong:~$ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">strong@foreverstrong:~$ python -c &quot;import os; print(os.sys.executable)&quot;</span><br><span class="line">/usr/bin/python</span><br><span class="line">strong@foreverstrong:~$ </span><br><span class="line"></span><br><span class="line">strong@foreverstrong:~$ python -c &quot;import os; path = os.sys.executable; folder=path[0 : path.rfind(os.sep)]; print(folder)&quot;</span><br><span class="line">/usr/bin</span><br><span class="line">strong@foreverstrong:~$</span><br></pre></td></tr></table></figure>
<h3 id="Python-m-执行命令"><a href="#Python-m-执行命令" class="headerlink" title="Python -m 执行命令"></a>Python -m 执行命令</h3><blockquote>
<p>在 Python3 中，只需一行命令就能实现一个简单的 HTTP 服务：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m http.server 8000</span><br><span class="line"> </span><br><span class="line"># 注:在 Python2 中是这样</span><br><span class="line">python -m SimpleHTTPServer 8000</span><br></pre></td></tr></table></figure>
<p>执行后，在本机打开“ <a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a>  ”，或者在局域网内的其它机器上打开“  http://本机ip:8000   ”，就能访问到执行目录下的内容。</p>
<blockquote>
<p>与此类似，我们只需要一行命令“python -m pydoc -p xxx”，就能生成 HTML 格式的官方帮助文档，可以在浏览器中访问。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m pydoc -p 9000</span><br></pre></td></tr></table></figure>
<p>上面的命令执行了 pydoc 模块，会在 9000 端口启动一个 http 服务.</p>
<blockquote>
<p>它的第三个常见用法是执行 pdb 的调试命令“python -m pdb xxx.py”，以调试模式来执行“xxx.py”脚本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m pdb test.py</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>第四个同样挺有用的场景是用 timeit 在命令行中测试一小段代码的运行时间。以下的 3 段代码，用不同的方式拼接 “0-1-2-……-99” 数字串。可以直观地看出它们的效率差异：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m timeit &quot;&apos;-&apos;.join(str(n) for n in range(100))&quot;</span><br><span class="line">python -m timeit &quot;&apos;-&apos;.join([str(n) for n in range(100)])&quot;</span><br><span class="line">python -m timeit &quot;&apos;-&apos;.join(map(str,range(100)))&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>最后，还有一种常常被人忽略的场景：“python -m pip install xxx”。我们可能会习惯性地使用“pip install xxx”，或者做了版本区分时用“pip3 install xxx”，总之不在前面用“python -m”做指定。但这种写法可能会出问题。</p>
</blockquote>
<h3 id="m-选项的两种原理解析"><a href="#m-选项的两种原理解析" class="headerlink" title="-m 选项的两种原理解析"></a>-m 选项的两种原理解析</h3><p>看了前面的几种典型用法，你是否开始好奇： “-m”是怎么运作的？它是怎么实现的？</p>
<p>对于“python -m name”，一句话解释： Python 会检索 sys.path ，查找名字为“name”的模块或者包（含命名空间包），并将其内容当成“<strong>main</strong>”模块来执行。</p>
<p><strong>1、对于普通模块</strong></p>
<p>以“.py”为后缀的文件就是一个模块，在“-m”之后使用时，只需要使用模块名，不需要写出后缀，但前提是该模块名是有效的，且不能是用 C 语言写成的模块。</p>
<p>在“-m”之后，如果是一个无效的模块名，则会报错“No module named xxx”。</p>
<p>如果是一个带后缀的模块，则首先会导入该模块，然后可能报错：Error while finding module specification for ‘xxx.py’ (AttributeError: module ‘xxx’ has no attribute ‘<strong>path</strong>‘。</p>
<p><img src="/2021/02/18/python基础小结/python1.png" alt="avatar"></p>
<p>对于一个普通模块，有时候这两种写法表面看起来是等效的：<br>两种写法都会把定位到的模块脚本当成主程序入口来执行，即在执行时，该脚本的 <strong>name</strong> 都是”<strong>main</strong>“，跟 import 导入方式是不同的。</p>
<p>但它的前提是：在执行目录中存在着“test.py”，且只有唯一的“test”模块。对于本例，如果换一个目录执行的话，“python test.py”当然会报找不到文件的错误，然而，“python -m test”却不会报错，因为解释器在遍历 sys.path 时可以找到同名的“test”模块，并且执行：</p>
<p><img src="/2021/02/18/python基础小结/python2.png" alt="avatar"></p>
<p>由此差异，我们其实可以总结出“-m”的用法： 已知一个模块的名字，但不知道它的文件路径，那么使用“-m”就意味着交给解释器自行查找，若找到，则当成脚本执行。</p>
<p>直接运行脚本时，相当于给出了脚本的完整路径（不管是绝对路径还是相对路径），解释器根据 文件系统的查找机制， 定位到该脚本，然后执行 使用“-m”方式时，解释器需要在不 import 的情况下，在 所有模块命名空间 中查找，定位到脚本的路径，然后执行。为了实现这个过程，解释器会借助两个模块： pkgutil 和 runpy ，前者用来获取所有的模块列表，后者根据模块名来定位并执行脚本 </p>
<p><strong>2、对于包内模块</strong></p>
<p>如果“-m”之后要执行的是一个包，那么解释器经过前面提到的查找过程，先定位到该包，然后会去执行它的“<strong>main</strong>”子模块，也就是说，在包目录下需要实现一个“<strong>main</strong>.py”文件。</p>
<p>换句话说，假设有个包的名称是“pname”，那么， “python -m pname”，其实就等效于“python -m pname.<strong>main</strong>”。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python文件操作</title>
    <url>/2021/06/15/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>python和其它编程语言一样，Python 也具有操作文件（I/O）的能力，比如打开文件、读取和追加数据、插入和删除数据、关闭文件、删除文件等。</p>
<p>除了提供文件操作基本的函数之外，Python 还提供了很多模块，例如 fileinput 模块、pathlib 模块等，通过引入这些模块，我们可以获得大量实现文件操作可用的函数和方法（类属性和类方法），大大提供编写代码的效率。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>Python 中，对文件的操作有很多种，常见的操作包括创建、删除、修改权限、读取、写入等，这些操作可大致分为以下 2 类：</p>
<ol>
<li>删除、修改权限：作用于文件本身，属于系统级操作。</li>
<li>写入、读取：是文件最常用的操作，作用于文件的内容，属于应用级操作。</li>
</ol>
<p><strong>操作文件和目录</strong></p>
<p>其中，对文件的系统级操作功能单一，比较容易实现，可以借助 Python 中的专用模块（os、sys 等），并调用模块中的指定函数来实现。例如，假设如下代码文件的同级目录中有一个文件“a.txt”，通过调用 os 模块中的 remove 函数，可以将该文件删除，具体实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看当前目录的绝对路径:</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)</span><br><span class="line">&apos;/Users/michael&apos;</span><br><span class="line"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;/Users/zzz&apos;, &apos;testdir&apos;)</span><br><span class="line">&apos;/Users/michael/testdir&apos;</span><br><span class="line"># 然后创建一个目录:</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&apos;/Users/zzz/testdir&apos;)</span><br><span class="line"># 删掉一个目录:</span><br><span class="line">&gt;&gt;&gt; os.rmdir(&apos;/Users/zzz/testdir&apos;)</span><br></pre></td></tr></table></figure>
<p>要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.split(&apos;/Users/michael/testdir/file.txt&apos;)</span><br><span class="line">(&apos;/Users/michael/testdir&apos;, &apos;file.txt&apos;)</span><br><span class="line"></span><br><span class="line"># 对文件重命名:</span><br><span class="line">&gt;&gt;&gt; os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)</span><br><span class="line"># 删掉文件:</span><br><span class="line">&gt;&gt;&gt; os.remove(&apos;test.py&apos;)</span><br></pre></td></tr></table></figure>
<p>shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">列出当前目录下的所有目录</span><br><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)]</span><br><span class="line">[&apos;.lein&apos;, &apos;.local&apos;, &apos;.m2&apos;, &apos;.npm&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;.vim&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, ...]</span><br><span class="line"></span><br><span class="line">[x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;]</span><br><span class="line">[&apos;apis.py&apos;, &apos;config.py&apos;, &apos;models.py&apos;, &apos;pymonitor.py&apos;, &apos;test_db.py&apos;, &apos;urls.py&apos;, &apos;wsgiapp.py&apos;]</span><br></pre></td></tr></table></figure>
<p><strong>读文件</strong></p>
<p>文件的应用级操作可以分为以下 3 步，每一步都需要借助对应的函数实现：</p>
<ol>
<li>打开文件：使用 open() 函数，该函数会返回一个文件对象；</li>
<li>对已打开文件做读/写操作：读取文件内容可使用 read()、readline() 以及 readlines() 函数；向文件中写入内容，可以使用 write() 函数。</li>
<li>关闭文件：完成对文件的读/写操作之后，最后需要关闭文件，可以使用 close() 函数。</li>
</ol>
<p>一个文件，必须在打开之后才能对其进行操作，并且在操作结束之后，还应该将其关闭，这 3 步的顺序不能打乱。</p>
<p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/zzz/test.txt&apos;, &apos;r&apos;)</span><br></pre></td></tr></table></figure>
<p>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&apos;Hello, world!&apos;</span><br></pre></td></tr></table></figure>
<p>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure>
<p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    f = open(&apos;/path/to/file&apos;, &apos;r&apos;)</span><br><span class="line">    print(f.read())</span><br><span class="line">finally:</span><br><span class="line">    if f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>
<p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure>
<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>
<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for line in f.readlines():</span><br><span class="line">    print(line.strip())</span><br></pre></td></tr></table></figure>
<p><strong>写文件</strong></p>
<p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;)</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;Hello, world!&apos;)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure>
<p>你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">    f.write(&apos;Hello, world!&apos;)</span><br></pre></td></tr></table></figure>
<p>要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。</p>
<p>细心的童鞋会发现，以’w’模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入’a’以追加（append）模式写入。</p>
<h4 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h4><p>实现上下文管理是通过<strong>enter</strong>和<strong>exit</strong>这两个方法实现的。例如，下面的class实现了这两个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Query(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        print(&apos;Begin&apos;)</span><br><span class="line">        return self</span><br><span class="line">    </span><br><span class="line">    def __exit__(self, exc_type, exc_value, traceback):</span><br><span class="line">        if exc_type:</span><br><span class="line">            print(&apos;Error&apos;)</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;End&apos;)</span><br><span class="line">    </span><br><span class="line">    def query(self):</span><br><span class="line">        print(&apos;Query info about %s...&apos; % self.name)</span><br></pre></td></tr></table></figure>
<p>这样我们就可以把自己写的资源对象用于with语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with Query(&apos;Bob&apos;) as q:</span><br><span class="line">    q.query()</span><br></pre></td></tr></table></figure>
<p><strong>@contextmanager</strong></p>
<p>编写<strong>enter</strong>和<strong>exit</strong>仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法，上面的代码可以改写如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line">class Query(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def query(self):</span><br><span class="line">        print(&apos;Query info about %s...&apos; % self.name)</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def create_query(name):</span><br><span class="line">    print(&apos;Begin&apos;)</span><br><span class="line">    q = Query(name)</span><br><span class="line">    yield q</span><br><span class="line">    print(&apos;End&apos;)</span><br></pre></td></tr></table></figure>
<p>@contextmanager这个decorator接受一个generator，用yield语句把with … as var把变量输出出去，然后，with语句就可以正常地工作了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with create_query(&apos;Bob&apos;) as q:</span><br><span class="line">    q.query()</span><br></pre></td></tr></table></figure>
<p><strong>@closing</strong></p>
<p>如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from contextlib import closing</span><br><span class="line">from urllib.request import urlopen</span><br><span class="line"></span><br><span class="line">with closing(urlopen(&apos;https://www.python.org&apos;)) as page:</span><br><span class="line">    for line in page:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure>
<p>closing也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@contextmanager</span><br><span class="line">def closing(thing):</span><br><span class="line">    try:</span><br><span class="line">        yield thing</span><br><span class="line">    finally:</span><br><span class="line">        thing.close()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python获取文件路径小结</title>
    <url>/2021/07/07/python%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>业务线最近遇到一个问题，缘由是以下代码导致的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_work_dir():</span><br><span class="line">    work_dir = os.path.split(os.path.realpath(sys.argv[0]))[0]</span><br><span class="line">    sdk = os.path.join(work_dir, &quot;certificate/license-sdk&quot;)</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>
<p>整体来讲，就是在获取当前文件执行路径的时候出了问题。单独运行py文件和用uwsgi运行py文件，及用gunicorn运行py文件，这种方式获取的路径在代码运行的过程中是不一致的。为了验证上述问题，做如下测试：</p>
<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def hello_world():</span><br><span class="line">    print(&quot;------------&quot;)</span><br><span class="line">    print(sys.argv)</span><br><span class="line">    print(os.path.realpath(sys.argv[0]))</span><br><span class="line">    #print(os.getcwd())</span><br><span class="line">    #print(os.path.abspath(&apos;.&apos;))</span><br><span class="line">    print(&quot;------------&quot;)</span><br><span class="line">    return &apos;Hello World!&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<ol>
<li>单独启动flask项目，返回结果如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;/Users/zyy/Downloads/workspace/python3/learn/.venv/lib/python3.6/site-packages/flask/__main__.py&apos;, &apos;run&apos;]</span><br><span class="line">/Users/zyy/Downloads/workspace/python3/learn/.venv/lib/python3.6/site-packages/flask/__main__.py</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过uwsgi启动项目，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsgi --socket 0.0.0.0:5000 --protocol=http -p 1  --set foo=bar -w run:app</span><br><span class="line"></span><br><span class="line">返回结果如下：</span><br><span class="line"></span><br><span class="line">[&apos;uwsgi&apos;]</span><br><span class="line">/Users/zyy/Downloads/workspace/python3/learn/uwsgi</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>通过gunicorn启动项目</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunicorn -w 1 -b 127.0.0.1:5000 run:app</span><br><span class="line"></span><br><span class="line">返回结果如下：</span><br><span class="line"></span><br><span class="line">[&apos;/Users/zyy/Downloads/workspace/python3/learn/.venv/bin/gunicorn&apos;, &apos;-w&apos;, &apos;1&apos;, &apos;-b&apos;, &apos;127.0.0.1:5000&apos;, &apos;run:app&apos;]</span><br><span class="line">/Users/zyy/Downloads/workspace/python3/learn/.venv/bin/gunicorn</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>小结</li>
</ol>
<p>对比来看，三种方式启动后获取的文件路径都不一样，所以当通过uwsgi替换为gunicorn的时候，上述代码会出现问题。为了避免出现问题，可以通过其他方式来获取当前项目的执行路径。比如可以通过以下方式来获取项目执行路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure>
<h4 id="获取当前路径"><a href="#获取当前路径" class="headerlink" title="获取当前路径"></a>获取当前路径</h4><ol>
<li>使用sys.argv[0]</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">print sys.argv[0]</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>os模块</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(os.getcwd()) #获取当前工作目录路径</span><br><span class="line">print(os.path.abspath(&apos;.&apos;)) #获取当前工作目录路径</span><br><span class="line">print(os.path.abspath(&apos;test.txt&apos;)) #获取当前目录文件下的工作目录路径</span><br><span class="line">print(os.path.abspath(&apos;..&apos;)) #获取当前工作的父目录 ！注意是父目录路径</span><br><span class="line">print(os.path.abspath(os.curdir)) #获取当前工作目录路径</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>改变当前路径</li>
</ol>
<p>使用: os.chdir(path)</p>
<p>比如, 如果当前目录在 ‘E:’ 下面， 然后进入E 下面的files 文件 可以使用 os.chdir(E:\files).之后，使用比如 test1 = open(‘file1.txt’),  打开的文件会是在这个 ‘E:\files’ 目录下的文件，而不是 ‘E’ 下的文件。</p>
<ol start="4">
<li>组合路径返回</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">os.path.join(&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;)</span><br></pre></td></tr></table></figure>
<p>合并得到路径 file1/file2/file3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print os.path.join(&apos;E:&apos;, &apos;file1&apos;, &apos;file2&apos;)</span><br><span class="line">E:/file1/file2</span><br><span class="line">&gt;&gt;&gt; print os.path.join(&apos;/home&apos;, &apos;/home/file1/&apos;, &apos;/home/file1/file2/&apos;)</span><br><span class="line">/home/file1/file2/</span><br></pre></td></tr></table></figure>
<h4 id="获得当前目录下所有文件"><a href="#获得当前目录下所有文件" class="headerlink" title="获得当前目录下所有文件"></a>获得当前目录下所有文件</h4><p>os.walk() 用于在目录树种游走输出目录中的文件名字，向上或下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">top -- 根目录下的每一个文件夹(包含它自己), 产生3-元组 (dirpath, dirnames, filenames)【文件夹路径, </span><br><span class="line">       文件夹名字, 文件名】。</span><br><span class="line"></span><br><span class="line">topdown --可选，为True或者没有指定, 一个目录的的3-元组将比它的任何子文件夹的3-元组先产生 (目录自上而下)。</span><br><span class="line">          如果topdown为 False, 一个目录的3-元组将比它的任何子文件夹的3-元组后产生 (目录自下而上)。</span><br><span class="line"></span><br><span class="line">onerror -- 可选，是一个函数; 它调用时有一个参数, 一个OSError实例。报告这错误后，继续walk,或者抛出exception终止walk。</span><br><span class="line"></span><br><span class="line">followlinks -- 设置为 true，则通过软链接访问目录。</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def file_name(file_dir):</span><br><span class="line">    for root, dirs, files in os.walk(file_dir):</span><br><span class="line">        print(&quot;-----------&quot;)</span><br><span class="line">        print(root)  # os.walk()所在目录</span><br><span class="line">        print(dirs)  # os.walk()所在目录的所有目录名</span><br><span class="line">        print(files)  # os.walk()所在目录的所有非目录文件名</span><br><span class="line">        print(&quot; &quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python闭包和装饰器小结</title>
    <url>/2021/04/21/python%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h4 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h4><p>装饰器（Decorator）相对简单，咱们先介绍它：“装饰器的功能是将被装饰的函数当作参数传递给与装饰器对应的函数（名称相同的函数），并返回包装后的被装饰的函数”，听起来有点绕，没关系，直接看示意图,其中 a 为与装饰器 @a 对应的函数， b 为装饰器修饰的函数，装饰器@a的作用是：</p>
<p>简而言之：@a 就是将 b 传递给 a()，并返回新的 b = a(b)</p>
<h4 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h4><p>在通过Python的语言介绍一下，一个闭包就是你调用了一个函数A，这个函数A返回了一个函数B给你。这个返回的函数B就叫做闭包。你在调用函数A的时候传递的参数就是自由变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func(name):</span><br><span class="line">    def inner_func(age):</span><br><span class="line">        print &apos;name:&apos;, name, &apos;age:&apos;, age</span><br><span class="line">    return inner_func</span><br><span class="line"></span><br><span class="line">bb = func(&apos;the5fire&apos;)bb(26) # &gt;&gt;&gt; name: the5fire age: 26</span><br></pre></td></tr></table></figure>
<p>这里面调用func的时候就产生了一个闭包——inner_func,并且该闭包持有自由变量——name，因此这也意味着，当函数func的生命周期结束之后，name这个变量依然存在，因为它被闭包引用了，所以不会被回收。</p>
<p>另外再说一点，闭包并不是Python中特有的概念，所有把函数做为一等公民的语言均有闭包的概念。不过像Java这样以class为一等公民的语言中也可以使用闭包，只是它得用类或接口来实现。</p>
<h4 id="nonlocal-语句"><a href="#nonlocal-语句" class="headerlink" title="nonlocal 语句"></a>nonlocal 语句</h4><p>在 python 的函数内，可以直接引用外部变量，但不能改写外部变量，因此如果在闭包中直接改写父函数的变量，就会发生错误：</p>
<p>在 python 2 中可以在函数内使用 global 语句，但全局变量在任何语言中都不被提倡，因为它很难控制，python 3 中引入了 nonlocal 语句解决了这个问题：</p>
<p>Nonlocal 与 global 的区别在于 nonlocal 语句会去搜寻本地变量与全局变量之间的变量，其会优先寻找层级关系与闭包作用域最近的外部变量。</p>
<h4 id="闭包与装饰器"><a href="#闭包与装饰器" class="headerlink" title="闭包与装饰器"></a>闭包与装饰器</h4><p>上面已经简单演示了装饰器的功能，事实上，装饰器就是一种的闭包的应用，只不过其传递的是函数：</p>
<p>@makeitalic 装饰器将函数 hello 传递给函数 makeitalic，函数 makeitalic 执行完毕后返回被包装后的 hello 函数，而这个过程其实就是通过闭包实现的。@makebold 也是如此，只不过其传递的是 @makeitalic 装饰过的 hello 函数，因此最后的执行结果<b> 在 <i> 外层，这个功能如果不用装饰器，其实就是显式的使用闭包：</i></b></p>
<h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><p>闭包的最大特点是可以将父函数的变量与内部函数绑定，并返回绑定变量后的函数（也即闭包），此时即便生成闭包的环境（父函数）已经释放，闭包仍然存在，这个过程很像类（父函数）生成实例（闭包），不同的是父函数只在调用时执行，执行完毕后其环境就会释放，而类则在文件执行时创建，一般程序执行完毕后作用域才释放，因此对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，且更轻巧灵活，现举一例：假设我们仅仅想打印出各类动物的叫声，分别以类和闭包来实现：</p>
<p>可以看到输出结果是完全一样的，但显然类的实现相对繁琐，且这里只是想输出一下动物的叫声，定义一个 Animal 类未免小题大做，而且 voice 函数在执行完毕后，其作用域就已经释放，但 Animal 类及其实例 dog 的相应属性却一直贮存在内存中：</p>
<p>而这种占用对于实现该功能后，则是没有必要的。除此之外，闭包还有很多其他功能，比如用于封装等，另外，闭包有效的减少了函数参数的数目，这对并行计算非常有价值，比如可以让每台电脑负责一个函数，然后串起来，实现流水化的作业等。</p>
<h4 id="装饰器常用写法"><a href="#装饰器常用写法" class="headerlink" title="装饰器常用写法"></a>装饰器常用写法</h4><ol>
<li>普通装饰器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def decorator(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        return func()</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@decorator</span><br><span class="line">def function():</span><br><span class="line">    print(&quot;hello, decorator&quot;)</span><br></pre></td></tr></table></figure>
<p>时间计算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def timer(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        t1=time.time()</span><br><span class="line">        # 这是函数真正执行的地方</span><br><span class="line">        func(*args, **kw)</span><br><span class="line">        t2=time.time()</span><br><span class="line"></span><br><span class="line">        # 计算下时长</span><br><span class="line">        cost_time = t2-t1 </span><br><span class="line">        print(&quot;花费时间：&#123;&#125;秒&quot;.format(cost_time))</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>带参数的装饰器</li>
</ol>
<blockquote>
<p>装饰器本身是一个函数，做为一个函数，如果不能传参，那这个函数的功能就会很受限，只能执行固定的逻辑。这意味着，如果装饰器的逻辑代码的执行需要根据不同场景进行调整，若不能传参的话，我们就要写两个装饰器，这显然是不合理的。比如我们要实现一个可以定时发送邮件的任务（一分钟发送一封），定时进行时间同步的任务（一天同步一次），就可以自己实现一个periodic_task （定时任务）的装饰器，这个装饰器可以接收一个时间间隔的参数，间隔多长时间执行一次任务。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@periodic_task(spacing=60)</span><br><span class="line">def send_mail():</span><br><span class="line">     pass</span><br><span class="line"></span><br><span class="line">@periodic_task(spacing=86400)</span><br><span class="line">def ntp()</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def say_hello(contry):</span><br><span class="line">    def wrapper(func):</span><br><span class="line">        def deco(*args, **kwargs):</span><br><span class="line">            if contry == &quot;china&quot;:</span><br><span class="line">                print(&quot;你好!&quot;)</span><br><span class="line">            elif contry == &quot;america&quot;:</span><br><span class="line">                print(&apos;hello.&apos;)</span><br><span class="line">            else:</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            # 真正执行函数的地方</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        return deco</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>不带参数的类装饰器</li>
</ol>
<p>基于类装饰器的实现，必须实现 call 和 <strong>init</strong>两个内置函数。 init ：接收被装饰函数 call 实现装饰逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class logger(object):</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&quot;[INFO]: the function &#123;func&#125;() is running...&quot;\</span><br><span class="line">            .format(func=self.func.__name__))</span><br><span class="line">        return self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">@logger</span><br><span class="line">def say(something):</span><br><span class="line">    print(&quot;say &#123;&#125;!&quot;.format(something))</span><br><span class="line"></span><br><span class="line">say(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>带参数的类装饰器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class logger(object):</span><br><span class="line">    def __init__(self, level=&apos;INFO&apos;):</span><br><span class="line">        self.level = level</span><br><span class="line"></span><br><span class="line">    def __call__(self, func): # 接受函数</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            print(&quot;[&#123;level&#125;]: the function &#123;func&#125;() is running...&quot;\</span><br><span class="line">                .format(level=self.level, func=func.__name__))</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        return wrapper  #返回函数</span><br><span class="line"></span><br><span class="line">@logger(level=&apos;WARNING&apos;)</span><br><span class="line">def say(something):</span><br><span class="line">    print(&quot;say &#123;&#125;!&quot;.format(something))</span><br><span class="line"></span><br><span class="line">say(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>使用偏函数与类实现装饰器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import functools</span><br><span class="line"></span><br><span class="line">class DelayFunc:</span><br><span class="line">    def __init__(self,  duration, func):</span><br><span class="line">        self.duration = duration</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(f&apos;Wait for &#123;self.duration&#125; seconds...&apos;)</span><br><span class="line">        time.sleep(self.duration)</span><br><span class="line">        return self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def eager_call(self, *args, **kwargs):</span><br><span class="line">        print(&apos;Call without delay&apos;)</span><br><span class="line">        return self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">def delay(duration):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    装饰器：推迟某个函数的执行。</span><br><span class="line">    同时提供 .eager_call 方法立即执行</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 此处为了避免定义额外函数，</span><br><span class="line">    # 直接使用 functools.partial 帮助构造 DelayFunc 实例</span><br><span class="line">    return functools.partial(DelayFunc, duration)</span><br><span class="line"></span><br><span class="line">我们的业务函数很简单，就是相加</span><br><span class="line"></span><br><span class="line">@delay(duration=2)</span><br><span class="line">def add(a, b):</span><br><span class="line">    return a+b</span><br></pre></td></tr></table></figure>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://www.cnblogs.com/l520/p/10254784.html" target="_blank" rel="noopener">https://www.cnblogs.com/l520/p/10254784.html</a></li>
<li><a href="https://www.cnblogs.com/3me-linux/p/6761635.html" target="_blank" rel="noopener">https://www.cnblogs.com/3me-linux/p/6761635.html</a> </li>
<li><a href="https://blog.csdn.net/weixin_46457946/article/details/111939076" target="_blank" rel="noopener">https://blog.csdn.net/weixin_46457946/article/details/111939076</a></li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>redis实现分布式锁</title>
    <url>/2019/04/04/redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p>分布式应用进行逻辑处理时经常会遇到并发问题。<br>比如一个操作要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修改，改完了再存回去。如果这样的操作同时进行了，就会出现并发问题，因为读取和保存状态这两个操作不是原子的。（Wiki 解释：所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch 线程切换。）<br>分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。</p>
<h4 id="安全和可靠性保证"><a href="#安全和可靠性保证" class="headerlink" title="安全和可靠性保证"></a>安全和可靠性保证</h4><h5 id="互斥性"><a href="#互斥性" class="headerlink" title="互斥性"></a>互斥性</h5><p>保证同一时间只有一个客户端可以拿到锁，也就是可以对共享资源进行操作</p>
<h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>只有加锁的服务才能有解锁权限，也就是不能让a加的锁，bcd都可以解锁，如果都能解锁那分布式锁就没啥意义了<br>可能出现的情况就是a去查询发现持有锁，就在准备解锁，这时候忽然a持有的锁过期了，然后b去获得锁，因为a锁过期，b拿到锁，这时候a继续执行第二步进行解锁如果不加校验，就将b持有的锁就给删除了</p>
<h5 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h5><p>出现死锁就会导致后续的任何服务都拿不到锁,不能再对共享资源进行任何操作了</p>
<h5 id="保证加锁与解锁操作是原子性操作"><a href="#保证加锁与解锁操作是原子性操作" class="headerlink" title="保证加锁与解锁操作是原子性操作"></a>保证加锁与解锁操作是原子性操作</h5><p>这个其实属于是实现分布式锁的问题，假设a用redis实现分布式锁<br>假设加锁操作，操作步骤分为两步：<br>1，设置key set（key，value）2，给key设置过期时间<br>假设现在a刚实现set后，程序崩了就导致了没给key设置过期时间就导致key一直存在就发生了死锁</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>使用redis命令 set key value NX EX max-lock-time 实现加锁<br>使用redis命令 EVAL 实现解锁<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#java代码</span><br><span class="line">public class RedisDistributeLock &#123;</span><br><span class="line"></span><br><span class="line">    private Jedis jedis;</span><br><span class="line"></span><br><span class="line">    private static final String LOCK_SUCCESS = &quot;OK&quot;;</span><br><span class="line"></span><br><span class="line">    private static final Long UNLOCK_SUCCESS = 1L;</span><br><span class="line"></span><br><span class="line">    public Boolean lock(String key,String value,Long timeout)&#123;</span><br><span class="line">        String result = jedis.set(key,value,&quot;NX&quot;,&quot;EX&quot;,timeout);</span><br><span class="line">        if(LOCK_SUCCESS.equals(result))&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boolean unlock(String key,String value)&#123;</span><br><span class="line">        String luaScript = &quot;if redis.call(\&quot;get\&quot;,KEYS[1]) == ARGV[1] then return redis.call(\&quot;del\&quot;,KEYS[1]) else  return 0 end&quot;;</span><br><span class="line">        Object result = jedis.eval(luaScript, Collections.singletonList(key),Collections.singletonList(value));</span><br><span class="line">        if (UNLOCK_SUCCESS == result)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boolean lockRetry(String key,String value,Long timeout,Integer retryTime,Long sleepTime)&#123;</span><br><span class="line">        Boolean flag = false;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            for(int i=0;i&lt;retryTime;i++)&#123;</span><br><span class="line">                flag = lock(key,value,timeout);</span><br><span class="line">                if(flag)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(sleepTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>go版本代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;github.com/garyburd/redigo/redis&quot;</span><br><span class="line">	&quot;crypto/rand&quot;</span><br><span class="line">	&quot;encoding/base64&quot;</span><br><span class="line">	&quot;errors&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type RedisLock struct &#123;</span><br><span class="line">	lockKey string</span><br><span class="line">	value string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Redispool *redis.Pool</span><br><span class="line"></span><br><span class="line">var delScript = redis.NewScript(1, `</span><br><span class="line">if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="line">	return redis.call(&quot;del&quot;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">	return 0</span><br><span class="line">end`)</span><br><span class="line"></span><br><span class="line">func init()  &#123;</span><br><span class="line">	Redispool = &amp;redis.Pool&#123;</span><br><span class="line">		MaxIdle:     10,</span><br><span class="line">		IdleTimeout: 300 * time.Second,</span><br><span class="line">		Dial : func() (redis.Conn, error) &#123;</span><br><span class="line">			tcp := fmt.Sprintf(&quot;%s:%s&quot;,&quot;127.0.0.1&quot;,&quot;6379&quot;)</span><br><span class="line">			c,err := redis.Dial(&quot;tcp&quot;,tcp)</span><br><span class="line">			if err != nil&#123;</span><br><span class="line">				return nil,err</span><br><span class="line">			&#125;</span><br><span class="line">			return c,err</span><br><span class="line">		&#125;,</span><br><span class="line">		TestOnBorrow : func(c redis.Conn, t time.Time) error &#123;</span><br><span class="line">			_,err := c.Do(&quot;PING&quot;)</span><br><span class="line">			return  err</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(this *RedisLock) Lock(rd *redis.Conn,timeout int)error&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		b := make([]byte,16)</span><br><span class="line">		_,err := rand.Read(b)</span><br><span class="line">		if err !=nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">		this.value = base64.StdEncoding.EncodeToString(b)</span><br><span class="line">		lockReply,err := (*rd).Do(&quot;SET&quot;,this.lockKey,this.value,&quot;ex&quot;,timeout,&quot;nx&quot;)</span><br><span class="line">		if err !=nil&#123;</span><br><span class="line">			return errors.New(&quot;redis fail&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">		if lockReply == &quot;OK&quot;&#123;</span><br><span class="line">			return nil</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return errors.New(&quot;lock fail&quot;)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(this *RedisLock)Unlock(rd *redis.Conn)&#123;</span><br><span class="line">	delScript.Do(*rd,this.lockKey,this.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">	rd := Redispool.Get()</span><br><span class="line">	defer rd.Close()</span><br><span class="line"></span><br><span class="line">	var channel chan bool</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		lock1 :=RedisLock&#123;&quot;lockKey&quot;,&quot;**1**&quot;&#125;</span><br><span class="line">		err := lock1.Lock(&amp;rd,5)</span><br><span class="line">		time.Sleep(2*time.Second)</span><br><span class="line">		lock2 := RedisLock&#123;&quot;lockKey&quot;,&quot;**2**&quot;&#125;</span><br><span class="line">		err1 := lock2.Lock(&amp;rd,5)</span><br><span class="line">		fmt.Println(err,err1)</span><br><span class="line">		lock1.Unlock(&amp;rd)</span><br><span class="line">		channel &lt;- true</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	 if &lt;-channel &#123;</span><br><span class="line">	 	fmt.Println(&quot;结束&quot;)</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>redis问题小结</title>
    <url>/2021/05/28/redis%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h4 id="Redis的过期策略"><a href="#Redis的过期策略" class="headerlink" title="Redis的过期策略"></a>Redis的过期策略</h4><p>redis主要有2种过期删除策略</p>
<p><strong>惰性删除</strong></p>
<p>惰性删除指的是当我们查询key的时候才对key进⾏检测，如果已经达到过期时间，则删除。显然，他有⼀个缺点就是如果这些过期的key没有被访问，那么他就⼀直⽆法被删除，⽽且⼀直占⽤内存。</p>
<p><img src="/2021/05/28/redis问题小结/redis01.png" alt="avatar"></p>
<p><strong>定期删除</strong></p>
<p>定期删除指的是redis每隔⼀段时间对数据库做⼀次检查，删除⾥⾯的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取⼀些key去做检查和删除。</p>
<p><strong>那么定期+惰性都没有删除过期的key怎么办？</strong></p>
<p>假设redis每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key⼀直保存在redis⾥⾯⽆法被删除，这时候就会⾛到redis的内存淘汰机制。</p>
<ol>
<li>volatile-lru：从已设置过期时间的key中，移出最近最少使⽤的key进⾏淘汰</li>
<li>volatile-ttl：从已设置过期时间的key中，移出将要过期的key</li>
<li>volatile-random：从已设置过期时间的key中随机选择key淘汰</li>
<li>allkeys-lru：从key中选择最近最少使⽤的进⾏淘汰</li>
<li>allkeys-random：从key中随机选择key进⾏淘汰</li>
<li>noeviction：当内存达到阈值的时候，新写⼊操作报错</li>
</ol>
<h4 id="Redis事务机制"><a href="#Redis事务机制" class="headerlink" title="Redis事务机制"></a>Redis事务机制</h4><p>redis通过MULTI、EXEC、WATCH等命令来实现事务机制，事务执⾏过程将⼀系列多个命令按照顺序⼀次性执⾏，并且在执⾏期间，事务不会被中断，也不会去执⾏客户端的其他请求，直到所有命令执⾏完毕。事务的执⾏过程如下：</p>
<ol>
<li>服务端收到客户端请求，事务以MULTI开始</li>
<li>如果客户端正处于事务状态，则会把事务放⼊队列同时返回给客户端QUEUED，反之则直接执⾏这个命令</li>
<li>当收到客户端EXEC命令时，WATCH命令监视整个事务中的key是否有被修改，如果有则返回空回复到客户端表示失败，否则redis会遍历整个事务队列，执⾏队列中保存的所有命令，最后返回结果给客户端</li>
</ol>
<p>WATCH的机制本身是⼀个CAS的机制，被监视的key会被保存到⼀个链表中，如果某个key被修改，那么REDIS_DIRTY_CAS标志将会被打开，这时服务器会拒绝执⾏事务。</p>
<h4 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h4><p><strong>主从架构</strong></p>
<p>主从模式是最简单的实现⾼可⽤的⽅案，核⼼就是主从同步。主从同步的原理如下：</p>
<ol>
<li>slave发送sync命令到master</li>
<li>master收到sync之后，执⾏bgsave，⽣成RDB全量⽂件</li>
<li>master把slave的写命令记录到缓存</li>
<li>bgsave执⾏完毕之后，发送RDB⽂件到slave，slave执⾏</li>
<li>master发送缓存中的写命令到slave，slave执⾏</li>
</ol>
<p><img src="/2021/05/28/redis问题小结/redis02.png" alt="avatar"></p>
<p>这⾥我写的这个命令是sync，但是在redis2.8版本之后已经使⽤psync来替代sync了，原因是sync命令⾮常消耗系统资源，⽽psync的效率更⾼。</p>
<p><strong>哨兵</strong></p>
<p>基于主从⽅案的缺点还是很明显的，假设master宕机，那么就不能写⼊数据，那么slave也就失去了作⽤，整个架构就不可⽤了，除⾮你⼿动切换，主要原因就是因为没有⾃动故障转移机制。⽽哨兵(sentinel)的功能⽐单纯的主从架构全⾯的多了，它具备⾃动故障转移、集群监控、消息通知等功能。</p>
<p><img src="/2021/05/28/redis问题小结/redis03.png" alt="avatar"></p>
<p>哨兵可以同时监视多个主从服务器，并且在被监视的master下线时，⾃动将某个slave提升为master，</p>
<p>然后由新的master继续接收命令。整个过程如下：</p>
<ol>
<li>初始化sentinel，将普通的redis代码替换成sentinel专⽤代码</li>
<li>初始化masters字典和服务器信息，服务器信息主要保存ip:port，并记录实例的地址和ID</li>
<li>创建和master的两个连接，命令连接和订阅连接，并且订阅sentinel:hello频道</li>
<li>每隔10秒向master发送info命令，获取master和它下⾯所有slave的当前信息</li>
<li>当发现master有新的slave之后，sentinel和新的slave同样建⽴两个连接，同时每个10秒发送info命令，更新master信息</li>
<li>sentinel每隔1秒向所有服务器发送ping命令，如果某台服务器在配置的响应时间内连续返回⽆效回复，将会被标记为下线状态</li>
<li>选举出领头sentinel，领头sentinel需要半数以上的sentinel同意</li>
<li>领头sentinel从已下线的的master所有slave中挑选⼀个，将其转换为master</li>
<li>让所有的slave改为从新的master复制数据</li>
<li>将原来的master设置为新的master的从服务器，当原来master重新回复连接时，就变成了新master的从服务器</li>
</ol>
<p>sentinel会每隔1秒向所有实例（包括主从服务器和其他sentinel）发送ping命令，并且根据回复判断是否已经下线，这种⽅式叫做主观下线。当判断为主观下线时，就会向其他监视的sentinel询问，如果超过半数的投票认为已经是下线状态，则会标记为客观下线状态，同时触发故障转移。</p>
<h4 id="redis-分片"><a href="#redis-分片" class="headerlink" title="redis 分片"></a>redis 分片</h4><p><strong>节点</strong></p>
<p>⼀个redis集群由多个节点node组成，⽽多个node之间通过cluster meet命令来进⾏连接，节点的握⼿<br>过程：</p>
<ol>
<li>节点A收到客户端的cluster meet命令</li>
<li>A根据收到的IP地址和端⼝号，向B发送⼀条meet消息</li>
<li>节点B收到meet消息返回pong</li>
<li>A知道B收到了meet消息，返回⼀条ping消息，握⼿成功</li>
<li>最后，节点A将会通过gossip协议把节点B的信息传播给集群中的其他节点，其他节点也将和B进⾏握⼿</li>
</ol>
<p><img src="/2021/05/28/redis问题小结/redis04.png" alt="avatar"></p>
<p><strong>槽slot</strong></p>
<p>redis通过集群分⽚的形式来保存数据，整个集群数据库被分为16384个slot，集群中的每个节点可以处理0-16384个slot，当数据库16384个slot都有节点在处理时，集群处于上线状态，反之只要有⼀个slot没有得到处理都会处理下线状态。通过cluster addslots命令可以将slot指派给对应节点处理。<br>slot是⼀个位数组，数组的⻓度是16384/8=2048，⽽数组的每⼀位⽤1表示被节点处理，0表示不处理，如图所示的话表示A节点处理0-7的slot。</p>
<p><img src="/2021/05/28/redis问题小结/redis05.png" alt="avatar"></p>
<p>当客户端向节点发送命令，如果刚好找到slot属于当前节点，那么节点就执⾏命令，反之，则会返回⼀个MOVED命令到客户端指引客户端转向正确的节点。（MOVED过程是⾃动的）</p>
<p><img src="/2021/05/28/redis问题小结/redis06.png" alt="avatar"></p>
<p>如果增加或者移出节点，对于slot的重新分配也是⾮常⽅便的，redis提供了⼯具帮助实现slot的迁移，整个过程是完全在线的，不需要停⽌服务。</p>
<p><strong>故障转移</strong></p>
<p>如果节点A向节点B发送ping消息，节点B没有在规定的时间内响应pong，那么节点A会标记节点B为pfail疑似下线状态，同时把B的状态通过消息的形式发送给其他节点，如果超过半数以上的节点都标记B为pfail状态，B就会被标记为fail下线状态，此时将会发⽣故障转移，优先从复制数据较多的从节点选择⼀个成为主节点，并且接管下线节点的slot，整个过程和哨兵⾮常类似，都是基于Raft协议做选举。</p>
]]></content>
      <tags>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>reversed函数</title>
    <url>/2021/02/01/reversed%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="reversed-函数"><a href="#reversed-函数" class="headerlink" title="reversed 函数"></a>reversed 函数</h3><p>描述：</p>
<p>reversed()函数是python中极其常用的函数（我上回面试还被问到了）。reversed()函数的作用是返回一个反转的迭代器（元组、列表、字符串、range）。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reversed(seq)</span><br></pre></td></tr></table></figure>
<p>参数介绍： </p>
<p>seq — 需要转换的序列，如元组、列表、字符串、range</p>
<p>返回值：</p>
<p>返回反转的迭代器</p>
<p>下面例子展示reversed()函数使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">seqTuple = (&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;) # 元组</span><br><span class="line">print(list(reversed(seqTuple)))</span><br><span class="line">seqList = [7, 8, 4, 5, 6]  # 列表</span><br><span class="line">print(list(reversed(seqList)))</span><br><span class="line">seqString = &apos;HelloWorld&apos; # 字符串</span><br><span class="line">print(list(reversed(seqString)))</span><br><span class="line">seqRange = range(1, 8)    # range</span><br><span class="line">print(list(reversed(seqRange)))</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;o&apos;, &apos;l&apos;, &apos;l&apos;, &apos;e&apos;, &apos;H&apos;]</span><br><span class="line">[6, 5, 4, 8, 7]</span><br><span class="line">[&apos;d&apos;, &apos;l&apos;, &apos;r&apos;, &apos;o&apos;, &apos;W&apos;, &apos;o&apos;, &apos;l&apos;, &apos;l&apos;, &apos;e&apos;, &apos;H&apos;]</span><br><span class="line">[7, 6, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>
<h3 id="zip-函数"><a href="#zip-函数" class="headerlink" title="zip() 函数"></a>zip() 函数</h3><p>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</p>
<p>语法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip([iterable, ...])</span><br></pre></td></tr></table></figure></p>
<p>实例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b = [4,5,6]</span><br><span class="line">&gt;&gt;&gt; c = [4,5,6,7,8]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(a,c)              # 元素个数与最短的列表一致</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span><br><span class="line">[(1, 2, 3), (4, 5, 6)]</span><br></pre></td></tr></table></figure></p>
<h3 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h3><p>sorted() 函数对所有可迭代的对象进行排序操作。</p>
<p>sort 与 sorted 区别：sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sorted(iterable, cmp=None, key=None, reverse=False)</span><br><span class="line"></span><br><span class="line">iterable -- 可迭代对象。</span><br><span class="line">cmp -- 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。</span><br><span class="line">key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</span><br><span class="line">reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [5,7,6,3,4,1,2]</span><br><span class="line">&gt;&gt;&gt; b = sorted(a)       # 保留原列表</span><br><span class="line">&gt;&gt;&gt; a </span><br><span class="line">[5, 7, 6, 3, 4, 1, 2]</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L=[(&apos;b&apos;,2),(&apos;a&apos;,1),(&apos;c&apos;,3),(&apos;d&apos;,4)]</span><br><span class="line">&gt;&gt;&gt; sorted(L, cmp=lambda x,y:cmp(x[1],y[1]))   # 利用cmp函数</span><br><span class="line">[(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3), (&apos;d&apos;, 4)]</span><br><span class="line">&gt;&gt;&gt; sorted(L, key=lambda x:x[1])               # 利用key</span><br><span class="line">[(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3), (&apos;d&apos;, 4)]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; students = [(&apos;john&apos;, &apos;A&apos;, 15), (&apos;jane&apos;, &apos;B&apos;, 12), (&apos;dave&apos;, &apos;B&apos;, 10)]</span><br><span class="line">&gt;&gt;&gt; sorted(students, key=lambda s: s[2])            # 按年龄排序</span><br><span class="line">[(&apos;dave&apos;, &apos;B&apos;, 10), (&apos;jane&apos;, &apos;B&apos;, 12), (&apos;john&apos;, &apos;A&apos;, 15)]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; sorted(students, key=lambda s: s[2], reverse=True)       # 按降序</span><br><span class="line">[(&apos;john&apos;, &apos;A&apos;, 15), (&apos;jane&apos;, &apos;B&apos;, 12), (&apos;dave&apos;, &apos;B&apos;, 10)]</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlarchemy和flask_sqlalchemy使用区别</title>
    <url>/2021/04/14/sqlarchemy%E5%92%8Cflask-sqlalchemy%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="使用-flask-sqlalchemy"><a href="#使用-flask-sqlalchemy" class="headerlink" title="使用 flask_sqlalchemy"></a>使用 flask_sqlalchemy</h3><p>常见情况下对于只有一个 Flask 应用，所有您需要做的事情就是创建 Flask 应用，选择加载配置接着创建 SQLAlchemy 对象时候把 Flask 应用传递给它作为参数。</p>
<p>一旦创建，这个对象就包含 sqlalchemy 和 sqlalchemy.orm 中的所有函数和助手。此外它还提供一个名为 Model 的类，用于作为声明模型时的 delarative 基类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask.ext.sqlalchemy import SQLAlchemy</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = &apos;sqlite:////tmp/test.db&apos;</span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class User(db.Model):</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    username = db.Column(db.String(80), unique=True)</span><br><span class="line">    email = db.Column(db.String(120), unique=True)</span><br><span class="line"></span><br><span class="line">    def __init__(self, username, email):</span><br><span class="line">        self.username = username</span><br><span class="line">        self.email = email</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;&lt;User %r&gt;&apos; % self.username</span><br></pre></td></tr></table></figure>
<h3 id="使用-SQLAlchemy"><a href="#使用-SQLAlchemy" class="headerlink" title="使用 SQLAlchemy"></a>使用 SQLAlchemy</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入:</span><br><span class="line">from sqlalchemy import Column, String, create_engine</span><br><span class="line">from sqlalchemy.orm import sessionmaker</span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line"></span><br><span class="line"># 创建对象的基类:</span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"># 定义User对象:</span><br><span class="line">class User(Base):</span><br><span class="line">    # 表的名字:</span><br><span class="line">    __tablename__ = &apos;user&apos;</span><br><span class="line"></span><br><span class="line">    # 表的结构:</span><br><span class="line">    id = Column(String(20), primary_key=True)</span><br><span class="line">    name = Column(String(20))</span><br><span class="line"></span><br><span class="line"># 初始化数据库连接:</span><br><span class="line">engine = create_engine(&apos;mysql+mysqlconnector://root:password@localhost:3306/test&apos;)</span><br><span class="line"># 创建DBSession类型:</span><br><span class="line">DBSession = sessionmaker(bind=engine)</span><br><span class="line"></span><br><span class="line"># 创建session对象:</span><br><span class="line">session = DBSession()</span><br><span class="line"># 创建新User对象:</span><br><span class="line">new_user = User(id=&apos;5&apos;, name=&apos;Bob&apos;)</span><br><span class="line"># 添加到session:</span><br><span class="line">session.add(new_user)</span><br><span class="line"># 提交即保存到数据库:</span><br><span class="line">session.commit()</span><br><span class="line"># 关闭session:</span><br><span class="line">session.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建Session:</span><br><span class="line">session = DBSession()</span><br><span class="line"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:</span><br><span class="line">user = session.query(User).filter(User.id==&apos;5&apos;).one()</span><br><span class="line"># 打印类型和对象的name属性:</span><br><span class="line">print(&apos;type:&apos;, type(user))</span><br><span class="line">print(&apos;name:&apos;, user.name)</span><br><span class="line"># 关闭Session:</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure>
<h3 id="flask-sqlalchemy和sqlalchemy联系区别及其使用方式"><a href="#flask-sqlalchemy和sqlalchemy联系区别及其使用方式" class="headerlink" title="flask_sqlalchemy和sqlalchemy联系区别及其使用方式"></a>flask_sqlalchemy和sqlalchemy联系区别及其使用方式</h3><p><strong>使用SQLAlchemy去连接数据库：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.使用SQLALchemy去连接数据库，需要使用一些配置信息，然后将他们组合成满足条件的字符串：</span><br><span class="line">HOSTNAME = &apos;127.0.0.1&apos;</span><br><span class="line">PORT = &apos;3306&apos;</span><br><span class="line">DATABASE = &apos;1&apos;</span><br><span class="line">USERNAME = &apos;root&apos;</span><br><span class="line">PASSWORD = &apos;root&apos;</span><br><span class="line"></span><br><span class="line">DB_URI = &quot;mysql+mysqlconnector://&#123;username&#125;:&#123;password&#125;@&#123;host&#125;:&#123;port&#125;/&#123;db&#125;?charset=utf8&quot;.format(username=USERNAME,password=PASSWORD,host=HOSTNAME,port=PORT,db=DATABASE)</span><br><span class="line"></span><br><span class="line">2.然后使用`create_engine`创建一个引擎`engine`，</span><br><span class="line">engine = create_engine(DB_URI)</span><br><span class="line"></span><br><span class="line">3.构建session对象：所有和数据库的ORM操作都必须通过一个叫做`session`的会话对象来实现，通过以下代码来获取会话对象：</span><br><span class="line">from sqlalchemy.orm import sessionmaker</span><br><span class="line"></span><br><span class="line">engine = create_engine(DB_URI)</span><br><span class="line">session = sessionmaker(engine)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.将ORM模型映射到数据库中：</span><br><span class="line">(1)用`declarative_base`根据`engine`创建一个ORM基类。</span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line"></span><br><span class="line">engine = create_engine(DB_URI)</span><br><span class="line">Base = declarative_base(engine)</span><br><span class="line">(2)用这个`Base`类作为基类来写自己的ORM类。要定义`__tablename__`类属性，来指定这个模型映射到数据库中的表名。</span><br><span class="line">class Person(Base):</span><br><span class="line">    __tablename__ = &apos;person&apos;</span><br><span class="line">(3)在这个ORM模型中创建一些属性，来跟表中的字段进行一一映射。这些属性必须是sqlalchemy给我们提供好的数据类型。</span><br><span class="line">from sqlalchemy import create_engine,Column,Integer,String</span><br><span class="line"></span><br><span class="line">id = Column(Integer,primary_key=True,autoincrement=True)</span><br><span class="line">(4)使用`Base.metadata.create_all()`来将模型映射到数据库中。</span><br><span class="line">(5) 一旦使用`Base.metadata.create_all()`将模型映射到数据库中后，即使改变了模型的字段，也不会重新映射了。目前来说，只能删除这个表重新建了</span><br><span class="line"></span><br><span class="line"># Base.metadata.drop_all() # 删除这个表以及里面的数据</span><br><span class="line"># Base.metadata.create_all() # 新建表以及表结构</span><br></pre></td></tr></table></figure></p>
<p><strong>使用Flask-SQLAlchemy去连接数据库：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.数据库连接：</span><br><span class="line">(1)跟sqlalchemy一样，定义好数据库连接字符串DB_URI。</span><br><span class="line">(2)将这个定义好的数据库连接字符串DB_URI，通过`SQLALCHEMY_DATABASE_URI`这个键放到`app.config`中。</span><br><span class="line">示例代码：app.config[&quot;SQLALCHEMY_DATABASE_URI&quot;] = DB_URI</span><br><span class="line">(3)使用`flask_sqlalchemy.SQLAlchemy`这个类定义一个对象，并将`app`传入进去。</span><br><span class="line">示例代码：</span><br><span class="line">from flask_sqlalchemy import SQLAlchemy</span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line">2.创建ORM模型：</span><br><span class="line">还是跟使用sqlalchemy一样，定义模型。现在不再是需要使用`delarative_base`来创建一个基类。而是使用`db.Model`来作为基类。</span><br><span class="line"></span><br><span class="line">3.使用session：</span><br><span class="line">以后session也不需要使用`sessionmaker`来创建了。直接使用`db.session`就可以了。操作这个session的时候就跟之前的`sqlalchemy`的`session`是一模一样的。</span><br><span class="line"></span><br><span class="line">4.在模型类中，`Column`、`String`、`Integer`以及`relationship`等，都不需要导入了，直接使用`db`下面相应的属性名就可以了。</span><br><span class="line">id = db.Column(db.Integer,primary_key=True,autoincrement=True)</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017803857459008" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017803857459008</a><br><a href="http://www.pythondoc.com/flask-sqlalchemy/binds.html" target="_blank" rel="noopener">http://www.pythondoc.com/flask-sqlalchemy/binds.html</a><br><a href="https://www.cnblogs.com/sanduzxcvbnm/p/10219087.html" target="_blank" rel="noopener">https://www.cnblogs.com/sanduzxcvbnm/p/10219087.html</a><br><a href="https://www.cnblogs.com/sanduzxcvbnm/p/10219087.html" target="_blank" rel="noopener">https://www.cnblogs.com/sanduzxcvbnm/p/10219087.html</a><br><a href="https://www.osgeo.cn/sqlalchemy/tutorial/orm_data_manipulation.html" target="_blank" rel="noopener">https://www.osgeo.cn/sqlalchemy/tutorial/orm_data_manipulation.html</a></p>
]]></content>
      <tags>
        <tag>python web</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat系统架构及实现二</title>
    <url>/2019/10/04/tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%E4%BA%8C/</url>
    <content><![CDATA[<h4 id="tomcat的启动流程"><a href="#tomcat的启动流程" class="headerlink" title="tomcat的启动流程"></a>tomcat的启动流程</h4><p>我们通过Tomcat的/bin目录下的脚本startup.sh来启动Tomcat，通过如下流程图来了解一下。<br><img src="/2019/10/04/tomcat系统架构及实现二/tomcat1.png" alt="avatar"><br>Tomcat本质上是一个Java程序，因此startup.sh脚本会启动一个JVM来运行Tomcat的启动类Bootstrap。Bootstrap的主要任务是初始化Tomcat 的类加载器，并且创建Catalina。Catalina是一个启动类，它通过解析server.xml、创建相应的组件，并调用Server的start方法。Server 组件的职责就是管理 Service 组件，它会负责调用Service的start方法。Service 组件的职责就是管理连接器和顶层容器 Engine，因此它会调用连接器和 Engine 的 start 方法。</p>
<h4 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h4><p>Catalina 的主要任务就是创建 Server，它不是直接 new 一个 Server 实例就完事了，而是 需要解析 server.xml，把在 server.xml 里配置的各种组件一一创建出来，接着调用 Server 组件的 init 方法和 start 方法，这样整个 Tomcat 就启动起来了。作为“管理者”， Catalina 还需要处理各种“异常”情况，比如当我们通过“Ctrl + C”关闭 Tomcat 时， Tomcat 将如何优雅的停止并且清理资源呢?因此 Catalina 在 JVM 中注册一个“关闭钩 子”。</p>
]]></content>
      <tags>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>元组的特殊语法</title>
    <url>/2020/08/03/%E5%85%83%E7%BB%84%E7%9A%84%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="元组的特殊语法"><a href="#元组的特殊语法" class="headerlink" title="元组的特殊语法"></a>元组的特殊语法</h2><p>如果圆括号里的单一对象是元组对象而不是一个简单的表达式，需要对python进行特别说明。如果确实想得到一个元组，只要在这一单个元素之后、关闭圆括号之前加一个逗号就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x=(40)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">40</span><br><span class="line">&gt;&gt;&gt; x=(40,)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">(40,)</span><br></pre></td></tr></table></figure>
<h2 id="转换、方法以及不可变性"><a href="#转换、方法以及不可变性" class="headerlink" title="转换、方法以及不可变性"></a>转换、方法以及不可变性</h2><p>元组不提供排序方法，如果想对元组进行排序，通常得先将它转换为列表并使其成为一个可变对象，才能获得使用排序方法调用的权限。或者使用新的sorted的内置方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; T=(&apos;cc&apos;,&apos;aa&apos;,&apos;dd&apos;,&apos;bb&apos;)</span><br><span class="line">&gt;&gt;&gt; tmp=list(T)</span><br><span class="line">&gt;&gt;&gt; tmp.sort()</span><br><span class="line">&gt;&gt;&gt; tmp</span><br><span class="line">[&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;dd&apos;]</span><br><span class="line">&gt;&gt;&gt; T=tuple(tmp)</span><br><span class="line">&gt;&gt;&gt; T</span><br><span class="line">(&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;dd&apos;)</span><br><span class="line">&gt;&gt;&gt; T=(&apos;cc&apos;,&apos;aa&apos;,&apos;dd&apos;,&apos;bb&apos;)</span><br><span class="line">&gt;&gt;&gt; T</span><br><span class="line">(&apos;cc&apos;, &apos;aa&apos;, &apos;dd&apos;, &apos;bb&apos;)</span><br><span class="line">&gt;&gt;&gt; sorted(T)</span><br><span class="line">[&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;dd&apos;]</span><br></pre></td></tr></table></figure>
<h2 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h2><p><strong>什么是列表解析？</strong></p>
<p>简单来说，列表解析（list comprehension）提供了一种优雅的生成列表的方法，能用一行代码代替十几行代码，而且不损失任何可读性。而且，性能还快很多很多</p>
<p>简单给个例子，如果我们需要0~100所有偶数组成的列表，正常的代码应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a=[]</span><br><span class="line">for i in range(101):</span><br><span class="line">    if i%2==0:</span><br><span class="line">        a.append(i)</span><br></pre></td></tr></table></figure>
<p>用列表解析来做就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a=[x for x in range(101) if x%2==0]</span><br></pre></td></tr></table></figure>
<p>简单的一行代码代替了4行代码</p>
<p>从上面的例子来看列表解析的语法其实不难，可以分成三个部分来看</p>
<ul>
<li>x：我们需要的列表里面的结果(1st part)</li>
<li>for x in range(101):x来源——0~100的数字(2nd part)</li>
<li>if x%2==0:x成立的条件，如果不成立就不放在列表里了(3rd part)</li>
</ul>
<p><strong>获取文本中所有单词的第1个字符</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text=&quot;My house is full of flowers&quot;</span><br><span class="line">first_charts=[]</span><br><span class="line">for word in text.split():</span><br><span class="line">    first_charts.append(word[0])</span><br></pre></td></tr></table></figure>
<p>列表解析的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first_charts=[word[0] for word in text.split()]</span><br></pre></td></tr></table></figure>
<p><strong>获取两个列表对应位的乘积</strong></p>
<p>来个复杂的，list a=[2,3,4,5]; list b=[3,4,5,6],想要得到a，b对应位的乘积:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[i*j for i,j in zip(a,b)]</span><br></pre></td></tr></table></figure>
<p><strong>带if else的列表解析</strong></p>
<p>list a=[‘1’,’2’,’3’,’i’,’8’],现在想将a中所有能转化为数字的字符串转化为数字，不为数字的内容都转换成0，用列表解析可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[int(i) if i.isdigit() else 0 for i in a]</span><br><span class="line">out&gt;&gt;[1,2,3,0,8]</span><br></pre></td></tr></table></figure>
<p>增加一点难度，如果list a=[‘1’,’2’,’3’,4,5,’o’,’6’]，如果不能转换成数字则为None，列表解析可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[int(i) if str(i).isdigit() else None for i in a]</span><br><span class="line">out&gt;&gt;[1, 2, 3, 4, 5, None, 6]</span><br></pre></td></tr></table></figure>
<p><strong>获取一个全0列表</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;ok&apos; for i in range(10)]</span><br></pre></td></tr></table></figure></p>
<p><strong>略复杂的列表解析，获取列表中嵌套列表的元素，生成一个无嵌套的新列表</strong></p>
<p>这个例子说起来挺拗口，实际上是想从[[1,2],[3,4,5],[6,7]，[8]]这种列表中，把嵌套在列表中的元素解出来，得到[1,2,3,4,5,6,7,8]，用列表解析可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a=[[1,2],[3,4,5],[6,7],[8]]</span><br><span class="line">[x  for i in a for x in i] </span><br><span class="line">out&gt;&gt;[1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure>
<p>理解起来略有一点麻烦，for i in a，i为子列表，for x in i，x得到每个子列表中的值。这样的列表解析写法确实很难理解，所以有时候我们不要过分的使用复杂的列表解析。</p>
<p><strong>获取所有可能的组合</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from itertools import product</span><br><span class="line">x=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">results = [&quot;&quot;.join(i) for i in product(x, repeat=3)]</span><br><span class="line">out&gt;&gt;[&apos;aaa&apos;, &apos;aab&apos;, &apos;aac&apos;, &apos;aba&apos;, &apos;abb&apos;, &apos;abc&apos;, &apos;aca&apos;, &apos;acb&apos;, &apos;acc&apos;, &apos;baa&apos;, &apos;bab&apos;, &apos;bac&apos;, &apos;bba&apos;, &apos;bbb&apos;, &apos;bbc&apos;, &apos;bca&apos;, &apos;bcb&apos;, &apos;bcc&apos;, &apos;caa&apos;, &apos;cab&apos;, &apos;cac&apos;, &apos;cba&apos;, &apos;cbb&apos;, &apos;cbc&apos;, &apos;cca&apos;, &apos;ccb&apos;, &apos;ccc&apos;]</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://www.jianshu.com/p/c635d3c798c2" target="_blank" rel="noopener">https://www.jianshu.com/p/c635d3c798c2</a></li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式的几种实现方式</title>
    <url>/2020/07/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-饿汉式-线程安全，调用效率高，但是不能延时加载-："><a href="#1-饿汉式-线程安全，调用效率高，但是不能延时加载-：" class="headerlink" title="1. 饿汉式(线程安全，调用效率高，但是不能延时加载)："></a>1. 饿汉式(线程安全，调用效率高，但是不能延时加载)：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123; </span><br><span class="line">     private static Singleton instance = new Singleton; </span><br><span class="line">     private Singleton()&#123;&#125; </span><br><span class="line">     public static Singleton getInstance()&#123;  </span><br><span class="line">          return instance;  </span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一上来就把单例对象创建出来了，要用的时候直接返回即可，这种可以说是单例模式中最简单的一种实现方式。但是问题也比较明显。单例在还没有使用到的时候，初始化就已经完成了。也就是说，如果程序从头到位都没用使用这个单例的话，单例的对象还是会创建。这就造成了不必要的资源浪费。所以不推荐这种实现方式。</p>
<h2 id="2-懒汉式-线程安全，调用效率不高，但是能延时加载"><a href="#2-懒汉式-线程安全，调用效率不高，但是能延时加载" class="headerlink" title="2. 懒汉式(线程安全，调用效率不高，但是能延时加载)"></a>2. 懒汉式(线程安全，调用效率不高，但是能延时加载)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">     </span><br><span class="line">    //类初始化时，不初始化这个对象(延时加载，真正用的时候再创建)</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">     </span><br><span class="line">    //构造器私有化</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    //方法同步，调用效率低</span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            instance=new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Double-CheckLock实现单例：DCL也就是双重锁判断机制（由于JVM底层模型原因，偶尔会出问题，不建议使用）"><a href="#3-Double-CheckLock实现单例：DCL也就是双重锁判断机制（由于JVM底层模型原因，偶尔会出问题，不建议使用）" class="headerlink" title="3. Double CheckLock实现单例：DCL也就是双重锁判断机制（由于JVM底层模型原因，偶尔会出问题，不建议使用）"></a>3. Double CheckLock实现单例：DCL也就是双重锁判断机制（由于JVM底层模型原因，偶尔会出问题，不建议使用）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static volatile Singleton singleton;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        synchronized(Singleton.class)&#123;</span><br><span class="line">            if(singleton == null)&#123;</span><br><span class="line">                synchronized(Singleton.class)&#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return signleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-静态内部类实现模式（线程安全，调用效率高，可以延时加载）"><a href="#4-静态内部类实现模式（线程安全，调用效率高，可以延时加载）" class="headerlink" title="4. 静态内部类实现模式（线程安全，调用效率高，可以延时加载）"></a>4. 静态内部类实现模式（线程安全，调用效率高，可以延时加载）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingletonDemo3 &#123;</span><br><span class="line">    private static class SingletonClassInstance&#123;</span><br><span class="line">        private static final SingletonDemo3 instance=new SingletonDemo3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo3()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo3 getInstance()&#123;</span><br><span class="line">        return SingletonClassInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-枚举类（线程安全，调用效率高，不能延时加载，可以天然的防止反射和反序列化调用）"><a href="#5-枚举类（线程安全，调用效率高，不能延时加载，可以天然的防止反射和反序列化调用）" class="headerlink" title="5.枚举类（线程安全，调用效率高，不能延时加载，可以天然的防止反射和反序列化调用）"></a>5.枚举类（线程安全，调用效率高，不能延时加载，可以天然的防止反射和反序列化调用）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">     public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;doSomething&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://www.cnblogs.com/happy4java/p/11206105.html" target="_blank" rel="noopener">https://www.cnblogs.com/happy4java/p/11206105.html</a></li>
<li><a href="https://www.cnblogs.com/shujiying/p/13127418.html" target="_blank" rel="noopener">https://www.cnblogs.com/shujiying/p/13127418.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序算法</title>
    <url>/2020/08/24/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>堆排序</strong></p>
<p>　　堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p>
<p><strong>堆</strong></p>
<p>　　堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</p>
<p><img src="/2020/08/24/堆排序算法/sort1.png" alt="avatar"></p>
<p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p>
<p><img src="/2020/08/24/堆排序算法/sort2.png" alt="avatar"></p>
<p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p>
<p>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]  </p>
<p>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]  </p>
<p>ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：</p>
<p><strong>堆排序基本思想及步骤</strong></p>
<blockquote>
<p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
</blockquote>
<p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p>
<p>　　a.假设给定无序序列结构如下</p>
<p><img src="/2020/08/24/堆排序算法/sort3.png" alt="avatar"></p>
<p>2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p>
<p><img src="/2020/08/24/堆排序算法/sort4.png" alt="avatar"></p>
<p>4.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。   </p>
<p><img src="/2020/08/24/堆排序算法/sort5.png" alt="avatar"></p>
<p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</p>
<p><img src="/2020/08/24/堆排序算法/sort6.png" alt="avatar"></p>
<p>此时，我们就将一个无需序列构造成了一个大顶堆。</p>
<p>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</p>
<p>a.将堆顶元素9和末尾元素4进行交换</p>
<p><img src="/2020/08/24/堆排序算法/sort7.png" alt="avatar"></p>
<p>b.重新调整结构，使其继续满足堆定义</p>
<p><img src="/2020/08/24/堆排序算法/sort8.png" alt="avatar"></p>
<p>c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</p>
<p><img src="/2020/08/24/堆排序算法/sort9.png" alt="avatar"></p>
<p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p>
<p><img src="/2020/08/24/堆排序算法/sort10.png" alt="avatar"></p>
<p>再简单总结下堆排序的基本思路：</p>
<p>　　a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p>
<p>　　b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</p>
<p>　　c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>多路复用机制与javaNIO</title>
    <url>/2019/09/17/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%8EjavaNIO/</url>
    <content><![CDATA[<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。<br>1、select实现<br><img src="/2019/09/17/多路复用机制与javaNIO/select.png" alt="avatar"><br>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间<br>（2）注册回调函数<strong>pollwait<br>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）<br>（4）以tcp_poll为例，其核心实现就是</strong>pollwait，也就是上面注册的回调函数。<br>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。<br>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。<br>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。<br>（8）把fd_set从内核空间拷贝到用户空间。<br>总结：<br>select的几大缺点：<br>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大<br>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大<br>（3）select支持的文件描述符数量太小了，默认是1024</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>开源协议概览</title>
    <url>/2021/06/22/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<p>在申请专利的过程中，因为系统中涉及相关组件，其中组件使用的协议有可能会涉及商业开源问题，小结下开源协议的异同点如下。</p>
<p>世界上的开源许可证（Open Source License）大概有上百种，我们常用的开源软件协议大致有GPL、BSD、MIT、Mozilla、Apache和LGPL。</p>
<p>由宽松到严紧排序，常用的开源许可证有：</p>
<ol>
<li>MIT许可证</li>
<li>BSD许可证</li>
<li>Apache许可证</li>
<li>LGPL许可证</li>
<li>GPL许可证</li>
</ol>
<p>MIT、BSD 许可证都源自大学，体现了简单、开放和包容的特点。</p>
<p>MIT、BSD、Apache 三者都支持闭源的后续开发。</p>
<p>GPL、LGPL 传染性开源，编译的代码里用了这里的代码，都必须开源。</p>
<p>其它License，最好都在产品上说明使用了，署名保留原作者就ok。</p>
<p><strong>MIT（MIT）</strong></p>
<p>来源于大学，MIT 许可证是史上最为简洁和慷慨（permissive）的开源协议之一。作者只想保留版权,而无任何其他了限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的。</p>
<p>简言之：</p>
<ul>
<li>用户可以拿你的代码做任何想做的事情</li>
<li>用户在项目副本中要包含版权声明和许可声明</li>
<li>你无需承担任何责任</li>
</ul>
<p>应用案例有：JQuery、Rails 等</p>
<p><strong>BSD开源协议（original BSD license、FreeBSD license、Original BSD license）</strong></p>
<p>来源于大学，BSD可证与MIT差不多，也非常简单、慷慨。</p>
<p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p>
<p>但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p>
<ul>
<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li>
<li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li>
<li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li>
</ul>
<p>BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对 商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p>
<p><strong>Apache Licence 2.0（Apache License, Version 2.0、Apache License, Version 1.1、Apache License, Version 1.0）</strong></p>
<p>来自apache，类似MIT许可证，但它重视专利权。</p>
<p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：</p>
<ol>
<li>需要给代码的用户一份Apache Licence</li>
<li>如果你修改了代码，需要再被修改的文件中说明。</li>
<li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li>
<li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。</li>
</ol>
<p>Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。</p>
<p>应用案例有：Apache 家族、SVN、NuGet 等等。</p>
<p><strong>LGPL（GNU Lesser General Public License）</strong></p>
<p>来源自由软件联盟GNU，可以翻译为更宽松的GPL协议，也属于传染性开源。</p>
<p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。</p>
<p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源 代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p>
<p><strong>GPL（GNU General Public License）</strong></p>
<p>来源自由软件联盟GNU，GPL/LGPL侧重于代码及衍生代码的开源与免费使用。</p>
<p>GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。</p>
<p>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</p>
<p>我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商 业软件公司开发的免费软件了。</p>
<p>其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。</p>
<p>应用案例：Linux</p>
<p><strong>参考文献</strong></p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/87855729" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/87855729</a></li>
</ol>
]]></content>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>循环队列</title>
    <url>/2019/09/01/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>队列(Queue)两端同意操作的类型不一样：<br>能够进行删除的一端称为队头，这样的操作也叫出队dequeue；<br>能够进行插入的一端称为队尾，这样的操作也叫入队enqueue。<br>1、添加一个属性size用来记录眼下的元素个数。<br>目的是当head=rear的时候。通过size=0还是size=数组长度。来区分队列为空，或者队列已满。<br>2、数组中仅仅存储数组大小-1个元素，保证rear转一圈之后不会和head相等。也就是队列满的时候。rear+1=head，中间刚好空一个元素。<br>当rear=head的时候。一定是队列空了。<br>解决这种问题的常见做法是这种：<br>使用一标记，用以区分这样的易混淆的情形。<br>牺牲一个元素空间。当front和rear相等时，为空。当rear的下一个位置是front时，为满。<br><img src="/2019/09/01/循环队列/queue.png" alt="avatar"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hyh.datastructure;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">public class CQueue &#123;</span><br><span class="line">    private int front;//指向队首</span><br><span class="line">    private int rear;//指向队尾</span><br><span class="line">    private int[] elem;</span><br><span class="line">    private int maxSize;//最大容量</span><br><span class="line"> </span><br><span class="line">    public CQueue(int maxSize) &#123;</span><br><span class="line">        this.front = 0;</span><br><span class="line">        this.rear = 0;</span><br><span class="line">        this.elem = new int[maxSize];</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return rear==front;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isFull()&#123;</span><br><span class="line">        return  (rear+1)%maxSize==front;</span><br><span class="line">    &#125;</span><br><span class="line">    public void offer(int val)&#123;</span><br><span class="line">        if(isFull())return;</span><br><span class="line">        elem[rear++]=val;</span><br><span class="line">        rear=rear%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    public void poll()&#123;</span><br><span class="line">        if(isEmpty())return;</span><br><span class="line">        front=++front%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    public int peek()&#123;</span><br><span class="line">        if(isEmpty())return -1;</span><br><span class="line">        return elem[front];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        String str=&quot;&quot;;</span><br><span class="line">        for (int i:elem</span><br><span class="line">             ) &#123;</span><br><span class="line">            str=str+i;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CQueue c= new CQueue(5);</span><br><span class="line">        System.out.println(c.isEmpty());//true</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            c.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(c.isFull());//true</span><br><span class="line">        System.out.println(c.toString());//01230   因为实际容量是maxSize-1 所以只存了前4次的值</span><br><span class="line">        c.poll();</span><br><span class="line">        c.offer(4);</span><br><span class="line">        System.out.println(c.toString());//01234</span><br><span class="line">        c.poll();</span><br><span class="line">        c.offer(5);</span><br><span class="line">        System.out.println(c.toString());//51234</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.jb51.net/article/130855.htm" target="_blank" rel="noopener">https://www.jb51.net/article/130855.htm</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构-字典树</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<h3 id="什么是Trie树"><a href="#什么是Trie树" class="headerlink" title="什么是Trie树"></a>什么是Trie树</h3><p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p>
<p><strong>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</strong></p>
<p><img src="/2021/04/18/数据结构-字典树/tire1.png" alt="avatar"></p>
<p>它有3个基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<h3 id="树的构建"><a href="#树的构建" class="headerlink" title="树的构建"></a>树的构建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TireTree(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Initialize your data structure here.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line">        self.word_end = -1</span><br><span class="line"></span><br><span class="line">    def insert(self, word):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Inserts a word into the trie.</span><br><span class="line">        :type word: str</span><br><span class="line">        :rtype: void</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        curNode = self.root</span><br><span class="line">        for c in word:</span><br><span class="line">            if not c in curNode:</span><br><span class="line">                curNode[c] = &#123;&#125;</span><br><span class="line">            curNode = curNode[c]</span><br><span class="line">        curNode[self.word_end] = True</span><br><span class="line"></span><br><span class="line">    def search(self, word):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns if the word is in the trie.</span><br><span class="line">        :type word: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        curNode = self.root</span><br><span class="line">        for c in word:</span><br><span class="line">            if not c in word:</span><br><span class="line">                return False</span><br><span class="line">            curNode = curNode[c]</span><br><span class="line"></span><br><span class="line">        if self.word_end not in curNode:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    def startsWith(self, prefix):</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns if there is any word in the trie that starts with the given prefix.</span><br><span class="line">        :type prefix: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        curNode = self.root</span><br><span class="line">        for c in prefix:</span><br><span class="line">            if not c in curNode:</span><br><span class="line">                return False</span><br><span class="line">            curNode = curNode[c]</span><br><span class="line"></span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    tire = TireTree()</span><br><span class="line">    tire.insert(&quot;hello world&quot;)</span><br><span class="line">    print(tire.search(&quot;hello world&quot;))</span><br><span class="line">    print(tire.startsWith(&quot;hello&quot;))</span><br></pre></td></tr></table></figure>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>典型应用是用于统计，排序和公共字符串(不仅限于字符串)，经常被搜索引擎系统用于文本词频统计。</p>
<ol>
<li>字符串的快速查找</li>
</ol>
<p>给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。在这道题中，我们可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。</p>
<ol start="2">
<li>字典树在“串”排序方面的应用</li>
</ol>
<p>给定N个互不相同的仅由一个单词构成的英文名，让你将他们按字典序从小到大输出用字典树进行排序，采用数组的方式创建字典树，这棵树的每个节点的所有儿子很显然地按照其字母大小排序,对这棵树进行先序遍历即可。</p>
<ol start="3">
<li>字典树在最长公共前缀问题的应用</li>
</ol>
<p>对所有串建立字典树，对于两个串的最长公共前缀的长度即他们所在的节点的公共前缀。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://blog.csdn.net/tuwenqi2013/article/details/89389983" target="_blank" rel="noopener">https://blog.csdn.net/tuwenqi2013/article/details/89389983</a></li>
<li><a href="https://www.cnblogs.com/iris001999/p/9057988.html" target="_blank" rel="noopener">https://www.cnblogs.com/iris001999/p/9057988.html</a></li>
<li><a href="https://blog.csdn.net/ANNILingMo/article/details/80879910" target="_blank" rel="noopener">https://blog.csdn.net/ANNILingMo/article/details/80879910</a></li>
<li><a href="https://blog.csdn.net/danengbinggan33/article/details/82151220?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.control" target="_blank" rel="noopener">https://blog.csdn.net/danengbinggan33/article/details/82151220?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-8.control</a></li>
</ol>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>文件锁fcntl</title>
    <url>/2020/08/03/%E6%96%87%E4%BB%B6%E9%94%81fcntl/</url>
    <content><![CDATA[<h2 id="python中的文件锁"><a href="#python中的文件锁" class="headerlink" title="python中的文件锁"></a>python中的文件锁</h2><p>我们在写python应用的时候，当涉及到多个进程向同一个文件write(或者read)的情况，如果几个进程同时都对这个文件进行写操作，那么文件的内容就会变得非常混乱，这个时候文件锁就派上用场了。</p>
<p>python中的文件锁，可以保证同时只有一个进程写文件，目前使用的是fcntl这个库，它实际上为 Unix上的ioctl，flock和fcntl 函数提供了一个接口。python通过调用fcntl.flock()函数对文件加锁。</p>
<p>fcntl这个模块是Python自带的，但Windows没有，可以手工下载fcntl.py文件，然后保存到python的Lib目录下。</p>
<h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><ul>
<li>LOCK_SH： 表示要创建一个共享锁，在任意时间内，一个文件的共享锁可以被多个进程拥有</li>
<li>LOCK_EX： 表示创建一个排他锁，在任意时间内，一个文件的排他锁只能被一个进程拥有</li>
<li>LOCK_UN： 表示删除该进程创建的锁(解锁)</li>
<li>LOCK_MAND：它主要是用于共享模式强制锁，它可以与 LOCK_READ 或者 LOCK_WRITE 联合起来使用，从而 表示是否允许并发的读操作或者并发的写操作（尽管在 flock() 的手册页中没有介绍 LOCK_MAND，但是阅读内核源代码就会发现，这在内核中已经实现了）</li>
<li>LOCK_NB： 如果指定此参数，函数不能获得文件锁就立即返回，否则，函数会等待获得文件锁。LOCK_NB可以同LOCK_SH或LOCK_EX进行按位或（|）运算操作</li>
</ul>
<p>例如：一个文件设置了排它锁，如果这个锁已经被某个进程获取了，那么其他进程请求获取这个锁的时候将会被阻塞。<br>如果想要在没有获得这个排他锁的情况下不阻塞那些进程，可以与 LOCK_NB 联合使用，那么系统就不会阻塞该进程。即： fcnt.flock(f,fcntl.LOCK_EX|fcntl.LOCK_NB)</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>对于文件的 close() 操作会使文件锁失效；</li>
<li>同理，进程结束后文件锁失效；</li>
<li>flock() 的 LOCK_EX是“劝告锁”，系统内核不会强制检查锁的状态，需要在代码中进行文件操作的地方显式检查才能生效。</li>
<li>在给文件加锁之前,一定要保证文件以相应的访问模式打开,例如：<blockquote>
<p>要对一个文件加上共享锁,一定要首先按读模式打开文件；<br>  若要给文件加上排他锁,则首先要按写模式打开对应文件；<br>  若想加两种锁，则需要按读写模式打开.</p>
</blockquote>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import fcntl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Lock(object):</span><br><span class="line">    def __init__(self, file_name):</span><br><span class="line">        self.file_name = file_name</span><br><span class="line">        self.handle = open(file_name, &apos;w+&apos;)</span><br><span class="line"></span><br><span class="line">    def lock(self):</span><br><span class="line">        fcntl.flock(self.handle, fcntl.LOCK_EX | fcntl.LOCK_NB)</span><br><span class="line"></span><br><span class="line">    def unlock(self):</span><br><span class="line">        fcntl.flock(self.handle, fcntl.LOCK_UN)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        try:</span><br><span class="line">            self.handle.close()</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://www.cnblogs.com/Zzbj/p/11068131.html" target="_blank" rel="noopener">https://www.cnblogs.com/Zzbj/p/11068131.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器上的MGMT管理口</title>
    <url>/2021/04/15/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84MGMT%E7%AE%A1%E7%90%86%E5%8F%A3/</url>
    <content><![CDATA[<h3 id="浪潮服务器管理口地址配置参考"><a href="#浪潮服务器管理口地址配置参考" class="headerlink" title="浪潮服务器管理口地址配置参考"></a>浪潮服务器管理口地址配置参考</h3><p>开机启动按Delete键，进入BIOS集成IPMI 管理卡IP地址，在BIOS 中的“Server Mgmt”选项中选择“BMC networkConfiguration”</p>
<p>将专用管理口的updata BMC LAN Configuration 改为yes 后下面的灰色选项会被激活，将Configuration Address source 配置项从默认的Dynamic 改为static 静态然后配置管理口IP为比如10.1.1.1<br>按F10 保存重启后将电脑与管理口相连，并将电脑的网口设置为与管理口同网段IP（如10.1.1.5），先ping一下是否ping通 </p>
<p>进入位于windows控制面板的java控制台中，在安全选项下添加服务器管理口对应的IP地址 保存，然后通过火狐浏览器直接登陆即可。</p>
<h3 id="使用远程管理端口（mgmt或ilo）进行服务器底层远程管理"><a href="#使用远程管理端口（mgmt或ilo）进行服务器底层远程管理" class="headerlink" title="使用远程管理端口（mgmt或ilo）进行服务器底层远程管理"></a>使用远程管理端口（mgmt或ilo）进行服务器底层远程管理</h3><p>服务器上集成的远程管理端口，它是一组芯片内部集成vxworks嵌入式操作系统，通过一个标准RJ45接口连接到工作环境的交换机。只要将服务器接入网络并且没有断开服务器的电源，不管HP服务器的处于何种状态（开机、关机、重启），都可以允许用户通过网络进行远程管理。简单来说，远程管理端口是高级别的远程KVM系统，可以将服务器的显示信息显示在本地，并且使用本地的键盘鼠标控制、操作服务器，并可以将本地的光盘镜像、文件夹作为虚拟光驱映射并加载到服务器中。使用远程管理端口，可以完成低层的BIOS设置、磁盘RAID配置、操作系统的安装等底层的工作，并且可以在完成系统安装后实现系统的远程控制与管理。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://www.cnblogs.com/huazai007/articles/7927644.html" target="_blank" rel="noopener">https://www.cnblogs.com/huazai007/articles/7927644.html</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_4c86552f0102wd39.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4c86552f0102wd39.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器网口分类及顺序确认</title>
    <url>/2021/04/22/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%8F%A3%E5%88%86%E7%B1%BB%E5%8F%8A%E9%A1%BA%E5%BA%8F%E7%A1%AE%E8%AE%A4/</url>
    <content><![CDATA[<h4 id="服务器网卡光口和电口的区别"><a href="#服务器网卡光口和电口的区别" class="headerlink" title="服务器网卡光口和电口的区别"></a>服务器网卡光口和电口的区别</h4><p>光纤接口简称为光口也可称之为G口 (意思是G光纤口)，是用来连接光纤线缆的物理接口。其原理是利用了光从光密介质进入光疏介质从而发生了全反射。一般是应用于机房、机柜等大型设备的一个光纤带宽接口。</p>
<p>电口就是普通的双绞线(TwirstPair)接口，传输的是电信号，而电口是相对光口来讲的，是指防火器的物理特性，主要指铜缆，是处理的电信号。目前使用普遍的网络接口有百兆电口和千兆电口、万兆电口等。简单来说，电口就是普通的网线接口，一般速率为10M、100M或者1000M。</p>
<p>服务器网卡光口和电口网卡的主要区别主要是在于传输距离上，服务器电口网卡的传输距离只能到100米，而服务器光口网卡分为单模和多模，多模一般传输几百米，单模传输可以达到几千米，什么传输速率的，都一样的。</p>
<p>电口网卡：电口是服务器和网络中对RJ45等各种双绞线接口的统称，其原因是这些端口都使用电作为信息的承载介质，不过有时它也会包含同轴电缆端口。通常电口可能使用百兆以太网、千兆以太网、万兆以太网或其它种类的传输协议。<br><img src="/2021/04/22/服务器网口分类及顺序确认/net1.png" alt="avatar"></p>
<p>光口网卡：光口是服务器和网络中对各种光纤端口的统称，它是以光作为信息的承载介质。光口可能包含有从ST到SFF(小型化光纤连接器，以 MTRJ和LC为主)的各种光纤接口，因此在布线施工后期配备光纤跳线时，需要核实光口的光纤接口种类，以免在布线配置时假定的光纤跳线种类与实际使用的要求不匹。<br><img src="/2021/04/22/服务器网口分类及顺序确认/net2.png" alt="avatar"></p>
<h4 id="多网卡Linux服务器如何确定网口位置"><a href="#多网卡Linux服务器如何确定网口位置" class="headerlink" title="多网卡Linux服务器如何确定网口位置"></a>多网卡Linux服务器如何确定网口位置</h4><p>在配置有多个网络接口的设备时我们会犯难，eth0、eth1、……到底是那个接口？</p>
<p>今天为大家介绍一个小工具，ethtool，他可以帮助你解决这个问题。</p>
<p>我使用的机器是Fedora Linux 系统，打开终端，输入ethtool –help 显示帮助信息，下面我就简要介绍一下最常用的两个功能。</p>
<p>功能1</p>
<p>ethtool DEVNAME   查看相应设备名称对应的设备信息</p>
<p>使用方法如下：<br>ethtool eth3</p>
<p>显示了eth3 的接口类型，连接模式，速率等等信息，方便你找到相应的网卡。（如果是网线Supported ports 就是TP，如果是光纤则显示Fiber）</p>
<p><img src="/2021/04/22/服务器网口分类及顺序确认/net3.png" alt="avatar"></p>
<p>功能2</p>
<p>ethtool -p DEVNAME   查看相应设备名称对应的设备位置</p>
<p>使用方法如下：<br>ethtool -p eth0</p>
<p>回车后与eth0 相对应的网卡接口旁边的指示灯就会闪烁，这样你就能很快确定eth0 网口的位置啦。（按下Ctrl+C 结束命令，停止闪烁）</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol>
<li><a href="http://www.grt-china.com/xinwenzixun/518.html" target="_blank" rel="noopener">http://www.grt-china.com/xinwenzixun/518.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>架构与开源</title>
    <url>/2019/09/13/%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BC%80%E6%BA%90/</url>
    <content><![CDATA[<h4 id="1-关于架构与技术栈"><a href="#1-关于架构与技术栈" class="headerlink" title="1.关于架构与技术栈"></a>1.关于架构与技术栈</h4><p>技术架构一遍经过三个阶段，创建期、瓶颈期和退化期，就像下面这张图所画:<br><img src="/2019/09/13/架构与开源/arti.png" alt="avatar"><br>架构的选型要注意以下几点：功能预见性（功能性）、系统可用性、容错性、可靠性、性能够快、可伸缩、可维护性、安全性、成本、可度量性;<br>架构的选型的误区：“重复造轮子”、脱离实际业务需求、避免无意义的重构、功能完成是完事了、技术解决一切；</p>
<h4 id="2-关于开源"><a href="#2-关于开源" class="headerlink" title="2.关于开源"></a>2.关于开源</h4><p>开源软件的优势：</p>
<ul>
<li>成本</li>
<li>效率</li>
<li>安全、稳健</li>
<li>大企业的背书</li>
<li>学习成本、技术支持</li>
</ul>
<p>开源协议的选择：</p>
<p>GPL许可：是 GNU General Public License 的缩写，既GNU通用公共许可协议，是自由软件基金会（GNU）发布的一个软件首选许可，GPL许可一共发布的三个不版本，最新一版是2007年公布的GPLv3，最著名的使用GPL许可的软件就是大Linux。GPL许可的特点就是，使用GPL软件(包括类库)或者源代码（不管多少）的发布的新产品（包括新增源代码和可执行二进制文件）也必须使用GPL协议，也要公开源代码。由于这个许可具有一定的开源强制性，很多大公司对GPL许可的开源软件的选择还是比较谨慎的。GPL 协议有很多变种：比如LGPL, AGPL<br>LGPL : LGPL 是 GNU Lesser General Public License 的缩写 既GNU宽通用公共许可证，相比于GPL，其开源强制性弱一些，对商用软件更加友好，使用该许可的著名软件是Linux下的办公软件 OpenOffice。按照该许可协议的要求，以类库方式引入基于LGPL许可的软件可以不开源其衍生产品的源代码，单对于LGPL许可授权的源代码进行修改或者和修改相关的衍生代码则必须开源且使用LGPL许可进行授权。<br>AGPL：Affero General Public License，简称Affero GPL或AGPL，Affero 是一家公司名称，AGPL最初由该公司撰写，改许可是相当于GPL的增强版本，主要是对通过网络发布服务进行限制。GPL许可本身限制的是软件的“发布”行为，只要是使用了GPL许可的源代码或者二进制文件，必须开源且以同样以GPL许可进行授权，但到了互联网十点，很多互联网公司并不发布软件实体，而是提供“服务”，所以GPL的约束力就明显下降了，AGPL许可的目的就是填补这个所谓的“漏洞”，改许可要求，除了GPL本身的约束以外，所有基于AGPL许可软件提供网络服务，其相关源代码必须开源，所以在AGPL许可下，网络服务也被看做一种分发形式。所以很多互联网公司禁止使用 AGPL 许可的开源软件。<br>BSD许可：BSD（BSD是Berkly Software Distribution的简写）许可最初使用在加州大学伯克利分校发布的 BSD Unix 系统上，随着BSD系统的发展，BSD许可也随之沿用下来。相比于GPL 和 MPL 的严格要求，BSD 许可的的要求就非常宽松，给予使用者非常大的自由度。在该许可下的软件可以自由使用修改，也可以将修改后的代码再次发布，而且可以是按照闭源的私有软件进行发布，只需要在发布的软件和中保留BSD许可协议文件即可，但未经许可不能使用原作者或者机构名义进行宣传和推广。+<br>MPL许可：MPL是 The Mozilla Public License 的做些。是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。MPL许可允许经过MPL授权的源代码和其他授权的文件（包括源代码和二进制文件）混合使用，甚至剥和私有软件混合使用，这相当于GPL许可和BSD或类似许可的折中，其既有一定的开源强制性，又保留一定的私有权利。按照该许可要求，使用基于MPL授权源代码的部分，包括对MPL源代码的修改部分，必须保持MPL授权，这一点和GPL协议类似，但新增代码发布的可使用其他方式授权，甚至是私有授权，也可以比闭源的方式。<br>MIT 许可：MIT 许可是来自麻省理工学院（Massachusetts Institute of Technology, MIT），该许可被认为是最自由的开源协议之一，也是应用最为广泛的开源协议(据blackduck——一家对软件源代码进行合规审计的公司，统计，全球有将近1/3的开源软件使用MIT开源协议)，他的协议声明非常简短，他和BSD许可类似，允许自由修改发布基于MIT的代码和软件，只需要你的发行版里包含原始协议文件即可，其他无任何限制，及时使用原始作者的名义进行推广。使用MIT许可的著名软件有ssh 客户端软件jquery,Rails，putty 和 xwindows等。<br>Apache 2.0许可：改协议是由Apache软件基金会发布的许可，最初用在像Apache web Server这样Apache的内部软件中，2004年公布了2.0版本。其限制条件和BSD类似，允许自由修改和使用、发布软件，但要求保留版权，相比于BSD许可，该许可对版权要求的更细，每一个被修改后的原始文件都要著名原始版权声明。使用 Apache 2.0许可 著名的软件有 Android ,Apache web server，swift 等。</p>
]]></content>
  </entry>
  <entry>
    <title>浅拷贝与深拷贝以及引用</title>
    <url>/2020/08/03/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%BB%A5%E5%8F%8A%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Python-变量存储情况"><a href="#Python-变量存储情况" class="headerlink" title="Python 变量存储情况"></a>Python 变量存储情况</h2><p>在高级语言中，变量是对内存及其地址的抽象。对于python 而言，python 的一切变量都是对象，变量的存储，采用了引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是指这个变量的本身:</p>
<p>引用语义：在 python 中，变量保存的是对象(值)的引用，我们称为 引用语义。采用这种方式，变量所需的存储空间大小一致，因为变量只是保存了一个引用。也被称为对象语义和指针语义。</p>
<p>值语义：有些语言采用的不是这种方式，它们把变量的值直接保存在变量的存储区里，这种方式被我们称为值语义，例如 C 语言，采用这种存储方式，每一个变量在内存中所占的空间就要根据变量实际的大小而定，无法固定下来。</p>
<p>值语义和引用语义的区别：</p>
<p>值语义： 死的、 傻的、 简单的、 具体的、 可复制的<br>引用语义： 活的、 聪明的、 复杂的、 抽象的、 不可复制的</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析GIT分支模型</title>
    <url>/2020/07/08/%E6%B5%85%E6%9E%90GIT%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>前几天在大神的wiki里看到了这么一篇文章（<a href="https://nvie.com/posts/a-successful-git-branching-model/），抱着学习的态度想对原文进行翻译下，不当之处请大家多多指教。图1是给出的git分支模型，在原文中作者没有讨论任何项目的细节信息，仅仅讨论关于分支策略和release版本管理。" target="_blank" rel="noopener">https://nvie.com/posts/a-successful-git-branching-model/），抱着学习的态度想对原文进行翻译下，不当之处请大家多多指教。图1是给出的git分支模型，在原文中作者没有讨论任何项目的细节信息，仅仅讨论关于分支策略和release版本管理。</a><br><img src="/2020/07/08/浅析GIT分支模型/git1.png" alt="avatar"></p>
<h2 id="Decentralized-but-centralized"><a href="#Decentralized-but-centralized" class="headerlink" title="Decentralized but centralized"></a>Decentralized but centralized</h2><p>GIT是一个分布式的版本控制工具，在技术层面是没有中央仓库(不考虑gitlab、github)的概念。但是在此分支模型中，我们在创建使用一个仓库时，设定一个仓库为中央仓库，根据开发者的使用习惯，定义此仓库名称为origin，如图2所示。<br><img src="/2020/07/08/浅析GIT分支模型/git2.png" alt="avatar"><br>项目开发组中的成员都可以在origin分支上拉取上传代码，除了这种集中式的推拉关系外，还可以从项目组的其他成员那儿拉取代码。通过构建不同的子项目组，也就是通过创建不同的分支，可以实现不同功能需求的并行开发，待开发完毕后合并到origin分支上。图2中alice和bob、alice和david、david和clair可以理解为3个不同的子项目组，也可以理解为3个不同的分支。</p>
<h2 id="The-main-branches"><a href="#The-main-branches" class="headerlink" title="The main branches"></a>The main branches</h2><p>在图3分支模型中，中央仓库在其生命周期中维护着两个分支：master分支和develop分支。master分支上的代码是生产环境稳定运行的代码，开发者不应该在master分支上做任何修改代码的操作；develop分支是新功能迭代中合并的主分支，开发者可以在此分支上进行对应的回归测试和夜构建。当develop分支上的代码达到上线标准并且准备发布时，开发者需要将develop分支上的代码合并到master分支上，并且打上对应的tag。<br><img src="/2020/07/08/浅析GIT分支模型/git3.png" alt="avatar"></p>
<h2 id="Supporting-branches"><a href="#Supporting-branches" class="headerlink" title="Supporting branches"></a>Supporting branches</h2><p>除了master分支和develop分支以外，分支模型中需要一些额外的分支来支撑项目中新功能的开发、版本的迭代、线上问题的修复。由于这些分支特有的属性，导致它们的生命周期都比较短暂。在此模型中，我们将这些分支定义为feature分支、relaese分支和hotfix分支。</p>
<h2 id="Feature-branches"><a href="#Feature-branches" class="headerlink" title="Feature branches"></a>Feature branches</h2><p>feature分支用于开发即将推出或未来版本的新功能。如图4所示，feature分支的本质是，只要功能处于开发阶段它就会存在，但最终会被合并到develop分支或丢弃。feature分支的命名规则比较随意，只需要避免”master”、”develop”、”release-<em>“,”hotfix-x</em>“这几类名称就可以。通常我们都从develop分支上创建一个feature分支，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b myfeature develop</span><br></pre></td></tr></table></figure></p>
<p>当完成功能开发时，需要将feature分支合并到develop分支上，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line"></span><br><span class="line">git merge --no--ff myfeature</span><br><span class="line"></span><br><span class="line">git branch -d myfeature</span><br><span class="line"></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/08/浅析GIT分支模型/git4.png" alt="avatar"></p>
<h2 id="Release-branches"><a href="#Release-branches" class="headerlink" title="Release branches"></a>Release branches</h2><p>release分支是从准上线的状态的develop分支上创建而来，反映了我们对于新版本的期望。在新版中，一些重要的feature需要合并到develop分支上。此外，在release分支上可以进行小问题的修改，并且为发布版本（版本号，构建日期等）提供元数据信息。正是在release分支开始时，即将发布的版本才会被分配一个版本号 。需要说明的是，开发分支仅反映了“下一个版本”的变化，但是尚不清楚这个“下一个版本”是否最终会变为0.3或1.0，首先创建一个release分支：<br><img src="/2020/07/08/浅析GIT分支模型/git5.png" alt="avatar"><br>然后把release分支上的代码进行合并到master分支上，<br><img src="/2020/07/08/浅析GIT分支模型/git6.png" alt="avatar"><br>此外需要将代码合并到develop分支上，<br><img src="/2020/07/08/浅析GIT分支模型/git7.png" alt="avatar"><br>最后删除release分支<br><img src="/2020/07/08/浅析GIT分支模型/git8.png" alt="avatar"></p>
<h2 id="Hotfix-branches"><a href="#Hotfix-branches" class="headerlink" title="Hotfix branches"></a>Hotfix branches</h2><p>当生产环境中的代码存在严重bug时，需要从master分支上创建hotfix分支进行bug的修复，修复完毕后在合并到develop分支和master分支上。分支名称一般命名为”hotfix-*”。<br><img src="/2020/07/08/浅析GIT分支模型/git9.png" alt="avatar"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是文章中介绍的git分支模型。在我们实际的项目开发中，根据自己项目特点仅使用master、develop和feature分支构成的阉割版的分支模型。总之，代码规范跟自己团队的规模、项目迭代情况、项目组开发者等各种因素相关，我们需要根据以上各种因素选择最合适的gitflow工作流程。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>docker端口映射相关问题</title>
    <url>/2021/04/01/%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>docker容器内提供服务并监听8888端口，要使外部能够访问，需要做端口映射。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --rm -p 8888:8888 server:v1</span><br></pre></td></tr></table></figure>
<p>此时出现问题，在虚机A上部署后，在A内能够访问8888端口服务，但是在B却不能访问。</p>
<p>这应该是由于请求被拦截。</p>
<p><strong>1. 查看firewall-cmd –state</strong></p>
<p>如果输出的是“not running”则FirewallD没有在运行，且所有的防护策略都没有启动，那么可以排除防火墙阻断连接的情况了。</p>
<p>如果输出的是“running”，表示当前FirewallD正在运行，需要再输入下面的命令查看现在开放了哪些端口和服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br><span class="line">firewall-cmd --list-services</span><br></pre></td></tr></table></figure>
<p>解决方案有两种：</p>
<p>1.关闭FirewallD服务：</p>
<p>如果您不需要防火墙，那直接关掉FirewallD服务就好了</p>
<p>systemctl stop firewalld.service<br>2.添加策略对外打开指定的端口：</p>
<p>比如我们现在要打开对外5000/tcp端口，可以使用下面的命令：</p>
<p>firewall-cmd –add-port=5000/tcp –permanent<br>firewall-cmd –reload<br>如果只是临时打开端口，去掉第一行命令中的“–permanent”参数，那么当再次重启FirewallD服务时，本策略将失效。</p>
<p><strong>2 ip转发没有打开</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.ip_forward</span><br></pre></td></tr></table></figure>
<p>显示net.ipv4.ip_forward=0则表示未打开。</p>
<p><strong>3. service iptables打开并拦截了</strong></p>
<p>可关闭service iptables</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service iptables stop</span><br></pre></td></tr></table></figure>
<p>若docker run时出现错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables: No chain/target/match by that name.</span><br></pre></td></tr></table></figure>
<p>则只需重启docker服务即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#设置iptables防火墙为开机启动项 </span><br><span class="line">systemctl enable iptables.service</span><br><span class="line"></span><br><span class="line">#启动防火墙使配置文件生效 </span><br><span class="line">systemctl start iptables.service</span><br><span class="line"></span><br><span class="line">#停止防火墙 </span><br><span class="line">systemctl stop iptables.service</span><br><span class="line"></span><br><span class="line">#重启防火墙使配置文件生效  </span><br><span class="line">systemctl restart iptables.service</span><br></pre></td></tr></table></figure></p>
<p>最终版本：</p>
<p>启动docker并进行端口映射后，docker会在iptables中添加DNAT规则，将收到的对应端口的包转换ip并进行转发，同时添加规则将所有来自docker网域的ip进行转换。</p>
<p>但是在Centos7上出现docker可以正常访问外网，但是外网发出的请求在经过eth1接收转发后送达不到docker0，或者送到却出现（oui Unknown）的状况。暂时不清楚这到底是为什么经过DNAT后无法送达docker0.</p>
<p>最终解决办法是在启动docker后，重启iptables<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service iptables restart</span><br><span class="line">清空docker添加的所有规则，而后添加规则</span><br><span class="line"></span><br><span class="line">iptables -t nat -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br><span class="line">将所有来自docker的包172.17.0.0/16的ip替换为本机ip并发送，以达到docker访问外网的目的。</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>网络中的AS自洽域</title>
    <url>/2021/06/18/%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84AS%E8%87%AA%E6%B4%BD%E5%9F%9F/</url>
    <content><![CDATA[<p>最近在看stix协议，其中在SCO中有 Autonomous System (AS) Object这么一个对象，主要描述了AS自洽域相关的资料信息，小结下AS自洽域相关内容如下。</p>
<p><strong>什么是AS自治域？</strong></p>
<p>全球的互联网被分成很多个AS 自治域，每个国家的运营商、机构、甚至公司等都可以申请AS号码，AS号码是有限的，最大数目是65536。各自分配的IP地址被标清楚属于哪个AS号码，在全球互联网上，假如一封email从一个a IP地址发往另外一个b IP地址，这封email必须要知道a IP地址属于的AS号码A到b IP地址属于的AS号码 B如何走，然后就沿着这条路到达目的IP地址。在国外，尤其美国，很多公司都有自己的AS号码，也可能有好几个，而国内申请到的AS号码很少，仅是几个运营商持有，不超过30个。在IPv4的互联网时代，我们是弱势的。</p>
<p><strong>AS自治域与网络路由协议</strong></p>
<p>根据是否在一个自治域内部使用，动态路由协议分为内部网关协议（IGP: inner gateway protocol）和外部网关协议（EGP: Exterior Gateway Protocol）。自治域内部采用的路由选择协议称为内部网关协议，常用的有RIP、OSPF；外部网关协议主要用于多个自治域之间的路由选择，常用的是BGP和BGP-4。BGP是自治系统之间的路由选择协议，用于连接Internet。</p>
<ul>
<li>RIP（routing information protocol)路由信息协议</li>
<li>OSPF （open shortest path first）开放最短路径优先</li>
<li>BGP ( border gateway protocol ) 边界网关协议</li>
</ul>
<p><strong>如何获得AS自治域信息</strong></p>
<ul>
<li>某个特定的AS自治域信息：如<a href="http://www.cidr-report.org/cgi-bin/as-report?as=AS4777" target="_blank" rel="noopener">http://www.cidr-report.org/cgi-bin/as-report?as=AS4777</a></li>
<li>所有的AS自治域信息：<a href="http://www.cidr-report.org/as2.0/aggr.html" target="_blank" rel="noopener">http://www.cidr-report.org/as2.0/aggr.html</a></li>
</ul>
<p><strong>参考文献</strong></p>
<ol>
<li><a href="https://blog.csdn.net/ctwen/article/details/84775924" target="_blank" rel="noopener">https://blog.csdn.net/ctwen/article/details/84775924</a></li>
</ol>
]]></content>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>网络模型总结</title>
    <url>/2019/09/17/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>常用的五种网络IO模型是阻塞I/O，非阻塞I/O，I/O复用，事件(信号)驱动I/O，异步I/O。<br>为什么要发起系统调用？因为进程想要获取磁盘中的数据，而能和硬件打交道的只能是内核，进程通知内核说我要磁盘中的数据，此过程就是系统调用。<br>一次I/O的完成的步骤：当进程发起系统调用时，这个系统调用就进入内核模式，然后开始I/O操作。I/O操作分为两个步骤；<br>1、磁盘把数据装载到内核的内存空间，<br>2、内核的内存空间的数据copy到用户的内存空间中(此过程是I/O发生的地方)<br>以下是进程获取数据的详细图解过程；<br><img src="/2019/09/17/网络模型总结/net1.png" alt="avatar"><br>整个过程：此进程需要对磁盘中的数据进行操作，则会向内核发起一个系统调用，然后此进程，将会被切换出去，此进程会被挂起或者进入睡眠状态，也叫不可中断的睡眠，因为数据还没有得到，只有等到系统调用的结果完成后，则进程会被唤醒，继续接下来的操作，从系统调用的开始到系统调用结束经过的步骤：<br>①进程向内核发起一个系统调用，<br>②内核接收到系统调用，知道是对文件的请求，于是告诉磁盘，把文件读取出来<br>③磁盘接收到来着内核的命令后，把文件载入到内核的内存空间里面<br>④内核的内存空间接收到数据之后，把数据copy到用户进程的内存空间(此过程是I/O发生的地方)<br>⑤进程内存空间得到数据后，给内核发送通知<br>⑥内核把接收到的通知回复给进程，此过程为唤醒进程，然后进程得到数据，进行下一步操作<br>I/O发生的地方才会出现阻塞或非阻塞<br>阻塞：进程发起I/O调用，进程又不得不等待I/O的完成，此时CPU把进程切换出去，进程处于睡眠状态则此过程为阻塞I/O<br>阻塞I/O系统怎么通知进程？I/O完成，系统直接通知进程，则进程被唤醒</p>
<h4 id="阻塞IO（blocking-I-O）"><a href="#阻塞IO（blocking-I-O）" class="headerlink" title="阻塞IO（blocking I/O）"></a>阻塞IO（blocking I/O）</h4><p>在内核将数据准备好之前，系统调用会一直等待所有的套接字，默认的是阻塞方式。<br><img src="/2019/09/17/网络模型总结/net2.png" alt="avatar"></p>
<h4 id="非阻塞IO（noblocking-I-O）"><a href="#非阻塞IO（noblocking-I-O）" class="headerlink" title="非阻塞IO（noblocking I/O）"></a>非阻塞IO（noblocking I/O）</h4><p>每次客户询问内核是否有数据准备好，即文件描述符缓冲区是否就绪。当有数据报准备好时，就进行拷贝数据报的操作。当没有数据报准备好时，也不阻塞程序，内核直接返回未准备就绪的信号，等待用户程序的下一个轮寻。但是，轮寻对于CPU来说是较大的浪费，一般只有在特定的场景下才使用。<br><img src="/2019/09/17/网络模型总结/net3.png" alt="avatar"></p>
<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>IO多路转接是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理。<br><img src="/2019/09/17/网络模型总结/net4.png" alt="avatar"></p>
<h4 id="异步IO（asynchronous-I-O）"><a href="#异步IO（asynchronous-I-O）" class="headerlink" title="异步IO（asynchronous I/O）"></a>异步IO（asynchronous I/O）</h4><p>当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。<br>当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序。<br><img src="/2019/09/17/网络模型总结/net5.png" alt="avatar"></p>
<h4 id="阻塞、非阻塞，同步、异步"><a href="#阻塞、非阻塞，同步、异步" class="headerlink" title="阻塞、非阻塞，同步、异步"></a>阻塞、非阻塞，同步、异步</h4><p>关于同步和异步<br>同步和异步其实指的是，请求发起方对消息结果的获取是主动发起的，还是等被动通知的。如果是请求方主动发起的，一直在等待应答结果（同步阻塞），或者可以先去处理其他的事情，但要不断轮询查看发起的请求是否有应答结果（同步非阻塞 ）因为不管如何都要发起方主动获取消息结果，所以形式上还是同步操作。如果是由服务方通知的，也就是请求方发出请求后，要么在一直等待通知（异步阻塞），要么就先去干自己的事了（异步非阻塞），当事情处理完成之后，服务方会主动通知请求方，它的请求已经完成，这就是异步。异步通知的方式一般是通过状态改变，消息通知，或者回调函数来完成，大多数时候采用的都是回调函数。<br>关于阻塞和非阻塞<br>阻塞和非阻塞在计算机的世界里面，通常指的是针对IO的操作，如网络IO和磁盘IO等。那么什么是阻塞和非阻塞呢？简单的说就是我们调用了一个函数之后，在等待这个函数返回结果之前，当前的线程是处于挂起状态，还是运行状态，如果是挂起状态，就意味着当前线程什么都不能干，就等着获取结果，这就叫同步阻塞，如果仍然是运行状态，就意味当前线程是可以的继续处理其他任务，但要时不时的去看下是否有结果了，这就是同步非阻塞。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器与生成器</title>
    <url>/2021/06/11/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p><strong>生成器</strong></p>
<p>生成器本质上就是一个函数，它记住了上一次返回时在函数体中的位置。</p>
<p>对生成器函数的第二次（或第n次）调用，跳转到函数上一次挂起的位置。</p>
<p>而且记录了程序执行的上下文。</p>
<p>生成器不仅“记住”了它的数据状态，生成还记住了程序执行的位置。</p>
<p><strong>迭代器</strong></p>
<p>迭代器是一种支持next()操作的对象。它包含了一组元素，当执行next()操作时，返回其中一个元素。</p>
<p>当所有元素都被返回后，再执行next()报异常—StopIteration</p>
<p>生成器一定是可迭代的，也一定是迭代器对象</p>
<p><strong>区别</strong></p>
<ol>
<li>生成器是生成元素的，迭代器是访问集合元素的一种方式</li>
<li>迭代输出生成器的内容</li>
<li>迭代器是一种支持next()操作的对象</li>
<li>迭代器（iterator）：其中iterator对象表示的是一个数据流，可以把它看做一个有序序列，但我们不能提前知道序列的长度，只有通过nex()函数实现需要计算的下一个数据。可以看做生成器的一个子集。</li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发、高性能、高可用相关概念</title>
    <url>/2021/03/30/%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>通常是指，通过设计保证系统能够同时并行处理很多请求。 高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等。</p>
<ul>
<li>响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。</li>
<li>吞吐量：单位时间内处理的请求数量。</li>
<li>QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。</li>
<li>并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</li>
</ul>
<h3 id="如何提高并发能力"><a href="#如何提高并发能力" class="headerlink" title="如何提高并发能力"></a>如何提高并发能力</h3><ul>
<li>垂直扩展（Scale Up）</li>
</ul>
<ol>
<li>增强单机硬件性能（优先）：例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G。</li>
<li>提升单机架构性能：例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间。</li>
<li>总结：管是提升单机硬件性能，还是提升单机架构性能，都有一个致命的不足：单机性能总是有极限的。所以互联网分布式架构设计高并发终极解决方案还是水平扩展。</li>
</ol>
<ul>
<li>水平扩展（Scale Out）</li>
</ul>
<ol>
<li>只要增加服务器数量，就能线性扩充系统性能。水平扩展对系统架构设计是有要求的，难点在于：如何在架构各层进行可水平扩展的设计。</li>
</ol>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ol>
<li>简单的说，高性能（High Performance）就是指程序处理速度快，所占内存少，cpu占用率低。</li>
<li>高并发和高性能是紧密相关的，提高应用的性能，是肯定可以提高系统的并发能力的。</li>
<li>应用性能优化的时候，对于计算密集型和IO密集型还是有很大差别，需要分开来考虑。</li>
<li>增加服务器资源（CPU、内存、服务器数量），绝大部分时候是可以提高应用的并发能力和性能<br>（前提是应用能够支持多任务并行计算，多服务器分布式计算才行），但也是要避免其中的一些问题，才可以更好的更有效率的利用服务器资源。</li>
</ol>
<h3 id="提高性能的注意事项"><a href="#提高性能的注意事项" class="headerlink" title="提高性能的注意事项"></a>提高性能的注意事项</h3><ol>
<li>避免因为IO阻塞让CPU闲置，导致CPU的浪费。</li>
<li>避免多线程间增加锁来保证同步，导致并行系统串行化。</li>
<li>免创建、销毁、维护太多进程、线程，导致操作系统浪费资源在调度上。</li>
<li>避免分布式系统中多服务器的关联，比如：依赖同一个mysql，程序逻辑中使用分布式锁，导致瓶颈在mysql，分布式又变成串行化运算。</li>
</ol>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>高可用性（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性(一直都能用)。</p>
]]></content>
  </entry>
  <entry>
    <title>HashTree小结</title>
    <url>/2021/04/21/HashTree%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>哈希树（hash tree；Merkle tree），在密码学及计算机科学中是一种树形数据结构，每个叶节点均以数据块的哈希作为标签，而除了叶节点以外的节点则以其子节点标签的加密哈希作为标签 。哈希树能够高效、安全地验证大型数据结构的内容。哈希树的概念由瑞夫·墨克于 1979 年申请专利，故亦称墨克树（Merkle tree）。</p>
<p>Merkle 树的原理：</p>
<p>它使用的是单向哈希。哈希树的顶部为顶部哈希（top hash），亦称根哈希（root hash）或主哈希（master hash）。它是通过并联两个子哈希来往树上爬直到找到根哈希。单向哈希可以避免碰撞，而且由于它是确定性算法，因此不会也不可能存在两个一样的文本哈希。</p>
<h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><p><strong>质数分辨定理</strong></p>
<p>简单地说就是： n个不同的质数可以“分辨”的连续整数的个数和他们的乘积相等。“分辨”就是指这些连续的整数不可能有完全相同的余数序列。</p>
<p>在将一个数进行 Hash 的时候，对于数，当一个质数不够用的时候，可以加上第二个质数，用两个 mod 来确定该数据在库中的位置。那么这里需要简单的解释一下，对于一个质数 x，它的 mod 有 [ 0 … x - 1 ] x 种；所以对于两个质数 x 和 y，能存储的无一重复的数据有 x y 个，其实也就是开一个 xy 的二维数组。但是当数据极其多时，用两个质数去 mod 显然也是有不够的时候，就还要再加一个。<br>为了便于查找，选取最小的十个质数，也就是 2，3，5，7，11，13，17，23，29，31 来mod，能包括的数就有 10555815270 个，已经远超出 longint 了。<br>也就是说，如果我们开一个十维数组，那么取到一个数的效率就是 O( 1 )！但是那样显然太浪费空间了，就可以用到树。</p>
<p><img src="/2021/04/21/HashTree小结/hashtree1.png" alt="avatar"></p>
<p>同一节点中的子节点，从左到右代表不同的余数结果。<br>例如：第二层节点下有三个子节点。那么从左到右分别代表：除 3 余 0，除 3 余 1 和除 3 余 2。</p>
<p>对质数的余数决定了处理的路径。<br>例如：某个数来到第二层子节点，那么它要做取余操作，然后再决定从哪个子节点向下搜寻。如果这个数是 12 那么它需要从第一个子节点向下搜索；如果这个数是7那么它需要从第二个子节点向下搜索；如果这个数是32那么它需要从第三个子节点向下搜索。</p>
<p>这就是一个 HashTree 了。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>优点</li>
</ol>
<p><strong>结构简单</strong><br>从 HashTree 的结构来说，非常的简单。每层节点的子节点个数为连续的质数。子节点可以随时创建。因此 HashTree 的结构是动态的，也不像某些 Hash 算法那样需要长时间的初始化过程。HashTree 也没有必要为不存在的关键字提前分配空间。<br>需要注意的是 HashTree 是一个单向增加的结构，即随着所需要存储的数据量增加而增大。即使数据量减少到原来的数量，但是 HashTree 的总节点数不会减少。这样做的目的是为了避免结构的调整带来的额外消耗。</p>
<p><strong>查找迅速</strong><br>从算法过程我们可以看出，对于整数，HashTree 层级最多能增加到10。因此最多只需要十次取余和比较操作，就可以知道这个对象是否存在。这个在算法逻辑上决定了 HashTree 的优越性。<br>一般的树状结构，往往随着层次和层次中节点数的增加而导致更多的比较操作。操作次数可以说无法准确确定上限。而 HashTree 的查找次数和元素个数没有关系。如果元素的连续关键字总个数在计算机的整数（32bit）所能表达的最大范围内，那么比较次数就最多不会超过10次，通常低于这个数值。</p>
<p><strong>结构不变</strong><br>HashTree 在删除的时候，并不做任何结构调整。这个也是它的一个非常好的优点。常规树结构在增加元素和删除元素的时候都要做一定的结构调整，否则他们将可能退化为链表结构，而导致查找效率的降低。HashTree 采取的是一种“见缝插针”的算法，从来不用担心退化的问题，也不必为优化结构而采取额外的操作，因此大大节约了操作时间。</p>
<ol start="2">
<li>缺点</li>
</ol>
<p><strong>非排序性</strong><br>HashTree 不支持排序，没有顺序特性。如果在此基础上不做任何改进的话并试图通过遍历来实现排序，那么操作效率将远远低于其他类型的数据结构。</p>
<ol start="3">
<li>应用</li>
</ol>
<p>HashTree 可以广泛应用于那些需要对大容量数据进行快速匹配操作的地方。例如：数据库索引系统、短信息中的收条匹配、大量号码路由匹配、信息过滤匹配。HashTree 不需要额外的平衡和防止退化的操作，效率十分理想。</p>
<h4 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def hash_data(data, hash_function=&apos;sha256&apos;):</span><br><span class="line">    &quot;hash function&quot;</span><br><span class="line">    hash_function = getattr(hashlib, hash_function)</span><br><span class="line">    data = data.encode(&apos;utf-8&apos;)</span><br><span class="line">    return hash_function(data).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def concat_and_hash_list(lst, hash_function=&apos;sha256&apos;):</span><br><span class="line">    lst1 = []</span><br><span class="line">    for i in lst:</span><br><span class="line">        lst1.append(hash_data(i))</span><br><span class="line"></span><br><span class="line">    assert len(lst1) &gt; 2, &quot;no tracnsactions to be hashed&quot;</span><br><span class="line"></span><br><span class="line">    n = 0  # merkle树高度</span><br><span class="line">    while len(lst1) &gt; 1:</span><br><span class="line">        n += 1</span><br><span class="line">        if len(lst1) % 2 == 0:</span><br><span class="line">            v = []</span><br><span class="line">            while len(lst1) &gt; 1:</span><br><span class="line">                a = lst1.pop(0)</span><br><span class="line">                b = lst1.pop(0)</span><br><span class="line">                v.append(hash_data(a + b, hash_function))</span><br><span class="line">            lst1 = v</span><br><span class="line">        else:</span><br><span class="line">            v = []</span><br><span class="line">            l = lst1.pop(-1)</span><br><span class="line">            while len(lst1) &gt; 1:</span><br><span class="line">                a = lst1.pop(0)</span><br><span class="line">                b = lst1.pop(0)</span><br><span class="line">                v.append(hash_data(a + b, hash_function))</span><br><span class="line">            v.append(l)</span><br><span class="line">            lst1 = v</span><br><span class="line">    return lst1, n + 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    l = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &quot;d&quot;]</span><br><span class="line">    print(concat_and_hash_list(l))</span><br></pre></td></tr></table></figure>
<h4 id="jmeter中的HashTree"><a href="#jmeter中的HashTree" class="headerlink" title="jmeter中的HashTree"></a>jmeter中的HashTree</h4><p><strong>构造函数</strong></p>
<p>构造函数有多种形式：<br>HashTree(Map&lt;Object, HashTree&gt; _map, Object key)：若 HashTree 不为空则使用 HashTree，若 key 不为空则设为 top-level（root）节点，也可能是空。这个构造函数是最为主要的构造函数，它还有几个变形体都是调用它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Uses the new HashTree if not null and adds the given object as a</span><br><span class="line">     * top-level node if not null</span><br><span class="line">	 *</span><br><span class="line">     * 构造函数</span><br><span class="line">	 * 若HashTree不为空则使用HashTree</span><br><span class="line">	 * 若key不为空则设为top-level（root）节点，也可能是空。</span><br><span class="line">	 * 这个构造函数是最为主要的构造函数，它还有几个变形体都是调用它</span><br><span class="line">	 *</span><br><span class="line">     * @param _map</span><br><span class="line">     *            the map to be used. If &lt;code&gt;null&lt;/code&gt; a new &#123;@link HashMap&#125;</span><br><span class="line">     *            will be created</span><br><span class="line">     * @param key</span><br><span class="line">     *            the object to be used as the key for the root node (may be</span><br><span class="line">     *            &lt;code&gt;null&lt;/code&gt;, in which case no root node will be created)</span><br><span class="line">     */</span><br><span class="line">    private HashTree(Map&lt;Object, HashTree&gt; _map, Object key) &#123;</span><br><span class="line">        if(_map != null) &#123;</span><br><span class="line">            data = _map;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            data = new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        if(key != null) &#123;</span><br><span class="line">            data.put(key, new HashTree());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>traverseInto</strong></p>
<p>完成树遍历和执行的递归方法对 HashTreeTraverser 的回调。使用深度优先遍历 hashTree</p>
<p>traverse(HashTreeTraverser visitor)：允许 HashTreeTraverser 接口的任何实现轻松遍历（深度优先）HashTree 的所有节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Allows any implementation of the HashTreeTraverser interface to easily</span><br><span class="line">     * traverse (depth-first) all the nodes of the HashTree. The Traverser</span><br><span class="line">     * implementation will be given notification of each node visited.</span><br><span class="line">     *</span><br><span class="line">     * @see HashTreeTraverser</span><br><span class="line">     * @param visitor</span><br><span class="line">     *            the visitor that wants to traverse the tree</span><br><span class="line">     */</span><br><span class="line">    public void traverse(HashTreeTraverser visitor) &#123;</span><br><span class="line">        for (Object item : list()) &#123;</span><br><span class="line">            visitor.addNode(item, getTree(item));</span><br><span class="line">            getTree(item).traverseInto(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The recursive method that accomplishes the tree-traversal and performs</span><br><span class="line">     * the callbacks to the HashTreeTraverser.</span><br><span class="line">	 *</span><br><span class="line">	 * 完成树遍历和执行的递归方法对HashTreeTraverser的回调。使用深度优先遍历hashTree</span><br><span class="line">     *</span><br><span class="line">     * @param visitor</span><br><span class="line">     *            the &#123;@link HashTreeTraverser&#125; to be notified</span><br><span class="line">     */</span><br><span class="line">    private void traverseInto(HashTreeTraverser visitor) &#123;</span><br><span class="line">        if (list().isEmpty()) &#123;</span><br><span class="line">            visitor.processPath();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (Object item : list()) &#123;</span><br><span class="line">                final HashTree treeItem = getTree(item);</span><br><span class="line">                visitor.addNode(item, treeItem);</span><br><span class="line">                treeItem.traverseInto(visitor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visitor.subtractNode();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://steemit.com/blockchain/@susanli3769/merkle-tree" target="_blank" rel="noopener">https://steemit.com/blockchain/@susanli3769/merkle-tree</a></li>
<li><a href="https://blog.51cto.com/tianxingzhe/1720067" target="_blank" rel="noopener">https://blog.51cto.com/tianxingzhe/1720067</a></li>
<li><a href="https://blog.csdn.net/yang_yulei/article/details/46337405" target="_blank" rel="noopener">https://blog.csdn.net/yang_yulei/article/details/46337405</a></li>
<li><a href="https://blog.csdn.net/zuozewei/article/details/86748517" target="_blank" rel="noopener">https://blog.csdn.net/zuozewei/article/details/86748517</a></li>
<li><a href="https://github.com/jingyadong/merkle-tree-implementation/blob/main/merkle-tree.py" target="_blank" rel="noopener">https://github.com/jingyadong/merkle-tree-implementation/blob/main/merkle-tree.py</a></li>
</ol>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常</title>
    <url>/2020/03/01/Java%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h4 id="Exception和Error"><a href="#Exception和Error" class="headerlink" title="Exception和Error"></a>Exception和Error</h4><ol>
<li><p>异常基础<br>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。<br>Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。<br>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。<br>Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的Error，是 Throwable 不是 Exception。<br>不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。<br><img src="/2020/03/01/Java异常/java1.png" alt="avatar"><br>随着 Java 语言的发展，引入了一些更加便利的特性，比如 try-withresources和 multiple catch，具体可以参考下面的代码段。在编译时期，会自动生成相应的处理逻辑，比如，自动按照约定俗成 close 那些扩展了 AutoCloseable 或者 Closeable的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try (BufferedReader br = new BufferedReader(…);</span><br><span class="line">BufferedWriter writer = new BufferedWriter(…)) &#123;// Try-with-resources</span><br><span class="line">// do something</span><br><span class="line">catch ( IOException | XEception e) &#123;// Multiple catch</span><br><span class="line">// Handle it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>异常处理的两个基本原则</p>
</li>
</ol>
<ul>
<li>尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常</li>
<li>不要生吞（swallow）异常<br>有的时候，我们会根据需要自定义异常，这个时候除了保证提供足够的信息，还有两点需要考虑：</li>
<li>是否需要定义成 Checked Exception，因为这种类型设计的初衷更是为了从异常情况恢复，作为异常设计者，我们往往有充足信息进行分类。</li>
<li>在保证诊断信息足够的同时，也要考虑避免包含敏感信息，因为那样可能导致潜在的安全问题。如果我们看 Java 的标准类库，你可能注意到类似 java.net.ConnectException，出错信息是类似“ Connection refused (Connection refused)”，而不包含具体的机器名、IP、端口等，一个重要考量就是信息安全。类似的情况在日志中也有，比如，用户数据一般是不可以输出到日志里面的。</li>
</ul>
<h4 id="强引用、软引用、弱引用、幻象引用"><a href="#强引用、软引用、弱引用、幻象引用" class="headerlink" title="强引用、软引用、弱引用、幻象引用"></a>强引用、软引用、弱引用、幻象引用</h4><ul>
<li>不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。</li>
</ul>
<ol>
<li>强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</li>
<li>软引用（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li>
<li>弱引用（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</li>
<li>幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem清理机制，也有人利用幻象引用监控对象的创建和销毁。</li>
</ol>
<ul>
<li>对象可达性<br>简单描述了对象生命周期和不同可达性状态，以及不同状态可能的改变关系，可能未必 100% 严谨，来阐述下可达性的变化。<br><img src="/2020/03/01/Java异常/java2.png" alt="avatar"></li>
</ul>
<ol>
<li>强可达（Strongly Reachable），就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新创建一个对象，那么创建它的线程对它就是强可达。</li>
<li>软可达（Softly Reachable），就是当我们只能通过软引用才能访问到对象的状态。</li>
<li>弱可达（Weakly Reachable），类似前面提到的，就是无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。这是十分临近finalize 状态的时机，当弱引用被清除的时候，就符合 finalize 的条件了。</li>
<li>幻象可达（Phantom Reachable），上面流程图已经很直观了，就是没有强、软、弱引用关联，并且 finalize 过了，只有幻象引用指向这个对象的时候。</li>
<li>当然，还有一个最后的状态，就是不可达（unreachable），意味着对象可以被清除了。<br>判断对象可达性，是 JVM 垃圾收集器决定如何处理对象的一部分考虑。所有引用类型，都是抽象类 java.lang.ref.Reference 的子类，你可能注意到它提供了 get()方法：<br><img src="/2020/03/01/Java异常/java3.png" alt="avatar"><br>除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过 get 方法获取原有对象。这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态！所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。</li>
</ol>
<ul>
<li><p>引用队列（ReferenceQueue）使用<br>在创建各种引用并关联到响应对象时，可以选择是否需要关联引用队列，JVM 会在特定时机将引用 enqueue 到队列里，可以从队列里获取引用（remove 方法在这里实际是有获取的意思）进行相关后续逻辑。尤其是幻象引用，get 方法只返回 null，如果再不指定引用队列，基本就没有意义了。利用引用队列，我们可以在对象处于相应状态时（对于幻象引用，就是前面说的被 finalize 了，处于幻象可达状态），执行后期处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object counter = new Object();</span><br><span class="line">ReferenceQueue refQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; p = new PhantomReference&lt;&gt;(counter, refQueue);</span><br><span class="line">counter = null;</span><br><span class="line">System.gc();</span><br><span class="line">try &#123;</span><br><span class="line">// Remove 是一个阻塞方法，可以指定 timeout，或者选择一直阻塞</span><br><span class="line">Reference&lt;Object&gt; ref = refQueue.remove(1000L);</span><br><span class="line">if (ref != null) &#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">// Handle it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显式地影响软引用垃圾收集<br>软引用通常会在最后一次引用后，还能保持一段时间，默认值是根据堆剩余空间计算的（以 M bytes 为单位）。从 Java 1.3.1 开始，提供了 -<br>XX:SoftRefLRUPolicyMSPerMB 参数，我们可以以毫秒（milliseconds）为单位设置。比如，下面这个示例就是设置为 3 秒（3000 毫秒）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:SoftRefLRUPolicyMSPerMB=3000</span><br></pre></td></tr></table></figure>
</li>
<li><p>诊断 JVM 引用情况<br>HotSpot JVM 自身便提供了明确的选项（PrintReferenceGC）去获取相关信息，我指定了下面选项去使用 JDK 8 运行一个样例应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintReferenceGC</span><br><span class="line">这是 JDK 8 使用 ParrallelGC 收集的垃圾收集日志，各种引用数量非常清晰。</span><br><span class="line">1 0.403: [GC (Allocation Failure) 0.871: [SoftReference, 0 refs, 0.0000393 secs]0.871: </span><br><span class="line">JDK 9 对 JVM 和垃圾收集日志进行了广泛的重构，类似 PrintGCTimeStamps 和PrintReferenceGC 已经不再存在</span><br></pre></td></tr></table></figure>
</li>
<li><p>Reachability Fence<br>除了前面介绍的几种基本引用类型，我们也可以通过底层 API 来达到强引用的效果，这就是所谓的设置reachability fence。需要一个方法，在没有强引用情况下，通知 JVM 对象是在被使用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Resource &#123;</span><br><span class="line">private static ExternalResource[] externalResourceArray = ...</span><br><span class="line">int myIndex; Resource(...) &#123;</span><br><span class="line">myIndex = ...</span><br><span class="line">externalResourceArray[myIndex] = ...;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">protected void finalize() &#123;</span><br><span class="line">externalResourceArray[myIndex] = null;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">public void action() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// 需要被保护的代码</span><br><span class="line">int i = myIndex;</span><br><span class="line">Resource.update(externalResourceArray[i]);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">// 调用 reachbilityFence，明确保障对象 strongly reachable</span><br><span class="line">Reference.reachabilityFence(this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private static void update(ExternalResource ext) &#123;</span><br><span class="line">ext.status = ...;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">方法 action 的执行，依赖于对象的部分属性，所以被特定保护了起来。否则，如果我们在代码中像下面这样调用，那么就可能会出现困扰，因为没有强引用指向我们创建出来的Resource 对象，JVM 对它进行 finalize 操作是完全合法的。</span><br><span class="line">参考地址：https://docs.oracle.com/javase/9/docs/api/java/lang/ref/Reference.html#reachabilityFence-java.lang.Object-</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内部类</title>
    <url>/2021/07/12/Java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>在看python闭包和装饰器的过程中，想起了Java内部类这块。小记下内部类的知识点。</p>
<h4 id="内部类分类"><a href="#内部类分类" class="headerlink" title="内部类分类"></a>内部类分类</h4><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p>
<p><strong>1. 成员内部类</strong></p>
<p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    double radius = 0;</span><br><span class="line">     </span><br><span class="line">    public Circle(double radius) &#123;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    class Draw &#123;     //内部类</span><br><span class="line">        public void drawSahpe() &#123;</span><br><span class="line">            System.out.println(&quot;drawshape&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    private double radius = 0;</span><br><span class="line">    public static int count =1;</span><br><span class="line">    public Circle(double radius) &#123;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    class Draw &#123;     //内部类</span><br><span class="line">        public void drawSahpe() &#123;</span><br><span class="line">            System.out.println(radius);  //外部类的private成员</span><br><span class="line">            System.out.println(count);   //外部类的静态成员</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">外部类.this.成员变量</span><br><span class="line">外部类.this.成员方法</span><br></pre></td></tr></table></figure>
<p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    private double radius = 0;</span><br><span class="line"> </span><br><span class="line">    public Circle(double radius) &#123;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();   //必须先创建成员内部类的对象，再进行访问</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    private Draw getDrawInstance() &#123;</span><br><span class="line">        return new Draw();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    class Draw &#123;     //内部类</span><br><span class="line">        public void drawSahpe() &#123;</span><br><span class="line">            System.out.println(radius);  //外部类的private成员</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        //第一种方式：</span><br><span class="line">        Outter outter = new Outter();</span><br><span class="line">        Outter.Inner inner = outter.new Inner();  //必须通过Outter对象来创建</span><br><span class="line">         </span><br><span class="line">        //第二种方式：</span><br><span class="line">        Outter.Inner inner1 = outter.getInnerInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Outter &#123;</span><br><span class="line">    private Inner inner = null;</span><br><span class="line">    public Outter() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Inner getInnerInstance() &#123;</span><br><span class="line">        if(inner == null)</span><br><span class="line">            inner = new Inner();</span><br><span class="line">        return inner;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    class Inner &#123;</span><br><span class="line">        public Inner() &#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p>
<p><strong>2.局部内部类</strong></p>
<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class People&#123;</span><br><span class="line">    public People() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Man&#123;</span><br><span class="line">    public Man()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public People getWoman()&#123;</span><br><span class="line">        class Woman extends People&#123;   //局部内部类</span><br><span class="line">            int age =0;</span><br><span class="line">        &#125;</span><br><span class="line">        return new Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<p><strong>3.匿名内部类</strong></p>
<p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scan_bt.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">             </span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                // TODO Auto-generated method stub</span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         </span><br><span class="line">        history_bt.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">             </span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                // TODO Auto-generated method stub</span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new OnClickListener() &#123;</span><br><span class="line">             </span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                // TODO Auto-generated method stub</span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void setListener()</span><br><span class="line">&#123;</span><br><span class="line">    scan_bt.setOnClickListener(new Listener1());       </span><br><span class="line">    history_bt.setOnClickListener(new Listener2());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Listener1 implements View.OnClickListener&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Listener2 implements View.OnClickListener&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。</p>
<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<p><strong>4. 静态内部类</strong></p>
<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        Outter.Inner inner = new Outter.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Outter &#123;</span><br><span class="line">    public Outter() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    static class Inner &#123;</span><br><span class="line">        public Inner() &#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/12/Java内部类/class.png" alt="avatar"></p>
<h4 id="内部类的使用场景和好处"><a href="#内部类的使用场景和好处" class="headerlink" title="内部类的使用场景和好处"></a>内部类的使用场景和好处</h4><p>为什么在Java中需要内部类？总结一下主要有以下四点：</p>
<ol>
<li>每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，</li>
<li>方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。</li>
<li>方便编写事件驱动程序</li>
<li>方便编写线程代码</li>
</ol>
<p>其中第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3811445.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查看硬件信息常用命令</title>
    <url>/2021/04/16/Linux%E6%9F%A5%E7%9C%8B%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="1-lscpu"><a href="#1-lscpu" class="headerlink" title="1. lscpu"></a>1. lscpu</h3><pre><code>用于查询CPU信息
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@node105 ~]# lscpu </span><br><span class="line">Architecture:          x86_64                      #CPU架构</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit             </span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                20                          #逻辑cpu颗数</span><br><span class="line">On-line CPU(s) list:   0-19                        </span><br><span class="line">Thread(s) per core:    1                            #每个CPU插槽核数/每颗物理CPU核数</span><br><span class="line">Core(s) per socket:    10                            </span><br><span class="line">Socket(s):             2</span><br><span class="line">NUMA node(s):          2</span><br><span class="line">Vendor ID:             GenuineIntel                #CPU厂商ID</span><br><span class="line">CPU family:            6                            </span><br><span class="line">Model:                 79                     </span><br><span class="line">Model name:            Intel(R) Xeon(R) CPU E5-2620 v4 @ 2.10GHz</span><br><span class="line">Stepping:              1</span><br><span class="line">CPU MHz:               2095.148                    #CPU主频</span><br><span class="line">BogoMIPS:              4190.29</span><br><span class="line">Hypervisor vendor:     VMware</span><br><span class="line">Virtualization type:   full                        #CPU支持的虚拟化技术</span><br><span class="line">L1d cache:             32K                         #一级缓存。cpu的L1数据缓存</span><br><span class="line">L1i cache:             32K                         #一级缓存，L1指令缓存</span><br><span class="line">L2 cache:              256K                        #二级缓存</span><br><span class="line">L3 cache:              20480K                      #三级缓存</span><br><span class="line">NUMA node0 CPU(s):     0-9</span><br><span class="line">NUMA node1 CPU(s):     10-19</span><br><span class="line">Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc aperfmperf eagerfpu pni pclmulqdq ssse3 fma cx16 sse4_1 sse4_2 movbe popcnt aes xsave avx hypervisor lahf_lm 3dnowprefetch epb cat_l3 cdp_l3 xsaveopt cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local dtherm ida arat pln pts</span><br><span class="line">[root@node105 ~]#</span><br></pre></td></tr></table></figure>
<h3 id="2-lshw"><a href="#2-lshw" class="headerlink" title="2. lshw"></a>2. lshw</h3><p> 用于显示硬件信息表</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> description: Computer</span><br><span class="line">    product: 6ffc6a2a-bf81-47f7-aac4-601e5655113f</span><br><span class="line">    vendor: QEMU</span><br><span class="line">    version: Standard</span><br><span class="line">    width: 64 bits</span><br><span class="line">    capabilities: smbios-2.8 dmi-2.8 smp vsyscall32</span><br><span class="line">    configuration: boot=normal family=Virtual Machine uuid=2A6AFC6F-81BF-F747-AAC4-601E5655113F</span><br><span class="line">  *-core</span><br><span class="line">       description: Motherboard</span><br><span class="line">       physical id: 0</span><br><span class="line">     *-firmware</span><br><span class="line">          description: BIOS</span><br><span class="line">          vendor: SeaBIOS</span><br><span class="line">          physical id: 0</span><br><span class="line">          version: seabios-1.7.5-11.el7</span><br><span class="line">          date: 04/01/2014</span><br><span class="line">          size: 96KiB</span><br><span class="line">     *-cpu:0</span><br><span class="line">          description: CPU</span><br><span class="line">          product: Intel(R) Xeon(R) Silver 4114 CPU @ 2.20GHz</span><br><span class="line">          vendor: Intel Corp.</span><br><span class="line">          vendor_id: GenuineIntel</span><br><span class="line">          physical id: 400</span><br><span class="line">          bus info: cpu@0</span><br><span class="line">          version: RHEL 7.3.0 PC (i440FX + PIIX, 1996)</span><br><span class="line">          slot: CPU 0</span><br><span class="line">          size: 2GHz</span><br><span class="line">          capacity: 2GHz</span><br><span class="line">          width: 64 bits</span><br><span class="line">          capabilities: fpu fpu_exception wp vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp x86-64 con</span><br><span class="line">stant_tsc arch_perfmon rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm</span><br><span class="line">abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xge</span><br><span class="line">tbv1 arat</span><br><span class="line">          configuration: cores=1 enabledcores=1 threads=1</span><br><span class="line">     *-cpu:1</span><br><span class="line">          description: CPU</span><br><span class="line">          product: Intel(R) Xeon(R) Silver 4114 CPU @ 2.20GHz</span><br><span class="line">          vendor: Intel Corp.</span><br><span class="line">          vendor_id: GenuineIntel</span><br><span class="line">          physical id: 401</span><br><span class="line">          bus info: cpu@1</span><br><span class="line">          version: RHEL 7.3.0 PC (i440FX + PIIX, 1996)</span><br><span class="line">          slot: CPU 1</span><br></pre></td></tr></table></figure>
<h3 id="3-lsblk"><a href="#3-lsblk" class="headerlink" title="3. lsblk"></a>3. lsblk</h3><p> 用于列出块设备的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@xxx ~]# lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0  400G  0 disk</span><br><span class="line">└─sda1   8:1    0  400G  0 part /</span><br><span class="line">loop0    7:0    0  918M  0 loop /mnt/cdrom</span><br></pre></td></tr></table></figure>
<h3 id="4-lsscsi"><a href="#4-lsscsi" class="headerlink" title="4. lsscsi"></a>4. lsscsi</h3><p>用于列出SCSI的设备信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@xxx ~]# lsscsi</span><br><span class="line">[2:0:0:0]    disk    QEMU     QEMU HARDDISK    2.5+  /dev/sda</span><br></pre></td></tr></table></figure>
<h3 id="5-fdisk"><a href="#5-fdisk" class="headerlink" title="5. fdisk"></a>5. fdisk</h3><p>看硬盘和分区的详细信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sda：429.5 GB, 429496729600 字节，838860800 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x000a0d6e</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048   838860766   419429359+  83  Linux</span><br><span class="line"></span><br><span class="line">磁盘 /dev/loop0：962 MB, 962592768 字节，1880064 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x104bed34</span><br><span class="line"></span><br><span class="line">      设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/loop0p1   *           0     1880063      940032    0  Empty</span><br><span class="line">/dev/loop0p2             440       17847        8704   ef  EFI (FAT-12/16/32)</span><br></pre></td></tr></table></figure>
<h3 id="6-ethtool"><a href="#6-ethtool" class="headerlink" title="6. ethtool"></a>6. ethtool</h3><p>查看某个网络接口的详细信息，例如eth0的详细参数和指标 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@kafka116 ~]# ethtool enp7s0f0          #注意，这里的enp7s0f0是网卡的名称</span><br><span class="line">Settings for enp7s0f0:</span><br><span class="line">        Supported ports: [ TP ]</span><br><span class="line">        Supported link modes:   100baseT/Full </span><br><span class="line">                                1000baseT/Full </span><br><span class="line">                                10000baseT/Full     #支持万兆全双工模式</span><br><span class="line">        Supported pause frame use: Symmetric</span><br><span class="line">        Supports auto-negotiation: Yes              #支持自适应模式，一般都支持</span><br><span class="line">        Supported FEC modes: Not reported</span><br><span class="line">        Advertised link modes:  100baseT/Full </span><br><span class="line">                                1000baseT/Full </span><br><span class="line">                                10000baseT/Full </span><br><span class="line">        Advertised pause frame use: Symmetric</span><br><span class="line">        Advertised auto-negotiation: Yes            #默认使用自适应模式</span><br><span class="line">        Advertised FEC modes: Not reported</span><br><span class="line">        Speed: 10000Mb/s                          #现在网卡的速度是万兆Mb/s,</span><br><span class="line">        Duplex: Full　　　　　　　　　　　　　　　　　　#当前是全双工模式</span><br><span class="line">        Port: Twisted Pair</span><br><span class="line">        PHYAD: 0</span><br><span class="line">        Transceiver: internal</span><br><span class="line">        Auto-negotiation: on</span><br><span class="line">        MDI-X: Unknown</span><br><span class="line">        Supports Wake-on: umbg</span><br><span class="line">        Wake-on: g</span><br><span class="line">        Current message level: 0x00000007 (7)</span><br><span class="line">                               drv probe link</span><br><span class="line">        Link detected: yes                        #表示有网线连接，和路由是通的，这可以使用“ifconfig”或者“ip a”查看操作系统中网卡的是否是UP状态。</span><br><span class="line">[root@kafka116 ~]#</span><br></pre></td></tr></table></figure>
<h3 id="7-dmidecode"><a href="#7-dmidecode" class="headerlink" title="7. dmidecode"></a>7. dmidecode</h3><p>一种可读的方式dump出机器的DMI(Desktop Management Interface)信息。这些信息包括了硬件以及BIOS，既可以得到当前的配置，也可以得到系统支持的最大配置，比如说支持的最大内存数等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@kafka116 ~]# dmidecode -t bios           #查看bios信息</span><br><span class="line"># dmidecode 3.0</span><br><span class="line">Getting SMBIOS data from sysfs.</span><br><span class="line">SMBIOS 3.0 present.</span><br><span class="line"></span><br><span class="line">Handle 0x0000, DMI type 0, 24 bytes</span><br><span class="line">BIOS Information</span><br><span class="line">        Vendor: American Megatrends Inc.</span><br><span class="line">        Version: 4.1.16</span><br><span class="line">        Release Date: 06/21/2018</span><br><span class="line">        Address: 0xF0000</span><br><span class="line">        Runtime Size: 64 kB</span><br><span class="line">        ROM Size: 8192 kB</span><br><span class="line">        Characteristics:</span><br><span class="line">                PCI is supported</span><br><span class="line">                BIOS is upgradeable</span><br><span class="line">                BIOS shadowing is allowed</span><br><span class="line">                Boot from CD is supported</span><br><span class="line">                Selectable boot is supported</span><br><span class="line">                BIOS ROM is socketed</span><br><span class="line">                EDD is supported</span><br><span class="line">                5.25&quot;/1.2 MB floppy services are supported (int 13h)</span><br><span class="line">                3.5&quot;/720 kB floppy services are supported (int 13h)</span><br><span class="line">                3.5&quot;/2.88 MB floppy services are supported (int 13h)</span><br><span class="line">                Print screen service is supported (int 5h)</span><br><span class="line">                Serial services are supported (int 14h)</span><br><span class="line">                Printer services are supported (int 17h)</span><br><span class="line">                ACPI is supported</span><br><span class="line">                USB legacy is supported</span><br><span class="line">                BIOS boot specification is supported</span><br><span class="line">                Targeted content distribution is supported</span><br><span class="line">                UEFI is supported</span><br><span class="line">        BIOS Revision: 5.6</span><br><span class="line"></span><br><span class="line">Handle 0x0066, DMI type 13, 22 bytes</span><br><span class="line">BIOS Language Information</span><br><span class="line">        Language Description Format: Long</span><br><span class="line">        Installable Languages: 1</span><br><span class="line">                en|US|iso8859-1</span><br><span class="line">        Currently Installed Language: en|US|iso8859-1</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础数据类型</title>
    <url>/2020/02/15/Python%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>数字、字符串、列表、元组、字典、集合</p>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><ul>
<li>python整数不分类型，或者说它只有一种类型的整数。Python 整数的取值范围是无限的，不管多大或者多小的数字，Python 都能轻松处理。<br>当所用数值超过计算机自身的计算能力时，Python 会自动转用高精度计算（大数计算）。</li>
<li>python 只有一种小数类型，就是 float。</li>
<li>复数（Complex）是python的内置类型，直接书写即可。换句话说，Python 语言本身就支持复数，而不依赖于标准库或者第三方库。复数由实部（real）和虚部（imag）构成，在Python中，复数的虚部以j或者j作为后缀。</li>
<li>布尔值型bool 　真 1 True,假 0 False</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串是由独立字符组成的一个序列，通常包含在单引号（’’）双引号（””）或者三引号之中（’’’ ‘’’或””” “””，两者一样）<br><img src="/2020/02/15/Python基础数据类型/python1.png" alt="avatar"></p>
<ul>
<li>常用操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># capitalize / swapcase / title</span><br><span class="line">name = &apos;sunShine&apos;</span><br><span class="line">msg = &apos;hello world&apos;</span><br><span class="line">print(name.capitalize()) # 首字母大写,其它小写 Sunshine</span><br><span class="line">print(name.swapcase())  #大小写反转 SUNHINE</span><br><span class="line">print(msg.title()) # 每个单词首字母大写 Hello World</span><br><span class="line"></span><br><span class="line">#内同居中，总长度，空白处填充</span><br><span class="line">res1 = name.center(20,&apos;*&apos;)</span><br><span class="line">print(res1) # ******sunhine*******</span><br><span class="line"></span><br><span class="line"># 字符串中的元素出现的个数</span><br><span class="line">res2 = name.count(&quot;n&quot;,0,7)  # 在0到7个字符间出现n的次数</span><br><span class="line">print(res2) # 2</span><br><span class="line"></span><br><span class="line">a2 = &quot;hqw\t&quot;</span><br><span class="line">res3 = a2.expandtabs() # 默认将一个tab键编程8个空格，如果tab前面的字符长度不足8位，则补全8个，</span><br><span class="line"># 如果超过8个但是不足16个，则补全至16位，以此类推。</span><br><span class="line">print(len(res3))  # 8</span><br><span class="line"></span><br><span class="line"># startswith / endswith</span><br><span class="line">print(name.startswith(&apos;S&apos;)) # 判断name是否以S为开头,返回布尔值 #False</span><br><span class="line">print(name.endswith(&apos;e&apos;)) # 判断name是否以e为结尾,返回布尔值 # True</span><br><span class="line">print(name,name.endswith(&apos;hi&apos;,4,6))</span><br><span class="line">print(name,name.startswith(&apos;Sh&apos;,3,6))</span><br><span class="line"></span><br><span class="line"># find / index</span><br><span class="line">res4 = name.find(&apos;un&apos;,1,6) # 在索引1，6之间匹配，不写默认是全部匹配</span><br><span class="line">print(res4) # 匹配结果则为1， 不匹配结果为 -1</span><br><span class="line">res5 = name.index(&apos;i&apos;,3,7)</span><br><span class="line">print(res5)  # 返回找到的元素的索引，找不到则报错。ValueError: substring not found # 5</span><br><span class="line"></span><br><span class="line"># split / rsplit 以某个内容分隔，最终形成一个列表，此列表中不含有这个分割的元素</span><br><span class="line">res6 = &apos;title,Title,test&apos;</span><br><span class="line">print(res6.split(&apos;t&apos;)) #以t为分割,[&apos;&apos;, &apos;i&apos;, &apos;le,Ti&apos;, &apos;le,&apos;, &apos;es&apos;, &apos;&apos;]</span><br><span class="line">print(res6.rsplit(&apos;t&apos;,1)) # 按由右向左的顺序，只将第一个匹配到的分割[&apos;title,Title,tes&apos;, &apos;&apos;]</span><br><span class="line"></span><br><span class="line"># format 格式化输出</span><br><span class="line">print(&apos;&#123;&#125; &#123;&#125; &#123;&#125;&apos;.format(&apos;sunshine&apos;,28,&apos;male&apos;))  #sunshine 28 male</span><br><span class="line">print(&apos;&#123;1&#125; &#123;0&#125; &#123;1&#125;&apos;.format(&apos;sunshine&apos;,28)) #28 sunshine 28</span><br><span class="line">print(&apos;&#123;name&#125; &#123;age&#125; &#123;sex&#125;&apos;.format(name=&apos;sunshine&apos;,age=28,sex=&apos;male&apos;)) #sunshine 28 male</span><br><span class="line"></span><br><span class="line"># strip 一般用来去空</span><br><span class="line">name=&apos;*sunshine**&apos;</span><br><span class="line">print(name.strip(&apos;*&apos;)) #sunshine   去除所有的*</span><br><span class="line">print(name.lstrip(&apos;*&apos;)) #sunshine** 去除左边的*</span><br><span class="line">print(name.rstrip(&apos;*&apos;)) #*sunshine  去除右边的*</span><br><span class="line"></span><br><span class="line"># replace  将匹配的元素替换为新的元素</span><br><span class="line">name = &apos;sunshine say :i am a good boy!&apos;</span><br><span class="line">print(name.replace(&apos;sunshine&apos;,&apos;SS&apos;))</span><br><span class="line"></span><br><span class="line"># is</span><br><span class="line">name = &apos;sunshine123&apos;</span><br><span class="line">print(name.isalnum()) # 判断字符串是否由字母或者数字组成，返回布尔值 True</span><br><span class="line">print(name.isalpha()) # 判断字符串是否由纯字母组成，返回布尔值  False</span><br><span class="line">print(name.isdigit()) # 判断字符串是否由纯数字组成，返回布尔值  False</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># string.capitalize()                                  #把字符串的第一个字符大写</span><br><span class="line"># string.center(width)                                 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</span><br><span class="line"># string.count(str, beg=0, end=len(string))            返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</span><br><span class="line"># string.decode(encoding=&apos;UTF-8&apos;, errors=&apos;strict&apos;)     以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除 非 errors 指 定 的 是 &apos;ignore&apos; 或 者&apos;replace&apos;</span><br><span class="line"># string.encode(encoding=&apos;UTF-8&apos;, errors=&apos;strict&apos;)     以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是&apos;ignore&apos;或者&apos;replace&apos;</span><br><span class="line"># string.endswith(obj, beg=0, end=len(string))         检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</span><br><span class="line"># string.expandtabs(tabsize=8)                         把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。</span><br><span class="line"># string.find(str, beg=0, end=len(string))             检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</span><br><span class="line"># string.index(str, beg=0, end=len(string))            跟find()方法一样，只不过如果str不在 string中会报一个异常.</span><br><span class="line"># string.isalnum()                                     如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</span><br><span class="line"># string.isalpha()                                     如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False</span><br><span class="line"># string.isdecimal()                                   如果 string 只包含十进制数字则返回 True 否则返回 False.</span><br><span class="line"># string.isdigit()                                     如果 string 只包含数字则返回 True 否则返回 False.</span><br><span class="line"># string.islower()                                     如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</span><br><span class="line"># string.isnumeric()                                   如果 string 中只包含数字字符，则返回 True，否则返回 False</span><br><span class="line"># string.isspace()                                     如果 string 中只包含空格，则返回 True，否则返回 False.</span><br><span class="line"># string.istitle()                                     如果 string 是标题化的(见 title())则返回 True，否则返回 False</span><br><span class="line"># string.isupper()                                     如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</span><br><span class="line"># string.join(seq)                                     以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</span><br><span class="line"># string.ljust(width)                                  返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</span><br><span class="line"># string.lower()                                       转换 string 中所有大写字符为小写.</span><br><span class="line"># string.lstrip()                                      截掉 string 左边的空格</span><br><span class="line"># string.maketrans(intab, outtab])                     maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</span><br><span class="line"># max(str)                                             返回字符串 str 中最大的字母。</span><br><span class="line"># min(str)                                             返回字符串 str 中最小的字母。</span><br><span class="line"># string.partition(str)                                有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string.</span><br><span class="line"># string.replace(str1, str2,  num=string.count(str1))  把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</span><br><span class="line"># string.rfind(str, beg=0,end=len(string) )            类似于 find()函数，不过是从右边开始查找.</span><br><span class="line"># string.rindex( str, beg=0,end=len(string))           类似于 index()，不过是从右边开始.</span><br><span class="line"># string.rjust(width)                                  返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</span><br><span class="line"># string.rpartition(str)                               类似于 partition()函数,不过是从右边开始查找.</span><br><span class="line"># string.rstrip()                                      删除 string 字符串末尾的空格.</span><br><span class="line"># string.split(str=&quot;&quot;, num=string.count(str))          以 str 为分隔符切片 string，如果 num有指定值，则仅分隔 num 个子字符串</span><br><span class="line"># string.splitlines(num=string.count(&apos;\n&apos;))            按照行分隔，返回一个包含各行作为元素的列表，如果 num 指定则仅切片 num 个行.</span><br><span class="line"># string.startswith(obj, beg=0,end=len(string))        检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</span><br><span class="line"># string.strip([obj])                                  在 string 上执行 lstrip()和 rstrip()</span><br><span class="line"># string.swapcase()                                    翻转 string 中的大小写</span><br><span class="line"># string.title()                                       返回&quot;标题化&quot;的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</span><br><span class="line"># string.translate(str, del=&quot;&quot;)                        根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中</span><br><span class="line"># string.upper()                                       转换 string 中的小写字母为大写</span><br></pre></td></tr></table></figure>
<h3 id="元组-amp-列表"><a href="#元组-amp-列表" class="headerlink" title="元组 &amp; 列表"></a>元组 &amp; 列表</h3><ul>
<li>元组也称为只读列表，数据只可以被查询，不能被修改。字符串的切片操作同样适用于列表。列表用（）标示，黎明的元素用逗号隔开。如（1，2，3)</li>
<li>列表是python的基础数据类型之一，是用[]括起来，每个元素以逗号隔开，里面可以存放各种数据类型。如：li = [‘sunshine’,18,{‘hobby’:’eat’},[1,2,3]]。列表还可以储存大量数据，32位python的限制是536870912个元素，64位python的限制是1152921504606846975 个元素。列表是有序的，有索引值，可以切片，方便取值。</li>
<li>列表和元组的存储方式的差异<br>1 由于列表是动态的，所以它需要存储指针，来指向对应的元素（上述例子中，对于int 型，8 字节）。另外，由于列表可变，所以需要额外存储已经分配的长度大小（8 字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。，Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)。<br>2 元组长度大小固定，元素不可变，所以存储空间固定。</li>
<li>列表和元组的区别<br>1 列表是动态的，长度可变，可以随意的增加、删减或改变元素。列表的存储空间略大于元组，性能略逊于元组。<br>2 元组是静态的，长度大小固定，不可以对元素进行增加、删减或者改变操作。元组相对于列表更加轻量级，性能稍优。</li>
<li>列表和元组的使用场景<br>1 如果存储的数据和数量不变，比如你有一个函数，需要返回的是一个地点的经纬度，然后直接传给前端渲染，那么肯定选用元组更合适。<br>2 如果存储的数据或数量是可变的，比如社交平台上的一个日志功能，是统计一个用户在一周之内看了哪些用户的帖子，那么则用列表更合适。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># insert / append / extend</span><br><span class="line">li = [1,&apos;a&apos;,&apos;b&apos;,2,3,&apos;a&apos;]</span><br><span class="line">li.insert(0,55) # 按索引增加个55的值 #[55, 1, &apos;a&apos;, &apos;b&apos;, 2, 3, &apos;a&apos;]</span><br><span class="line">li.append(&apos;c&apos;)# 增加到最后 [55, 1, &apos;a&apos;, &apos;b&apos;, 2, 3, &apos;a&apos;, &apos;c&apos;]</span><br><span class="line">li.append([1,2,3])#[55, 1, &apos;a&apos;, &apos;b&apos;, 2, 3, &apos;a&apos;, &apos;c&apos;, [1, 2, 3]]</span><br><span class="line">li.extend([&apos;a,b,c&apos;]) # 迭代的去增加元素 [55, 1, &apos;a&apos;, &apos;b&apos;, 2, 3, &apos;a&apos;, &apos;c&apos;, [1, 2, 3], &apos;a,b,c&apos;]</span><br><span class="line">li.extend([&apos;a,b&apos;,&apos;ccc&apos;]) # [55, 1, &apos;a&apos;, &apos;b&apos;, 2, 3, &apos;a&apos;, &apos;c&apos;, [1, 2, 3], &apos;a,b,c&apos;, &apos;a,b&apos;, &apos;ccc&apos;]</span><br><span class="line">li.extend(&apos;aaa&apos;) #[55, 1, &apos;a&apos;, &apos;b&apos;, 2, 3, &apos;a&apos;, &apos;c&apos;, [1, 2, 3], &apos;a,b,c&apos;, &apos;a,b&apos;, &apos;ccc&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;]</span><br><span class="line">li.extend(&apos;b,b&apos;)#[55, 1, &apos;a&apos;, &apos;b&apos;, 2, 3, &apos;a&apos;, &apos;c&apos;, [1, 2, 3], &apos;a,b,c&apos;, &apos;a,b&apos;, &apos;ccc&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;,&apos;, &apos;b&apos;]</span><br><span class="line">print(li)</span><br><span class="line"></span><br><span class="line">#pop_del_remove_clear</span><br><span class="line">li = [1,&apos;a&apos;,&apos;b&apos;,2,3,&apos;a&apos;]</span><br><span class="line">li.pop(1) # 按索引位置去删除</span><br><span class="line">print(li) #[1, &apos;b&apos;, 2, 3, &apos;a&apos;]</span><br><span class="line">del li[1:3] # 按照位置去删除</span><br><span class="line">print(li) #[1, 3, &apos;a&apos;]</span><br><span class="line">li.remove(&apos;a&apos;) # 按照元素去删除</span><br><span class="line">print(li) # [1, 3]</span><br><span class="line">li.clear() #清空列表</span><br><span class="line">print(li) # []</span><br><span class="line"></span><br><span class="line">li = [1,&apos;a&apos;,&apos;b&apos;,2,3,&apos;a&apos;]</span><br><span class="line">li[1]=&apos;ccc&apos;</span><br><span class="line">print(li) #[1, &apos;ccc&apos;, &apos;b&apos;, 2, 3, &apos;a&apos;]</span><br><span class="line">li[4:6] = [5,7]</span><br><span class="line">print(li) #[1, &apos;ccc&apos;, &apos;b&apos;, 2, 5, 7]</span><br><span class="line"></span><br><span class="line">#count (数) 统计某个元素在列表中出现的次数。</span><br><span class="line">a = [&apos;s&apos;,&apos;u&apos;,&apos;n&apos;,&apos;s&apos;,&apos;h&apos;,&apos;i&apos;,&apos;n&apos;,&apos;e&apos;]</span><br><span class="line">print(a.count(&apos;s&apos;))  # 出现了2次</span><br><span class="line"></span><br><span class="line">#index 方法 用于从列表中找出某个值第一个匹配项的索引位置</span><br><span class="line">a = [&apos;s&apos;,&apos;u&apos;,&apos;n&apos;,&apos;s&apos;,&apos;h&apos;,&apos;i&apos;,&apos;n&apos;,&apos;e&apos;]</span><br><span class="line">print(a.index(&apos;n&apos;)) # 第一个出现n的索引位置为 2</span><br><span class="line"></span><br><span class="line">#sort 在原位置对列表进行排序</span><br><span class="line">a = [&apos;s&apos;,&apos;u&apos;,&apos;n&apos;,&apos;s&apos;,&apos;h&apos;,&apos;i&apos;,&apos;n&apos;,&apos;e&apos;]</span><br><span class="line">print(a.sort()) # 输出为 None</span><br><span class="line">a.sort() # 没有返回值</span><br><span class="line">print(a) # [&apos;e&apos;, &apos;h&apos;, &apos;i&apos;, &apos;n&apos;, &apos;n&apos;, &apos;s&apos;, &apos;s&apos;, &apos;u&apos;]</span><br><span class="line"></span><br><span class="line">#reverse 将列表中的元素反向存放</span><br><span class="line">a = [&apos;s&apos;,&apos;u&apos;,&apos;n&apos;,&apos;s&apos;,&apos;h&apos;,&apos;i&apos;,&apos;n&apos;,&apos;e&apos;]</span><br><span class="line"># print(a.reverse()) # 输出为 None</span><br><span class="line">a.reverse() # 没有返回值</span><br><span class="line">print(a) # [&apos;e&apos;, &apos;n&apos;, &apos;i&apos;, &apos;h&apos;, &apos;s&apos;, &apos;n&apos;, &apos;u&apos;, &apos;s&apos;]</span><br></pre></td></tr></table></figure>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典是Python中唯一的映射类型，采用键值对（key–&gt;value）的形式存储数据。Python对key进行哈希函数运算，根据运算的结果决定value的存储地址，所以字典是无序存储的，且key必须是可哈希的。可哈希表示kye必须是不可变类型，如：数组、字符串、元组。字典是除列表之外最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象结合。两者的区别在于：字典是通过key来取值的，而不是通过偏移存取。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic = &#123;&apos;name&apos;:&apos;sunshine&apos;,&apos;age&apos;:28,&apos;sex&apos;:&apos;male&apos;&#125;</span><br><span class="line">dic[&apos;li&apos;] = [&apos;a&apos;,&apos;b&apos;]  </span><br><span class="line">print(dic) # &#123;&apos;name&apos;: &apos;sunshine&apos;, &apos;age&apos;: 28, &apos;sex&apos;: &apos;male&apos;, &apos;li&apos;: [&apos;a&apos;, &apos;b&apos;]&#125;</span><br><span class="line"># setdefault在字典中增加键值对，如果只有键那对应的值就是none,但是如果原字典中存在设置的键值对，则不会发生变更</span><br><span class="line">#&#123;&apos;name&apos;: &apos;sunshine&apos;, &apos;age&apos;: 28, &apos;sex&apos;: &apos;male&apos;, &apos;li&apos;: [&apos;a&apos;, &apos;b&apos;], &apos;hobby&apos;: [&apos;study&apos;, &apos;listen&apos;, &apos;eat&apos;]&#125;</span><br><span class="line">dic.setdefault(&apos;hobby&apos;,[&apos;study&apos;,&apos;sleep&apos;,&apos;eat&apos;])  # 未发生变化</span><br><span class="line">#&#123;&apos;name&apos;: &apos;sunshine&apos;, &apos;age&apos;: 28, &apos;sex&apos;: &apos;male&apos;, &apos;li&apos;: [&apos;a&apos;, &apos;b&apos;], &apos;hobby&apos;: [&apos;study&apos;, &apos;listen&apos;, &apos;eat&apos;]&#125;</span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line">setdefaut</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Supervisor使用总结</title>
    <url>/2020/08/24/Supervisor%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="一、supervisor简介"><a href="#一、supervisor简介" class="headerlink" title="一、supervisor简介"></a>一、supervisor简介</h2><p>Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。</p>
<h2 id="二、supervisor安装"><a href="#二、supervisor安装" class="headerlink" title="二、supervisor安装"></a>二、supervisor安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 配置好yum源后，可以直接安装</span><br><span class="line">yum install supervisor</span><br><span class="line"></span><br><span class="line">2. Debian/Ubuntu可通过apt安装</span><br><span class="line">apt-get install supervisor</span><br><span class="line"></span><br><span class="line">3. pip安装</span><br><span class="line">pip install supervisor</span><br><span class="line"></span><br><span class="line">4. easy_install安装</span><br><span class="line">easy_install supervisor</span><br></pre></td></tr></table></figure>
<h2 id="三、supervisor使用"><a href="#三、supervisor使用" class="headerlink" title="三、supervisor使用"></a>三、supervisor使用</h2><p><strong>supervisor配置文件</strong>：/etc/supervisord.conf<br>注：supervisor的配置文件默认是不全的，不过在大部分默认的情况下，上面说的基本功能已经满足。</p>
<p><strong>子进程配置文件路径</strong>：/etc/supervisord.d/<br>注：默认子进程配置文件为ini格式，可在supervisor主配置文件中修改。</p>
<h2 id="四、配置文件说明"><a href="#四、配置文件说明" class="headerlink" title="四、配置文件说明"></a>四、配置文件说明</h2><h3 id="supervisor-conf配置文件说明："><a href="#supervisor-conf配置文件说明：" class="headerlink" title="supervisor.conf配置文件说明："></a>supervisor.conf配置文件说明：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=0700                 ;socket文件的mode，默认是0700</span><br><span class="line">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span><br><span class="line"> </span><br><span class="line">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span><br><span class="line">;port=127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username=user              ;登录管理后台的用户名</span><br><span class="line">;password=123               ;登录管理后台的密码</span><br><span class="line"> </span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class="line">logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class="line">loglevel=info                ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ;pid 文件</span><br><span class="line">nodaemon=false               ;是否在前台启动，默认是false，即以 daemon 的方式启动</span><br><span class="line">minfds=1024                  ;可以打开的文件描述符的最小值，默认 1024</span><br><span class="line">minprocs=200                 ;可以打开的进程数的最小值，默认 200</span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span><br><span class="line">;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span><br><span class="line"> </span><br><span class="line">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class="line">[program:xx]</span><br><span class="line">command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令</span><br><span class="line">autostart=true       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br><span class="line">autorestart=true     ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class="line">startretries=3       ; 启动失败自动重试次数，默认是3</span><br><span class="line">user=tomcat          ; 用哪个用户启动进程，默认是root</span><br><span class="line">priority=999         ; 进程启动优先级，默认999，值小的优先启动</span><br><span class="line">redirect_stderr=true ; 把stderr重定向到stdout，默认false</span><br><span class="line">stdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MB</span><br><span class="line">stdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10</span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out</span><br><span class="line">stopasgroup=false     ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class="line">killasgroup=false     ;默认为false，向进程组发送kill信号，包括子进程</span><br><span class="line"> </span><br><span class="line">;包含其它配置文件</span><br><span class="line">[include]</span><br><span class="line">files = relative/directory/*.ini    ;可以指定一个或多个以.ini结束的配置文件</span><br></pre></td></tr></table></figure>
<h3 id="子进程配置文件说明："><a href="#子进程配置文件说明：" class="headerlink" title="子进程配置文件说明："></a>子进程配置文件说明：</h3><p>给需要管理的子进程(程序)编写一个配置文件，放在/etc/supervisor.d/目录下，以.ini作为扩展名（每个进程的配置文件都可以单独分拆也可以把相关的脚本放一起）。如任意定义一个和脚本相关的项目名称的选项组（/etc/supervisord.d/test.conf）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#项目名</span><br><span class="line">[program:blog]</span><br><span class="line">#脚本目录</span><br><span class="line">directory=/opt/bin</span><br><span class="line">#脚本执行命令</span><br><span class="line">command=/usr/bin/python /opt/bin/test.py</span><br><span class="line"></span><br><span class="line">#supervisor启动的时候是否随着同时启动，默认True</span><br><span class="line">autostart=true</span><br><span class="line">#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的</span><br><span class="line">autorestart=false</span><br><span class="line">#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span><br><span class="line">startsecs=1</span><br><span class="line"></span><br><span class="line">#脚本运行的用户身份 </span><br><span class="line">user = test</span><br><span class="line"></span><br><span class="line">#日志输出 </span><br><span class="line">stderr_logfile=/tmp/blog_stderr.log </span><br><span class="line">stdout_logfile=/tmp/blog_stdout.log </span><br><span class="line">#把stderr重定向到stdout，默认 false</span><br><span class="line">redirect_stderr = true</span><br><span class="line">#stdout日志文件大小，默认 50MB</span><br><span class="line">stdout_logfile_maxbytes = 20M</span><br><span class="line">#stdout日志文件备份数</span><br><span class="line">stdout_logfile_backups = 20</span><br></pre></td></tr></table></figure>
<h3 id="子进程配置示例："><a href="#子进程配置示例：" class="headerlink" title="子进程配置示例："></a>子进程配置示例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#说明同上</span><br><span class="line">[program:test] </span><br><span class="line">directory=/opt/bin </span><br><span class="line">command=/opt/bin/test</span><br><span class="line">autostart=true </span><br><span class="line">autorestart=false </span><br><span class="line">stderr_logfile=/tmp/test_stderr.log </span><br><span class="line">stdout_logfile=/tmp/test_stdout.log </span><br><span class="line">#user = test</span><br></pre></td></tr></table></figure>
<h2 id="五、supervisor命令说明"><a href="#五、supervisor命令说明" class="headerlink" title="五、supervisor命令说明"></a>五、supervisor命令说明</h2><p><strong>常用命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">supervisorctl status        //查看所有进程的状态</span><br><span class="line">supervisorctl stop es       //停止es</span><br><span class="line">supervisorctl start es      //启动es</span><br><span class="line">supervisorctl restart       //重启es</span><br><span class="line">supervisorctl update        //配置文件修改后使用该命令加载新的配置</span><br><span class="line">supervisorctl reload        //重新启动配置中的所有程序</span><br></pre></td></tr></table></figure>
<p>注：把es换成all可以管理配置中的所有进程。直接输入supervisorctl进入supervisorctl的shell交互界面，此时上面的命令不带supervisorctl可直接使用。</p>
<p>注意事项<br>使用supervisor进程管理命令之前先启动supervisord，否则程序报错。<br>使用命令supervisord -c /etc/supervisord.conf启动。<br>若是centos7：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start supervisord.service     //启动supervisor并加载默认配置文件</span><br><span class="line">systemctl enable supervisord.service    //将supervisor加入开机启动项</span><br></pre></td></tr></table></figure>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><blockquote>
<p>unix:///var/run/supervisor.sock no such file<br>问题描述：安装好supervisor没有开启服务直接使用supervisorctl报的错<br>解决办法：supervisord -c /etc/supervisord.conf</p>
</blockquote>
<blockquote>
<p>command中指定的进程已经起来，但supervisor还不断重启<br>问题描述：command中启动方式为后台启动，导致识别不到pid，然后不断重启，这里使用的是elasticsearch，command指定的是$path/bin/elasticsearch -d<br>解决办法：supervisor无法检测后台启动进程的pid，而supervisor本身就是后台启动守护进程，因此不用担心这个</p>
</blockquote>
<blockquote>
<p>启动了多个supervisord服务，导致无法正常关闭服务<br>问题描述：在运行supervisord -c /etc/supervisord.conf之前，直接运行过supervisord -c /etc/supervisord.d/xx.conf导致有些进程被多个superviord管理，无法正常关闭进程。<br>解决办法：使用ps -fe | grep supervisord查看所有启动过的supervisord服务，kill相关的进程。</p>
</blockquote>
<blockquote>
<p>unix:///var/run/supervisor/supervisor.sock no such file<br>sudo chmod 777 /run<br>sudo chmod 777 /var/log</p>
</blockquote>
<blockquote>
<p>Unlinking stale socket /var/run/supervisor/supervisor.sock<br>unlink /var/run/supervisor/supervisor.sock</p>
</blockquote>
<blockquote>
<p>Error: Another program is already listening on a port that one of our HTTP servers is configured to use.  Shut this program down first before starting supervisord.<br>ps aux | grep supervisord<br>kill - 9 进程ID</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://www.jianshu.com/p/0b9054b33db3" target="_blank" rel="noopener">https://www.jianshu.com/p/0b9054b33db3</a></li>
<li><a href="https://www.cnblogs.com/ruanraun/p/supervisor.html" target="_blank" rel="noopener">https://www.cnblogs.com/ruanraun/p/supervisor.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SkipList总结</title>
    <url>/2019/08/17/SkipList%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="skiplist简介"><a href="#skiplist简介" class="headerlink" title="skiplist简介"></a>skiplist简介</h4><p>skip List是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)（大多数情况下），因为其性能匹敌红黑树且实现较为简单，因此在很多著名项目都用跳表来代替红黑树，例如LevelDB、Redis的底层存储结构就是用的SkipList。<br>目前常用的key-value数据结构有三种：Hash表、红黑树、SkipList，它们各自有着不同的优缺点：<br>Hash表：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。<br>红黑树：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。<br>SkipList：插入、查找为O(logn)，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。</p>
<h4 id="SkipList基本数据结构及其实现"><a href="#SkipList基本数据结构及其实现" class="headerlink" title="SkipList基本数据结构及其实现"></a>SkipList基本数据结构及其实现</h4><p>一个跳表，应该具有以下特征：</p>
<p>1、一个跳表应该有几个层（level）组成；<br>通常是10-20层，leveldb中默认为12层。</p>
<p>2、跳表的第0层包含所有的元素；<br>且节点值是有序的。</p>
<p>3、每一层都是一个有序的链表；<br>层数越高应越稀疏，这样在高层次中能’跳过’许多的不符合条件的数据。</p>
<p>4、如果元素x出现在第i层，则所有比i小的层都包含x；</p>
<p>5、每个节点包含key及其对应的value和一个指向该节点第n层的下个节点的指针数组<br>x-&gt;next[level]表示第level层的x的下一个节点</p>
<p><img src="/2019/08/17/SkipList总结/list1.png" alt="avatar"><br>一个有序的链表，我们选取它的一半的节点用来建索引，这样如果插入一个节点，我们比较的次数就减少了一半。这种做法，虽然增加了50%的空间，但是性能提高了一倍。如上图。既然，我们已经提取了一层节点索引，那么，可以在第一层索引上再提取索引。如下图。</p>
<p><img src="/2019/08/17/SkipList总结/list2.png" alt="avatar"><br>对于node5来说，它的next：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node5-&gt;next[2] = tailNode;</span><br><span class="line">node5-&gt;next[1] = node7;</span><br><span class="line">node5-&gt;next[0] = node6;</span><br></pre></td></tr></table></figure></p>
<p>对于node7来说，它的next：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node7-&gt;next[1] = node9;</span><br><span class="line">node7-&gt;next[0] = node8;</span><br></pre></td></tr></table></figure></p>
<p>对于node3来说，它的next：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node3-&gt;next[0] = node4;</span><br></pre></td></tr></table></figure></p>
<h4 id="skiplist查找"><a href="#skiplist查找" class="headerlink" title="skiplist查找"></a>skiplist查找</h4><p><img src="/2019/08/17/SkipList总结/list3.png" alt="avatar"><br>综上：<br>当targetNode-&gt;next[i]的值 &lt; 待查找的值时，令targetNode = targetNode-&gt;next[i]，targetNode移到第i级的下一个结点；<br>当targetNode-&gt;next[i]的值 &gt; 待查找的值时，向下降级，i- - ，不改变targetNode；<br>当targetNode-&gt;next[i]的值 = 待查找的值时，向下降级，i- - ，不改变targetNode。<br>最后，再次比较targetNode-&gt;next[0]和theElement，判断是否找到。<br>所以整个运算下来，targetNode是要查找的节点前面那个节点。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 如果存在 x, 返回 x 所在的节点， </span><br><span class="line"> * 否则返回 x 的后继节点 */  </span><br><span class="line">find(x)   </span><br><span class="line">&#123;  </span><br><span class="line">    p = top;  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        while (p-&gt;next-&gt;key &lt; x)  </span><br><span class="line">            p = p-&gt;next;  </span><br><span class="line">        if (p-&gt;down == NULL)   </span><br><span class="line">            return p-&gt;next;  </span><br><span class="line">        p = p-&gt;down;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="skiplist插入"><a href="#skiplist插入" class="headerlink" title="skiplist插入"></a>skiplist插入</h4><p>插入的步骤：<br>新节点和各层索引节点逐一比较，确定原链表的插入位置。O（logN）<br>把索引插入到原链表。O（1）<br>利用抛硬币的随机方式，决定新节点是否提升为上一级索引。结果为“正”则提升并继续抛硬币，结果为“负”则停止。O（logN）<br>总体上，跳表插入操作的时间复杂度是O（logN），而这种数据结构所占空间是2N，既空间复杂度是 O（N）。</p>
<h4 id="skiplist删除"><a href="#skiplist删除" class="headerlink" title="skiplist删除"></a>skiplist删除</h4><p><img src="/2019/08/17/SkipList总结/list4.jpg" alt="avatar"><br>自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点。O（logN）<br>删除每一层查找到的节点，如果该层只剩下1个节点，删除整个一层（原链表除外）。O（logN）<br>总体上，跳表删除操作的时间复杂度是O（N）</p>
<h4 id="skiplist实现"><a href="#skiplist实现" class="headerlink" title="skiplist实现"></a>skiplist实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hqq.list;</span><br><span class="line"></span><br><span class="line">import java.net.CacheRequest;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * SkipListNode</span><br><span class="line"> * 跳跃表的节点,包括key-value和上下左右4个指针</span><br><span class="line"> * Created by heqianqian on 2017/6/1.</span><br><span class="line"> */</span><br><span class="line">public class SkipListNode&lt;T&gt; &#123;</span><br><span class="line">    private int key;</span><br><span class="line">    private T value;</span><br><span class="line">    public SkipListNode&lt;T&gt; up, down, left, right;</span><br><span class="line"></span><br><span class="line">    public static final int HEAD_KEY = Integer.MIN_VALUE;//负无穷</span><br><span class="line">    public static final int TAIL_KEY = Integer.MAX_VALUE;//正无穷</span><br><span class="line"></span><br><span class="line">    public SkipListNode(int k, T v) &#123;</span><br><span class="line">        this.key = k;</span><br><span class="line">        this.value = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getKey() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKey(int key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(T value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!(o instanceof SkipListNode&lt;?&gt;)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SkipListNode&lt;T&gt; ent;</span><br><span class="line">        try &#123;</span><br><span class="line">            ent = (SkipListNode&lt;T&gt;) o;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return (ent.getKey() == key) &amp;&amp; (ent.getValue() == value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;key-value:&quot;+key+&quot;-&quot;+value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hqq.list;</span><br><span class="line"></span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * SkipList</span><br><span class="line"> * 不固定层级的跳跃表</span><br><span class="line"> * Created by heqianqian on 2017/6/1.</span><br><span class="line"> */</span><br><span class="line">public class SkipList&lt;T extends Comparable&lt;? super T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private SkipListNode&lt;T&gt; head, tail;</span><br><span class="line">    private int nodes;//节点总数</span><br><span class="line">    private int listLevel;//层数</span><br><span class="line">    private Random random;//用于产生随机数</span><br><span class="line">    private static final double PROBABILITY = 0.5;//向上提升一个的概率</span><br><span class="line"></span><br><span class="line">    public SkipList() &#123;</span><br><span class="line">        random = new Random();</span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 清空跳跃表</span><br><span class="line">     */</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        head = new SkipListNode&lt;T&gt;(SkipListNode.HEAD_KEY, null);</span><br><span class="line">        tail = new SkipListNode&lt;T&gt;(SkipListNode.TAIL_KEY, null);</span><br><span class="line">        horizontalLink(head, tail);</span><br><span class="line">        listLevel = 0;</span><br><span class="line">        nodes = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 水平双向连接</span><br><span class="line">     */</span><br><span class="line">    private void horizontalLink(SkipListNode&lt;T&gt; node1, SkipListNode&lt;T&gt; node2) &#123;</span><br><span class="line">        node1.right = node2;</span><br><span class="line">        node2.left = node1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 垂直双向连接</span><br><span class="line">     */</span><br><span class="line">    private void vertiacallLink(SkipListNode&lt;T&gt; node1, SkipListNode&lt;T&gt; node2) &#123;</span><br><span class="line">        node1.down = node2;</span><br><span class="line">        node2.up = node1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在最下面一层，找到要插入的位置前面的那个key</span><br><span class="line">     */</span><br><span class="line">    private SkipListNode&lt;T&gt; findNode(int key) &#123;</span><br><span class="line">        SkipListNode&lt;T&gt; p = head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            while (p.right.getKey() != SkipListNode.TAIL_KEY &amp;&amp; p.right.getKey() &lt;= key) &#123;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">            if (p.down != null) &#123;</span><br><span class="line">                p = p.down;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查找是否存储key，存在则返回该节点，否则返回null</span><br><span class="line">     */</span><br><span class="line">    public SkipListNode&lt;T&gt; search(int key) &#123;</span><br><span class="line">        SkipListNode&lt;T&gt; p = findNode(key);</span><br><span class="line">        return (key == p.getKey()) ? p : null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向跳跃表中添加key-value</span><br><span class="line">     */</span><br><span class="line">    public void put(int k, T v) &#123;</span><br><span class="line">        SkipListNode&lt;T&gt; p = findNode(k);</span><br><span class="line">        //如果key值相同，替换原来的vaule即可结束</span><br><span class="line">        if (k == p.getKey()) &#123;</span><br><span class="line">            p.setValue(v);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        SkipListNode&lt;T&gt; q = new SkipListNode&lt;T&gt;(k, v);</span><br><span class="line">        backLink(p, q);</span><br><span class="line">        int currentLevel = 0;//当前所层次是0</span><br><span class="line">        //产生随机数</span><br><span class="line">        while (random.nextDouble() &lt; PROBABILITY) &#123;</span><br><span class="line">            //新建一个层</span><br><span class="line">            if (currentLevel &gt;= listLevel) &#123;</span><br><span class="line">                listLevel++;</span><br><span class="line">                SkipListNode&lt;T&gt; p1 = new SkipListNode&lt;T&gt;(SkipListNode.HEAD_KEY, null);</span><br><span class="line">                SkipListNode&lt;T&gt; p2 = new SkipListNode&lt;T&gt;(SkipListNode.TAIL_KEY, null);</span><br><span class="line">                horizontalLink(p1, p2);</span><br><span class="line">                vertiacallLink(p1, head);</span><br><span class="line">                vertiacallLink(p2, tail);</span><br><span class="line">                head = p1;</span><br><span class="line">                tail = p2;</span><br><span class="line">            &#125;</span><br><span class="line">            //把p移动到上一层</span><br><span class="line">            while (p.up == null) &#123;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.up;</span><br><span class="line"></span><br><span class="line">            SkipListNode&lt;T&gt; e = new SkipListNode&lt;T&gt;(k, null);</span><br><span class="line">            backLink(p, e);</span><br><span class="line">            vertiacallLink(e, q);</span><br><span class="line">            q = e;</span><br><span class="line">            currentLevel++;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在node1后插入node2</span><br><span class="line">     */</span><br><span class="line">    private void backLink(SkipListNode&lt;T&gt; node1, SkipListNode&lt;T&gt; node2) &#123;</span><br><span class="line">        node2.left = node1;</span><br><span class="line">        node2.right = node1.right;</span><br><span class="line">        node1.right.left = node2;</span><br><span class="line">        node1.right = node2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return nodes == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            return &quot;跳跃表为空&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        SkipListNode&lt;T&gt; p = head;</span><br><span class="line">        while (p.down != null) &#123;</span><br><span class="line">            p = p.down;</span><br><span class="line">        &#125;</span><br><span class="line">        while (p.left != null) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p.right != null) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        while (p.right != null) &#123;</span><br><span class="line">            builder.append(p);</span><br><span class="line">            builder.append(&quot;\n&quot;);</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="https://blog.csdn.net/Thousa_Ho/article/details/72830054" target="_blank" rel="noopener">https://blog.csdn.net/Thousa_Ho/article/details/72830054</a></li>
<li><a href="https://blog.csdn.net/wugemao/article/details/83826211" target="_blank" rel="noopener">https://blog.csdn.net/wugemao/article/details/83826211</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>es总结2</title>
    <url>/2020/03/25/es%E6%80%BB%E7%BB%932/</url>
    <content><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol>
<li>文档</li>
</ol>
<ul>
<li>Elasticsearch是面向文档的，文档是所有可搜索数据的最小单位</li>
<li>文档会被序列化为JSON格式，保存在Elasticsearch中，JSON对象由字段组成，每个字段都有对应的字段类型（字符串/数值／布尔／日期／二进制／范围类型）</li>
<li>每个文档都有一个Unique ID，可以自己指定ID，或者通过Elasticsearch生成</li>
</ul>
<ol start="2">
<li>JSON文档</li>
</ol>
<ul>
<li>一篇文档包含了一系列的字段。类似数据库表中一条记录</li>
<li>JSON文档，格式灵活，不需要预先定义格式；字段的类型可以指定或者通过Elasticsearch自动推算，支持数组／支持嵌套</li>
</ul>
<ol start="3">
<li>文档的元数据<br>元数据，用于标注文档的相关信息<br>_index:文档所属的索引名<br>_type:文档所属的类型名<br>_id:文档唯一Id<br>_source:文档的原始Json数据<br>_all:整合所有字段内容到该字段，已被废除<br>_version:文档的版本信息<br>_score:相关性打分</li>
<li>索引<ul>
<li>索引是文档的容器，是一类文档的结合；Index体现了逻辑空间的概念，每个索引都有自己的Mapping定义，用于定义包含的文档的字段名和字段类型；Shard体现了物理空间的概念，索引中的数据分散在Shard上。</li>
<li>索引的Mapping与Settings：Mapping定义文档字段的类型，Setting定义不同的数据分布<br><img src="/2020/03/25/es总结2/es2-1.png" alt="avatar"></li>
</ul>
</li>
<li>与关系型数据库对比<br><img src="/2020/03/25/es总结2/es2-2.png" alt="avatar"></li>
</ol>
<h4 id="节点、集群"><a href="#节点、集群" class="headerlink" title="节点、集群"></a>节点、集群</h4><ol>
<li>分布式系统的可用性与扩展性</li>
</ol>
<ul>
<li>高可用性：服务可用性，允许有节点停止服务；数据可用性，部分节点丢失，不会丢失数据；</li>
<li>可扩展性：请求量提升／数据的不断增长（将数据分布到所有节点上）</li>
<li>Elasticsearch的分布式架构好处：存储的水平扩容，提高系统的可用性；部分节点停止服务，整个集群的服务不受影响；</li>
<li>Elasticsearch的分布式架构：不同的集群通过不同的名字来区分，默认名字“elasticsearch”;通过配置文件修改，或者命令行中”-E cluster.name=geektime”进行设定；一个集群可以有一个或多个节点；</li>
</ul>
<ol start="2">
<li>节点 </li>
</ol>
<ul>
<li>节点是一个Elasticsearch的实例，本质上就是一个JAVA进程，一台机器上可以运行多个Elasticsearch进程，但生产环境一般只建议一台机器上只运行一个Elasticsearch实例。</li>
<li>每一个节点都有名字，通过配置文件配置或启动时候“-E node.name=node1”指定；</li>
<li>每一个节点在启动之后，会分配一个UID，保存在data目录下。</li>
</ul>
<ol start="3">
<li>Master-eligible nodes 和Master Node</li>
</ol>
<ul>
<li>每个节点启动后，默认就是一个Master eligible节点，可以设置node.master:false禁止；</li>
<li>Master-eilgible节点可以参加选主流程，成为Master节点；当第一个节点启动时候，它会将自己选举成Master节点；</li>
<li>每个节点上都保存了集群的状态，只有Master节点才能修改集群的状态信息；集群状态（cluster State），维护了一个集群中必要的信息，包括所有的节点信息，所有的索引和其相关的Mapping与Setting信息；分片的路由信息；任意节点都能修改信息会导致数据的不一致性；</li>
</ul>
<ol start="4">
<li>Date Node &amp; Coordinating Node</li>
</ol>
<ul>
<li>Data Node:可以保存数据的节点，叫做Data Node。负责保存分片数据，在数据扩展上起到了至关重要的作用。</li>
<li>Coordinating Node: 负责接受client的请求，将请求分发到合适的节点，最终把结果汇集到一起；每个节点默认都起到了Coordinating Node的职责。</li>
</ul>
<ol start="5">
<li>其他节点</li>
</ol>
<ul>
<li>Hot &amp; Warm节点：不同硬件配置的Data Node，用来实现Hot&amp;Warm架构，降低集群部署的成本</li>
<li>Machine Learning Node：负责跑机器学习的Job，用来做异常检测；</li>
</ul>
<ol start="6">
<li>配置节点类型<br>开发环境中一个节点可以承担多个角色；生产环境中应该设置单一角色的节点；<br><img src="/2020/03/25/es总结2/es2-3.png" alt="avatar"><h4 id="分片、副本（Primary-Shard，Replica-Shard）"><a href="#分片、副本（Primary-Shard，Replica-Shard）" class="headerlink" title="分片、副本（Primary Shard，Replica Shard）"></a>分片、副本（Primary Shard，Replica Shard）</h4></li>
</ol>
<ul>
<li>主分片：用以解决数据水平扩展的问题。通过主分片，可以将数据分布到集群内的所有节点之上。一个分片是一个运行的Lucene的实例，主分片数在索引创建时指定，后续不允许修改，除非Reindex。</li>
<li>副本：用以解决数据高可用的问题，分片是主分片的拷贝。副本分片数可以动态调整；增加副本数还可以在一定程度上提高服务的可用性。<br><img src="/2020/03/25/es总结2/es2-4.png" alt="avatar"></li>
</ul>
<ol>
<li>分片的设定</li>
</ol>
<ul>
<li>对于生产环境中分片的设定，需要提前做好容量规划。</li>
<li>分片数设置过小，导致后续无法增加节点实现水平扩展；单个分片的数据量太大，导致数据重新分配耗时。</li>
<li>分片数设置过大，7.0开始，默认主分片设置成1，解决了over-sharding的问题；影响搜索结果的相关性打分，影响统计结果的准确性；单个节点上过多的分片，会导致资源浪费，同时也会影响性能。<br><img src="/2020/03/25/es总结2/es2-5.png" alt="avatar"><h4 id="基本CRUD操作"><a href="#基本CRUD操作" class="headerlink" title="基本CRUD操作"></a>基本CRUD操作</h4><img src="/2020/03/25/es总结2/es2-6.png" alt="avatar"></li>
<li>Type名: 约定都用_doc</li>
<li>Create: 如果ID已经存在，会失败；</li>
<li>Index: 如果ID不存在，创建现有的文档。否则，先删除现有的文档，在创建新的文档，版本会增加；</li>
<li>Update: 文档必须已经存在，更新只会对相应字段做增量修改；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Create 一个文档</span><br><span class="line">PUT users/_create/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;:&quot;Jack&quot;,</span><br><span class="line">  &quot;lastName&quot;:&quot;Johnson&quot;,</span><br><span class="line">  &quot;tags&quot;:[&quot;guitar&quot;,&quot;skateboard&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;users&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;2&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;result&quot; : &quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 2,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 1,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">支持自动生成文档Id和指定文档Id两种方式</span><br><span class="line">通过调用“post /users/_doc”,系统会自动生成document Id</span><br><span class="line">使用HTTP PUT user/_create/1创建时，URI中显示指定_create,此时如果该id文档已经存在，操作失败。</span><br><span class="line"></span><br><span class="line">2. GET 一个文档 </span><br><span class="line">GET users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;users&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;_seq_no&quot; : 0,</span><br><span class="line">  &quot;_primary_term&quot; : 1,</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;firstName&quot; : &quot;Jack&quot;,</span><br><span class="line">    &quot;lastName&quot; : &quot;Johnson&quot;,</span><br><span class="line">    &quot;tags&quot; : [</span><br><span class="line">      &quot;guitar&quot;,</span><br><span class="line">      &quot;skateboard&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">找到文档，返回HTTP 200；</span><br><span class="line">文档元信息，_index/_type/</span><br><span class="line">版本信息，同一个Id的文档，即使被删除，Version号也会不断增加；</span><br><span class="line">_source中默认包含了文档的所有原始信息</span><br><span class="line">- 找不到文档，返回HTTP 404</span><br><span class="line"></span><br><span class="line">3. Index 文档</span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tags&quot;:[&quot;guitar&quot;,&quot;skateboard&quot;,&quot;reading&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;users&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 2,</span><br><span class="line">  &quot;result&quot; : &quot;updated&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 2,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 2,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line">Index和Create不一样的地方：如果文档不存在，就索引新的文档。</span><br><span class="line">否则现有文档会被删除，新的文档被索引。版本信息+1</span><br><span class="line"></span><br><span class="line">POST users/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;:&#123;</span><br><span class="line">    &quot;albums&quot;:[&quot;album1&quot;,&quot;album2&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;users&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 3,</span><br><span class="line">  &quot;result&quot; : &quot;noop&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 0,</span><br><span class="line">    &quot;successful&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">update方法不会删除原来的文档，而是实现真正的数据更新</span><br><span class="line">post方法／payload需要包含在doc中</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Bulk-API"><a href="#Bulk-API" class="headerlink" title="Bulk API"></a>Bulk API</h4><ul>
<li>支持在一次API调用中，对不同的索引进行操作</li>
<li>支持四种类型操作Index/Create/Update/Delete</li>
<li>可以再URI中指定Index，也可以在请求的Payload中进行</li>
<li>操作中单条记录失败，并不会影响其他操作</li>
<li>返回结果包括了每一条操作执行的结果<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _bulk </span><br><span class="line">&#123; &quot;index&quot; : &#123;&quot;_index&quot;: &quot;test&quot;,&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span><br><span class="line">&#123; &quot;field1&quot;: &quot;value1&quot;&#125;</span><br><span class="line">&#123; &quot;delete&quot;: &#123;&quot;_index&quot;: &quot;test&quot;,&quot;_id&quot;:&quot;2&quot;&#125;&#125;</span><br><span class="line">&#123; &quot;create&quot;: &#123;&quot;_index&quot;: &quot;test2&quot;,&quot;_id&quot;:&quot;3&quot;&#125;&#125;</span><br><span class="line">&#123; &quot;field1&quot;: &quot;value3&quot;&#125;</span><br><span class="line">&#123; &quot;update&quot;: &#123;&quot;_index&quot;: &quot;test&quot;,&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;field2&quot;:&quot;value2&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 717,</span><br><span class="line">  &quot;errors&quot; : false,</span><br><span class="line">  &quot;items&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;index&quot; : &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;test&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">        &quot;_version&quot; : 1,</span><br><span class="line">        &quot;result&quot; : &quot;created&quot;,</span><br><span class="line">        &quot;_shards&quot; : &#123;</span><br><span class="line">          &quot;total&quot; : 2,</span><br><span class="line">          &quot;successful&quot; : 2,</span><br><span class="line">          &quot;failed&quot; : 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;_seq_no&quot; : 0,</span><br><span class="line">        &quot;_primary_term&quot; : 1,</span><br><span class="line">        &quot;status&quot; : 201</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;delete&quot; : &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;test&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;2&quot;,</span><br><span class="line">        &quot;_version&quot; : 1,</span><br><span class="line">        &quot;result&quot; : &quot;not_found&quot;,</span><br><span class="line">        &quot;_shards&quot; : &#123;</span><br><span class="line">          &quot;total&quot; : 2,</span><br><span class="line">          &quot;successful&quot; : 2,</span><br><span class="line">          &quot;failed&quot; : 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;_seq_no&quot; : 1,</span><br><span class="line">        &quot;_primary_term&quot; : 1,</span><br><span class="line">        &quot;status&quot; : 404</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;create&quot; : &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;test2&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;3&quot;,</span><br><span class="line">        &quot;_version&quot; : 1,</span><br><span class="line">        &quot;result&quot; : &quot;created&quot;,</span><br><span class="line">        &quot;_shards&quot; : &#123;</span><br><span class="line">          &quot;total&quot; : 2,</span><br><span class="line">          &quot;successful&quot; : 1,</span><br><span class="line">          &quot;failed&quot; : 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;_seq_no&quot; : 0,</span><br><span class="line">        &quot;_primary_term&quot; : 1,</span><br><span class="line">        &quot;status&quot; : 201</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;update&quot; : &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;test&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">        &quot;_version&quot; : 2,</span><br><span class="line">        &quot;result&quot; : &quot;updated&quot;,</span><br><span class="line">        &quot;_shards&quot; : &#123;</span><br><span class="line">          &quot;total&quot; : 2,</span><br><span class="line">          &quot;successful&quot; : 2,</span><br><span class="line">          &quot;failed&quot; : 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;_seq_no&quot; : 2,</span><br><span class="line">        &quot;_primary_term&quot; : 1,</span><br><span class="line">        &quot;status&quot; : 200</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">批量读取-mget，批量操作可以减少网络连接所产生的开销，提高性能</span><br><span class="line">GET _mget</span><br><span class="line">&#123;</span><br><span class="line">  &quot;docs&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot;:&quot;user&quot;,</span><br><span class="line">      &quot;_id&quot;:1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot;:&quot;comment&quot;,</span><br><span class="line">      &quot;_id&quot;:1</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;docs&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;user&quot;,</span><br><span class="line">      &quot;_type&quot; : null,</span><br><span class="line">      &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">      &quot;error&quot; : &#123;</span><br><span class="line">        &quot;root_cause&quot; : [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot; : &quot;index_not_found_exception&quot;,</span><br><span class="line">            &quot;reason&quot; : &quot;no such index [user]&quot;,</span><br><span class="line">            &quot;resource.type&quot; : &quot;index_expression&quot;,</span><br><span class="line">            &quot;resource.id&quot; : &quot;user&quot;,</span><br><span class="line">            &quot;index_uuid&quot; : &quot;_na_&quot;,</span><br><span class="line">            &quot;index&quot; : &quot;user&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;type&quot; : &quot;index_not_found_exception&quot;,</span><br><span class="line">        &quot;reason&quot; : &quot;no such index [user]&quot;,</span><br><span class="line">        &quot;resource.type&quot; : &quot;index_expression&quot;,</span><br><span class="line">        &quot;resource.id&quot; : &quot;user&quot;,</span><br><span class="line">        &quot;index_uuid&quot; : &quot;_na_&quot;,</span><br><span class="line">        &quot;index&quot; : &quot;user&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;comment&quot;,</span><br><span class="line">      &quot;_type&quot; : null,</span><br><span class="line">      &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">      &quot;error&quot; : &#123;</span><br><span class="line">        &quot;root_cause&quot; : [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot; : &quot;index_not_found_exception&quot;,</span><br><span class="line">            &quot;reason&quot; : &quot;no such index [comment]&quot;,</span><br><span class="line">            &quot;resource.type&quot; : &quot;index_expression&quot;,</span><br><span class="line">            &quot;resource.id&quot; : &quot;comment&quot;,</span><br><span class="line">            &quot;index_uuid&quot; : &quot;_na_&quot;,</span><br><span class="line">            &quot;index&quot; : &quot;comment&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;type&quot; : &quot;index_not_found_exception&quot;,</span><br><span class="line">        &quot;reason&quot; : &quot;no such index [comment]&quot;,</span><br><span class="line">        &quot;resource.type&quot; : &quot;index_expression&quot;,</span><br><span class="line">        &quot;resource.id&quot; : &quot;comment&quot;,</span><br><span class="line">        &quot;index_uuid&quot; : &quot;_na_&quot;,</span><br><span class="line">        &quot;index&quot; : &quot;comment&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">其他：msearch批量查询</span><br><span class="line">错误返回：</span><br><span class="line">无法连接：网络故障或集群挂了</span><br><span class="line">连接无法关闭：网络故障或节点错误</span><br><span class="line">429:集群过于繁忙</span><br><span class="line">4xx:请求体格式有错  </span><br><span class="line">500:集群内部错误</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>flask_session源代码阅读</title>
    <url>/2021/06/16/flask-session%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>最近在做客户需求，要求提高session的安全性，需要把session的长度从32位提高至64位。主要内容是分析flask_session源码，具体如下。</p>
<p><strong><strong>init</strong>文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Session(object):</span><br><span class="line">    &quot;&quot;&quot;This class is used to add Server-side Session to one or more Flask</span><br><span class="line">    applications.</span><br><span class="line"></span><br><span class="line">    There are two usage modes.  One is initialize the instance with a very</span><br><span class="line">    specific Flask application::</span><br><span class="line"></span><br><span class="line">        app = Flask(__name__)</span><br><span class="line">        Session(app)</span><br><span class="line"></span><br><span class="line">    The second possibility is to create the object once and configure the</span><br><span class="line">    application later::</span><br><span class="line"></span><br><span class="line">        sess = Session()</span><br><span class="line"></span><br><span class="line">        def create_app():</span><br><span class="line">            app = Flask(__name__)</span><br><span class="line">            sess.init_app(app)</span><br><span class="line">            return app</span><br><span class="line"></span><br><span class="line">    By default Flask-Session will use :class:`NullSessionInterface`, you</span><br><span class="line">    really should configurate your app to use a different SessionInterface.</span><br><span class="line"></span><br><span class="line">    .. note::</span><br><span class="line"></span><br><span class="line">        You can not use ``Session`` instance directly, what ``Session`` does</span><br><span class="line">        is just change the :attr:`~flask.Flask.session_interface` attribute on</span><br><span class="line">        your Flask applications.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, app=None):</span><br><span class="line">        self.app = app</span><br><span class="line">        if app is not None:</span><br><span class="line">            self.init_app(app)</span><br><span class="line"></span><br><span class="line">    def init_app(self, app):</span><br><span class="line">        &quot;&quot;&quot;This is used to set up session for your app object.</span><br><span class="line"></span><br><span class="line">        :param app: the Flask app object with proper configuration.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        app.session_interface = self._get_interface(app)</span><br><span class="line"></span><br><span class="line">    def _get_interface(self, app):</span><br><span class="line">        config = app.config.copy()</span><br><span class="line">        config.setdefault(&apos;SESSION_TYPE&apos;, &apos;null&apos;)</span><br><span class="line">        config.setdefault(&apos;SESSION_PERMANENT&apos;, True)</span><br><span class="line">        config.setdefault(&apos;SESSION_USE_SIGNER&apos;, False)</span><br><span class="line">        config.setdefault(&apos;SESSION_KEY_PREFIX&apos;, &apos;session:&apos;)</span><br><span class="line">        config.setdefault(&apos;SESSION_REDIS&apos;, None)</span><br><span class="line">        config.setdefault(&apos;SESSION_MEMCACHED&apos;, None)</span><br><span class="line">        config.setdefault(&apos;SESSION_FILE_DIR&apos;,</span><br><span class="line">                          os.path.join(os.getcwd(), &apos;flask_session&apos;))</span><br><span class="line">        config.setdefault(&apos;SESSION_FILE_THRESHOLD&apos;, 500)</span><br><span class="line">        config.setdefault(&apos;SESSION_FILE_MODE&apos;, 384)</span><br><span class="line">        config.setdefault(&apos;SESSION_MONGODB&apos;, None)</span><br><span class="line">        config.setdefault(&apos;SESSION_MONGODB_DB&apos;, &apos;flask_session&apos;)</span><br><span class="line">        config.setdefault(&apos;SESSION_MONGODB_COLLECT&apos;, &apos;sessions&apos;)</span><br><span class="line">        config.setdefault(&apos;SESSION_SQLALCHEMY&apos;, None)</span><br><span class="line">        config.setdefault(&apos;SESSION_SQLALCHEMY_TABLE&apos;, &apos;sessions&apos;)</span><br><span class="line"></span><br><span class="line">        if config[&apos;SESSION_TYPE&apos;] == &apos;redis&apos;:</span><br><span class="line">            session_interface = RedisSessionInterface(</span><br><span class="line">                config[&apos;SESSION_REDIS&apos;], config[&apos;SESSION_KEY_PREFIX&apos;],</span><br><span class="line">                config[&apos;SESSION_USE_SIGNER&apos;], config[&apos;SESSION_PERMANENT&apos;])</span><br><span class="line">        elif config[&apos;SESSION_TYPE&apos;] == &apos;memcached&apos;:</span><br><span class="line">            session_interface = MemcachedSessionInterface(</span><br><span class="line">                config[&apos;SESSION_MEMCACHED&apos;], config[&apos;SESSION_KEY_PREFIX&apos;],</span><br><span class="line">                config[&apos;SESSION_USE_SIGNER&apos;], config[&apos;SESSION_PERMANENT&apos;])</span><br><span class="line">        elif config[&apos;SESSION_TYPE&apos;] == &apos;filesystem&apos;:</span><br><span class="line">            session_interface = FileSystemSessionInterface(</span><br><span class="line">                config[&apos;SESSION_FILE_DIR&apos;], config[&apos;SESSION_FILE_THRESHOLD&apos;],</span><br><span class="line">                config[&apos;SESSION_FILE_MODE&apos;], config[&apos;SESSION_KEY_PREFIX&apos;],</span><br><span class="line">                config[&apos;SESSION_USE_SIGNER&apos;], config[&apos;SESSION_PERMANENT&apos;])</span><br><span class="line">        elif config[&apos;SESSION_TYPE&apos;] == &apos;mongodb&apos;:</span><br><span class="line">            session_interface = MongoDBSessionInterface(</span><br><span class="line">                config[&apos;SESSION_MONGODB&apos;], config[&apos;SESSION_MONGODB_DB&apos;],</span><br><span class="line">                config[&apos;SESSION_MONGODB_COLLECT&apos;],</span><br><span class="line">                config[&apos;SESSION_KEY_PREFIX&apos;], config[&apos;SESSION_USE_SIGNER&apos;],</span><br><span class="line">                config[&apos;SESSION_PERMANENT&apos;])</span><br><span class="line">        elif config[&apos;SESSION_TYPE&apos;] == &apos;sqlalchemy&apos;:</span><br><span class="line">            session_interface = SqlAlchemySessionInterface(</span><br><span class="line">                app, config[&apos;SESSION_SQLALCHEMY&apos;],</span><br><span class="line">                config[&apos;SESSION_SQLALCHEMY_TABLE&apos;],</span><br><span class="line">                config[&apos;SESSION_KEY_PREFIX&apos;], config[&apos;SESSION_USE_SIGNER&apos;],</span><br><span class="line">                config[&apos;SESSION_PERMANENT&apos;])</span><br><span class="line">        else:</span><br><span class="line">            session_interface = NullSessionInterface()</span><br><span class="line"></span><br><span class="line">        return session_interface</span><br></pre></td></tr></table></figure>
<p>当我们初始化的时候，可以将session存储至内存、文件、redis、mongo、mysql等各种中间件中。可以对存储的内容进行相关配置，但是很遗憾，没有配置session长度的选项。</p>
<p>先了解下请求到来之前，获取session的方式</p>
<p>请求到来之前通过RequestContex 获取session, 由下图看出，open_session 调用session_interface,而session_interface，是SecureCookieSessionInterface（）的对象。</p>
<p>而 SecureCookieSessionInterface（）,提供了open，和save的方法，所以，可以使用 RedisSessionInterface 替换 SecureCookieSessionInterface,关键就是在配置文件中设置 session_interface指向哪个类</p>
<p><img src="/2021/06/16/flask-session源代码阅读/session.png" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RedisSessionInterface(SessionInterface):</span><br><span class="line">    &quot;&quot;&quot;Uses the Redis key-value store as a session backend.</span><br><span class="line"></span><br><span class="line">    .. versionadded:: 0.2</span><br><span class="line">        The `use_signer` parameter was added.</span><br><span class="line"></span><br><span class="line">    :param redis: A ``redis.Redis`` instance.</span><br><span class="line">    :param key_prefix: A prefix that is added to all Redis store keys.</span><br><span class="line">    :param use_signer: Whether to sign the session id cookie or not.</span><br><span class="line">    :param permanent: Whether to use permanent session or not.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    serializer = pickle</span><br><span class="line">    session_class = RedisSession</span><br><span class="line"></span><br><span class="line">    def __init__(self, redis, key_prefix, use_signer=False, permanent=True):</span><br><span class="line">        if redis is None:</span><br><span class="line">            from redis import Redis</span><br><span class="line">            redis = Redis()</span><br><span class="line">        self.redis = redis</span><br><span class="line">        self.key_prefix = key_prefix</span><br><span class="line">        self.use_signer = use_signer</span><br><span class="line">        self.permanent = permanent</span><br><span class="line"></span><br><span class="line">    def open_session(self, app, request):</span><br><span class="line">        sid = request.cookies.get(app.session_cookie_name)</span><br><span class="line">        if not sid:</span><br><span class="line">            sid = self._generate_sid()</span><br><span class="line">            return self.session_class(sid=sid, permanent=self.permanent)</span><br><span class="line">        if self.use_signer:</span><br><span class="line">            signer = self._get_signer(app)</span><br><span class="line">            if signer is None:</span><br><span class="line">                return None</span><br><span class="line">            try:</span><br><span class="line">                sid_as_bytes = signer.unsign(sid)</span><br><span class="line">                sid = sid_as_bytes.decode()</span><br><span class="line">            except BadSignature:</span><br><span class="line">                sid = self._generate_sid()</span><br><span class="line">                return self.session_class(sid=sid, permanent=self.permanent)</span><br><span class="line"></span><br><span class="line">        if not PY2 and not isinstance(sid, text_type):</span><br><span class="line">            sid = sid.decode(&apos;utf-8&apos;, &apos;strict&apos;)</span><br><span class="line">        val = self.redis.get(self.key_prefix + sid)</span><br><span class="line">        if val is not None:</span><br><span class="line">            try:</span><br><span class="line">                data = self.serializer.loads(val)</span><br><span class="line">                return self.session_class(data, sid=sid)</span><br><span class="line">            except:</span><br><span class="line">                return self.session_class(sid=sid, permanent=self.permanent)</span><br><span class="line">        return self.session_class(sid=sid, permanent=self.permanent)</span><br><span class="line"></span><br><span class="line">    def save_session(self, app, session, response):</span><br><span class="line">        domain = self.get_cookie_domain(app)</span><br><span class="line">        path = self.get_cookie_path(app)</span><br><span class="line">        if not session:</span><br><span class="line">            if session.modified:</span><br><span class="line">                self.redis.delete(self.key_prefix + session.sid)</span><br><span class="line">                response.delete_cookie(app.session_cookie_name,</span><br><span class="line">                                       domain=domain, path=path)</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # Modification case.  There are upsides and downsides to</span><br><span class="line">        # emitting a set-cookie header each request.  The behavior</span><br><span class="line">        # is controlled by the :meth:`should_set_cookie` method</span><br><span class="line">        # which performs a quick check to figure out if the cookie</span><br><span class="line">        # should be set or not.  This is controlled by the</span><br><span class="line">        # SESSION_REFRESH_EACH_REQUEST config flag as well as</span><br><span class="line">        # the permanent flag on the session itself.</span><br><span class="line">        # if not self.should_set_cookie(app, session):</span><br><span class="line">        #    return</span><br><span class="line"></span><br><span class="line">        httponly = self.get_cookie_httponly(app)</span><br><span class="line">        secure = self.get_cookie_secure(app)</span><br><span class="line">        expires = self.get_expiration_time(app, session)</span><br><span class="line">        val = self.serializer.dumps(dict(session))</span><br><span class="line">        self.redis.setex(name=self.key_prefix + session.sid, value=val,</span><br><span class="line">                         time=total_seconds(app.permanent_session_lifetime))</span><br><span class="line">        if self.use_signer:</span><br><span class="line">            session_id = self._get_signer(app).sign(want_bytes(session.sid))</span><br><span class="line">        else:</span><br><span class="line">            session_id = session.sid</span><br><span class="line">        response.set_cookie(app.session_cookie_name, session_id,</span><br><span class="line">                            expires=expires, httponly=httponly,</span><br><span class="line">                            domain=domain, path=path, secure=secure)</span><br></pre></td></tr></table></figure>
<p>其中 sid的生成方式为sid = self._generate_sid()，故修改长度，仅需要修改_generate_sid方法即可。</p>
<p><strong>参考文献</strong></p>
<ol>
<li><a href="https://blog.csdn.net/weixin_34381666/article/details/93401565" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34381666/article/details/93401565</a></li>
</ol>
]]></content>
      <tags>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>hash算法总结</title>
    <url>/2019/08/17/hash%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="什么是hash算法"><a href="#什么是hash算法" class="headerlink" title="什么是hash算法"></a>什么是hash算法</h4><p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。散列函数，顾名思义，它是一个函数。我们可以把它定义成hash(key)，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值。<br>散列函数设计的基本要求：</p>
<ol>
<li>散列函数计算得到的散列值是一个非负整数;</li>
<li>如果key1 = key2，那hash(key1) == hash(key2);</li>
<li>如果key1 ≠ key2，那hash(key1) ≠ hash(key2)。</li>
</ol>
<h4 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h4><h5 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1.开放寻址法"></a>1.开放寻址法</h5><p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢?我先讲一个比较简单的探测方法，线 性探测(Linear Probing)。<br>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。<br>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，二次探测(Quadratic probing)和双重散列(Double hashing)<br>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是1，那它探测的下标序列就是hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变 成了原来的“二次方”，也就是说，它探测的下标序列就是hash(key)+0，hash(key)+12，hash(key)+22……<br>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存 储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。<br>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子(load factor)来表示空位的多少。<br>装载因子的计算公式是: 散列表的装载因子=填入表中的元素个数/散列表的长度</p>
<h5 id="2-链表法"><a href="#2-链表法" class="headerlink" title="2.链表法"></a>2.链表法</h5><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶(bucket)”或者“槽(slot)”会对应一条链表,所有散 列值相同的元素我们都放到相同槽位对应的链表中。<br>实际上，这两个操作的时间复杂度跟链表的长度k成正比，也就是O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中n表示散列中数据的个数,m表示散列表 中“槽”的个数。</p>
<h4 id="hash算法作用"><a href="#hash算法作用" class="headerlink" title="hash算法作用"></a>hash算法作用</h4><p>（1） 文件校验<br>　　我们比较熟悉的校验算法有奇偶校验和CRC校验，这2种校验并没有抗数据篡改的能力，它们一定程度上能检测并纠正数据传输中的信道误码，但却不能防止对数据的恶意破坏。MD5 Hash算法的“数字指纹”特性，使它成为目前应用最广泛的一种文件完整性校验和（Checksum）算法，不少Unix系统有提供计算md5 checksum的命令。<br>（2） 数字签名<br>　　Hash 算法也是现代密码体系中的一个重要组成部分。由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。 对 Hash 值，又称“数字摘要”进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。而且这样的协议还有其他的优点。<br>（3） 鉴权协议<br>   如下的鉴权协议又被称作挑战–认证模式：在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。</p>
<h4 id="hash算法设计注意事项"><a href="#hash算法设计注意事项" class="headerlink" title="hash算法设计注意事项"></a>hash算法设计注意事项</h4><p>1.如何设计散列表<br>首先，散列函数的设计不能太复杂。过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能。其次，散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。<br>2.装载因子过大了怎么办?<br>对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。<br>对于动态散列表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多;如果太小，会导致内存浪费严重。<br>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值;相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于1。<br>3.总结<br>当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是Java中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。<br>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。<br>4.工业级散列表举例分析<br>java中的hashmap：<br>1.初始大小<br>HashMap默认的初始大小是16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会 大大提高HashMap的性能。<br>2.装载因子和动态扩容<br>最大装载因子默认是0.75，当HashMap中元素个数超过0.75*capacity(capacity表示散列表的容量)的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。<br>3.散列冲突解决方法<br>HashMap底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。<br>于是，在JDK1.8版本中，为了对HashMap做进一步优化，我们引入了红黑树。而当链表长度太长(默认超过8)时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高HashMap的性能。当红黑树结点个数少于8个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起 链表来，性能上的优势并不明显。<br>4.散列函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int hash(Object key) &#123;</span><br><span class="line">int h = key.hashCode();</span><br><span class="line">&#125; </span><br><span class="line">return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1); //capicity表示散列表的大小</span><br><span class="line">其中，hashCode()返回的是Java对象的hash code。比如String类型的对象的hashCode()就是下面这样:</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">int var1 = this.hash;</span><br><span class="line">if(var1 == 0 &amp;&amp; this.value.length &gt; 0) &#123;</span><br><span class="line">	char[] var2 = this.value;</span><br><span class="line">	for(int var3 = 0; var3 &lt; this.value.length; ++var3) &#123;</span><br><span class="line">		var1 = 31 * var1 + var2[var3];</span><br><span class="line">	&#125;</span><br><span class="line">	this.hash = var1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return var1;</span><br></pre></td></tr></table></figure></p>
<h4 id="hash算法实现"><a href="#hash算法实现" class="headerlink" title="hash算法实现"></a>hash算法实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* Hash算法大全&lt;br&gt;</span><br><span class="line">* 推荐使用FNV1算法</span><br><span class="line">* @algorithm None</span><br><span class="line">* @author Goodzzp 2006-11-20</span><br><span class="line">* @lastEdit Goodzzp 2006-11-20</span><br><span class="line">* @editDetail Create</span><br><span class="line">*/</span><br><span class="line">public class HashAlgorithms</span><br><span class="line">&#123;</span><br><span class="line">  /**//**</span><br><span class="line">  * 加法hash</span><br><span class="line">  * @param key 字符串</span><br><span class="line">  * @param prime 一个质数</span><br><span class="line">  * @return hash结果</span><br><span class="line">  */</span><br><span class="line">  public static int additiveHash(String key, int prime)</span><br><span class="line">  &#123;</span><br><span class="line">    int hash, i;</span><br><span class="line">    for (hash = key.length(), i = 0; i &lt; key.length(); i++)</span><br><span class="line">      hash += key.charAt(i);</span><br><span class="line">    return (hash % prime);</span><br><span class="line">  &#125;</span><br><span class="line">  /**//**</span><br><span class="line">  * 旋转hash</span><br><span class="line">  * @param key 输入字符串</span><br><span class="line">  * @param prime 质数</span><br><span class="line">  * @return hash值</span><br><span class="line">  */</span><br><span class="line">  public static int rotatingHash(String key, int prime)</span><br><span class="line">  &#123;</span><br><span class="line">    int hash, i;</span><br><span class="line">    for (hash=key.length(), i=0; i&lt;key.length(); ++i)</span><br><span class="line">      hash = (hash&lt;&lt;4)^(hash&gt;&gt;28)^key.charAt(i);</span><br><span class="line">    return (hash % prime);</span><br><span class="line">    //  return (hash ^ (hash&gt;&gt;10) ^ (hash&gt;&gt;20));</span><br><span class="line">  &#125;</span><br><span class="line">  // 替代：</span><br><span class="line">  // 使用：hash = (hash ^ (hash&gt;&gt;10) ^ (hash&gt;&gt;20)) &amp; mask;</span><br><span class="line">  // 替代：hash %= prime;</span><br><span class="line">  /**//**</span><br><span class="line">  * MASK值，随便找一个值，最好是质数</span><br><span class="line">  */</span><br><span class="line">  static int M_MASK = 0x8765fed1;</span><br><span class="line">  /**//**</span><br><span class="line">  * 一次一个hash</span><br><span class="line">  * @param key 输入字符串</span><br><span class="line">  * @return 输出hash值</span><br><span class="line">  */</span><br><span class="line">  public static int oneByOneHash(String key)</span><br><span class="line">  &#123;</span><br><span class="line">    int  hash, i;</span><br><span class="line">    for (hash=0, i=0; i&lt;key.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      hash += key.charAt(i);</span><br><span class="line">      hash += (hash &lt;&lt; 10);</span><br><span class="line">      hash ^= (hash &gt;&gt; 6);</span><br><span class="line">    &#125;</span><br><span class="line">    hash += (hash &lt;&lt; 3);</span><br><span class="line">    hash ^= (hash &gt;&gt; 11);</span><br><span class="line">    hash += (hash &lt;&lt; 15);</span><br><span class="line">    //  return (hash &amp; M_MASK);</span><br><span class="line">    return hash;</span><br><span class="line">  &#125;</span><br><span class="line">  /**//**</span><br><span class="line">  * Bernstein&apos;s hash</span><br><span class="line">  * @param key 输入字节数组</span><br><span class="line">  * @param level 初始hash常量</span><br><span class="line">  * @return 结果hash</span><br><span class="line">  */</span><br><span class="line">  public static int bernstein(String key)</span><br><span class="line">  &#123;</span><br><span class="line">    int hash = 0;</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0; i&lt;key.length(); ++i) hash = 33*hash + key.charAt(i);</span><br><span class="line">    return hash;</span><br><span class="line">  &#125;</span><br><span class="line">  //</span><br><span class="line">  /**///// Pearson&apos;s Hash</span><br><span class="line">  // char pearson(char[]key, ub4 len, char tab[256])</span><br><span class="line">  // &#123;</span><br><span class="line">  //  char hash;</span><br><span class="line">  //  ub4 i;</span><br><span class="line">  //  for (hash=len, i=0; i&lt;len; ++i)</span><br><span class="line">  //   hash=tab[hash^key[i]];</span><br><span class="line">  //  return (hash);</span><br><span class="line">  // &#125;</span><br><span class="line">  /**///// CRC Hashing，计算crc,具体代码见其他</span><br><span class="line">  // ub4 crc(char *key, ub4 len, ub4 mask, ub4 tab[256])</span><br><span class="line">  // &#123;</span><br><span class="line">  //  ub4 hash, i;</span><br><span class="line">  //  for (hash=len, i=0; i&lt;len; ++i)</span><br><span class="line">  //   hash = (hash &gt;&gt; 8) ^ tab[(hash &amp; 0xff) ^ key[i]];</span><br><span class="line">  //  return (hash &amp; mask);</span><br><span class="line">  // &#125;</span><br><span class="line">  /**//**</span><br><span class="line">  * Universal Hashing</span><br><span class="line">  */</span><br><span class="line">  public static int universal(char[]key, int mask, int[] tab)</span><br><span class="line">  &#123;</span><br><span class="line">    int hash = key.length, i, len = key.length;</span><br><span class="line">    for (i=0; i&lt;(len&lt;&lt;3); i+=8)</span><br><span class="line">    &#123;</span><br><span class="line">      char k = key[i&gt;&gt;3];</span><br><span class="line">      if ((k&amp;0x01) == 0) hash ^= tab[i+0];</span><br><span class="line">      if ((k&amp;0x02) == 0) hash ^= tab[i+1];</span><br><span class="line">      if ((k&amp;0x04) == 0) hash ^= tab[i+2];</span><br><span class="line">      if ((k&amp;0x08) == 0) hash ^= tab[i+3];</span><br><span class="line">      if ((k&amp;0x10) == 0) hash ^= tab[i+4];</span><br><span class="line">      if ((k&amp;0x20) == 0) hash ^= tab[i+5];</span><br><span class="line">      if ((k&amp;0x40) == 0) hash ^= tab[i+6];</span><br><span class="line">      if ((k&amp;0x80) == 0) hash ^= tab[i+7];</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash &amp; mask);</span><br><span class="line">  &#125;</span><br><span class="line">  /**//**</span><br><span class="line">  * Zobrist Hashing</span><br><span class="line">  */</span><br><span class="line">  public static int zobrist( char[] key,int mask, int[][] tab)</span><br><span class="line">  &#123;</span><br><span class="line">    int hash, i;</span><br><span class="line">    for (hash=key.length, i=0; i&lt;key.length; ++i)</span><br><span class="line">      hash ^= tab[i][key[i]];</span><br><span class="line">    return (hash &amp; mask);</span><br><span class="line">  &#125;</span><br><span class="line">  // LOOKUP3</span><br><span class="line">  // 见Bob Jenkins(3).c文件</span><br><span class="line">  // 32位FNV算法</span><br><span class="line">  static int M_SHIFT = 0;</span><br><span class="line">  /**//**</span><br><span class="line">  * 32位的FNV算法</span><br><span class="line">  * @param data 数组</span><br><span class="line">  * @return int值</span><br><span class="line">  */</span><br><span class="line">  public static int FNVHash(byte[] data)</span><br><span class="line">  &#123;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(byte b : data)</span><br><span class="line">      hash = (hash * 16777619) ^ b;</span><br><span class="line">    if (M_SHIFT == 0)</span><br><span class="line">      return hash;</span><br><span class="line">    return (hash ^ (hash &gt;&gt; M_SHIFT)) &amp; M_MASK;</span><br><span class="line">  &#125;</span><br><span class="line">  /**//**</span><br><span class="line">  * 改进的32位FNV算法1</span><br><span class="line">  * @param data 数组</span><br><span class="line">  * @return int值</span><br><span class="line">  */</span><br><span class="line">  public static int FNVHash1(byte[] data)</span><br><span class="line">  &#123;</span><br><span class="line">    final int p = 16777619;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(byte b:data)</span><br><span class="line">      hash = (hash ^ b) * p;</span><br><span class="line">    hash += hash &lt;&lt; 13;</span><br><span class="line">    hash ^= hash &gt;&gt; 7;</span><br><span class="line">    hash += hash &lt;&lt; 3;</span><br><span class="line">    hash ^= hash &gt;&gt; 17;</span><br><span class="line">    hash += hash &lt;&lt; 5;</span><br><span class="line">    return hash;</span><br><span class="line">  &#125;</span><br><span class="line">  /**//**</span><br><span class="line">  * 改进的32位FNV算法1</span><br><span class="line">  * @param data 字符串</span><br><span class="line">  * @return int值</span><br><span class="line">  */</span><br><span class="line">  public static int FNVHash1(String data)</span><br><span class="line">  &#123;</span><br><span class="line">    final int p = 16777619;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(int i=0;i&lt;data.length();i++)</span><br><span class="line">      hash = (hash ^ data.charAt(i)) * p;</span><br><span class="line">    hash += hash &lt;&lt; 13;</span><br><span class="line">    hash ^= hash &gt;&gt; 7;</span><br><span class="line">    hash += hash &lt;&lt; 3;</span><br><span class="line">    hash ^= hash &gt;&gt; 17;</span><br><span class="line">    hash += hash &lt;&lt; 5;</span><br><span class="line">    return hash;</span><br><span class="line">  &#125;</span><br><span class="line">  /**//**</span><br><span class="line">  * Thomas Wang的算法，整数hash</span><br><span class="line">  */</span><br><span class="line">  public static int intHash(int key)</span><br><span class="line">  &#123;</span><br><span class="line">    key += ~(key &lt;&lt; 15);</span><br><span class="line">    key ^= (key &gt;&gt;&gt; 10);</span><br><span class="line">    key += (key &lt;&lt; 3);</span><br><span class="line">    key ^= (key &gt;&gt;&gt; 6);</span><br><span class="line">    key += ~(key &lt;&lt; 11);</span><br><span class="line">    key ^= (key &gt;&gt;&gt; 16);</span><br><span class="line">    return key;</span><br><span class="line">  &#125;</span><br><span class="line">  /**//**</span><br><span class="line">  * RS算法hash</span><br><span class="line">  * @param str 字符串</span><br><span class="line">  */</span><br><span class="line">  public static int RSHash(String str)</span><br><span class="line">  &#123;</span><br><span class="line">    int b  = 378551;</span><br><span class="line">    int a  = 63689;</span><br><span class="line">    int hash = 0;</span><br><span class="line">    for(int i = 0; i &lt; str.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      hash = hash * a + str.charAt(i);</span><br><span class="line">      a  = a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">  &#125;</span><br><span class="line">  /**//* End Of RS Hash Function */</span><br><span class="line">  /**//**</span><br><span class="line">  * JS算法</span><br><span class="line">  */</span><br><span class="line">  public static int JSHash(String str)</span><br><span class="line">  &#123;</span><br><span class="line">    int hash = 1315423911;</span><br><span class="line">    for(int i = 0; i &lt; str.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      hash ^= ((hash &lt;&lt; 5) + str.charAt(i) + (hash &gt;&gt; 2));</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">  &#125;</span><br><span class="line">  /**//* End Of JS Hash Function */</span><br><span class="line">  /**//**</span><br><span class="line">  * PJW算法</span><br><span class="line">  */</span><br><span class="line">  public static int PJWHash(String str)</span><br><span class="line">  &#123;</span><br><span class="line">    int BitsInUnsignedInt = 32;</span><br><span class="line">    int ThreeQuarters   = (BitsInUnsignedInt * 3) / 4;</span><br><span class="line">    int OneEighth     = BitsInUnsignedInt / 8;</span><br><span class="line">    int HighBits     = 0xFFFFFFFF &lt;&lt; (BitsInUnsignedInt - OneEighth);</span><br><span class="line">    int hash       = 0;</span><br><span class="line">    int test       = 0;</span><br><span class="line">    for(int i = 0; i &lt; str.length();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      hash = (hash &lt;&lt; OneEighth) + str.charAt(i);</span><br><span class="line">      if((test = hash &amp; HighBits) != 0)</span><br><span class="line">      &#123;</span><br><span class="line">        hash = (( hash ^ (test &gt;&gt; ThreeQuarters)) &amp; (~HighBits));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">  &#125;</span><br><span class="line">  /**//* End Of P. J. Weinberger Hash Function */</span><br><span class="line">  /**//**</span><br><span class="line">  * ELF算法</span><br><span class="line">  */</span><br><span class="line">  public static int ELFHash(String str)</span><br><span class="line">  &#123;</span><br><span class="line">    int hash = 0;</span><br><span class="line">    int x  = 0;</span><br><span class="line">    for(int i = 0; i &lt; str.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      hash = (hash &lt;&lt; 4) + str.charAt(i);</span><br><span class="line">      if((x = (int)(hash &amp; 0xF0000000L)) != 0)</span><br><span class="line">      &#123;</span><br><span class="line">        hash ^= (x &gt;&gt; 24);</span><br><span class="line">        hash &amp;= ~x;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">  &#125;</span><br><span class="line">  /**//* End Of ELF Hash Function */</span><br><span class="line">  /**//**</span><br><span class="line">  * BKDR算法</span><br><span class="line">  */</span><br><span class="line">  public static int BKDRHash(String str)</span><br><span class="line">  &#123;</span><br><span class="line">    int seed = 131; // 31 131 1313 13131 131313 etc..</span><br><span class="line">    int hash = 0;</span><br><span class="line">    for(int i = 0; i &lt; str.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      hash = (hash * seed) + str.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">  &#125;</span><br><span class="line">  /**//* End Of BKDR Hash Function */</span><br><span class="line">  /**//**</span><br><span class="line">  * SDBM算法</span><br><span class="line">  */</span><br><span class="line">  public static int SDBMHash(String str)</span><br><span class="line">  &#123;</span><br><span class="line">    int hash = 0;</span><br><span class="line">    for(int i = 0; i &lt; str.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      hash = str.charAt(i) + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">  &#125;</span><br><span class="line">  /**//* End Of SDBM Hash Function */</span><br><span class="line">  /**//**</span><br><span class="line">  * DJB算法</span><br><span class="line">  */</span><br><span class="line">  public static int DJBHash(String str)</span><br><span class="line">  &#123;</span><br><span class="line">    int hash = 5381;</span><br><span class="line">    for(int i = 0; i &lt; str.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      hash = ((hash &lt;&lt; 5) + hash) + str.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">  &#125;</span><br><span class="line">  /**//* End Of DJB Hash Function */</span><br><span class="line">  /**//**</span><br><span class="line">  * DEK算法</span><br><span class="line">  */</span><br><span class="line">  public static int DEKHash(String str)</span><br><span class="line">  &#123;</span><br><span class="line">    int hash = str.length();</span><br><span class="line">    for(int i = 0; i &lt; str.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      hash = ((hash &lt;&lt; 5) ^ (hash &gt;&gt; 27)) ^ str.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">  &#125;</span><br><span class="line">  /**//* End Of DEK Hash Function */</span><br><span class="line">  /**//**</span><br><span class="line">  * AP算法</span><br><span class="line">  */</span><br><span class="line">  public static int APHash(String str)</span><br><span class="line">  &#123;</span><br><span class="line">    int hash = 0;</span><br><span class="line">    for(int i = 0; i &lt; str.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      hash ^= ((i &amp; 1) == 0) ? ( (hash &lt;&lt; 7) ^ str.charAt(i) ^ (hash &gt;&gt; 3)) :</span><br><span class="line">    (~((hash &lt;&lt; 11) ^ str.charAt(i) ^ (hash &gt;&gt; 5)));</span><br><span class="line">    &#125;</span><br><span class="line">    //    return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">    return hash;</span><br><span class="line">  &#125;</span><br><span class="line">  /**//* End Of AP Hash Function */</span><br><span class="line">  /**//**</span><br><span class="line">  * JAVA自己带的算法</span><br><span class="line">  */</span><br><span class="line">  public static int java(String str)</span><br><span class="line">  &#123;</span><br><span class="line">    int h = 0;</span><br><span class="line">    int off = 0;</span><br><span class="line">    int len = str.length();</span><br><span class="line">    for (int i = 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      h = 31 * h + str.charAt(off++);</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">  &#125;</span><br><span class="line">  /**//**</span><br><span class="line">  * 混合hash算法，输出64位的值</span><br><span class="line">  */</span><br><span class="line">  public static long mixHash(String str)</span><br><span class="line">  &#123;</span><br><span class="line">    long hash = str.hashCode();</span><br><span class="line">    hash &lt;&lt;= 32;</span><br><span class="line">    hash |= FNVHash1(str);</span><br><span class="line">    return hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.jb51.net/article/124819.htm" target="_blank" rel="noopener">https://www.jb51.net/article/124819.htm</a></p>
]]></content>
  </entry>
  <entry>
    <title>ip命令小结</title>
    <url>/2021/04/15/ip%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>ip 命令的功能很多,基本上它整合了 ifconfig 与 route 这两个命令，不过ip 的功能更强大！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip [option] [动作] [命令]</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">option ：设定的参数，主要有：</span><br><span class="line"></span><br><span class="line">     -s ：显示出该设备的统计数据(statistics)，例如总接受封包数等；</span><br><span class="line"></span><br><span class="line">  动作：就是是可以针对哪些网络参数进行动作，包括有：</span><br><span class="line"></span><br><span class="line">       link ：关于设备 (device) 的相关设定，包括 MTU, MAC 地址等等</span><br><span class="line"></span><br><span class="line">       addr/address ：关于额外的 IP 设定，例如多 IP 的实现等等；</span><br><span class="line"></span><br><span class="line">       route ：与路由有关的相关设定</span><br></pre></td></tr></table></figure>
<h4 id="关于设备-device-的相关设定：-ip-link"><a href="#关于设备-device-的相关设定：-ip-link" class="headerlink" title="关于设备(device) 的相关设定： ip link"></a>关于设备(device) 的相关设定： ip link</h4><p>ip link 可以设定与设备 (device) 有关的相关设定，包括 MTU 以及该网络设备的 MAC 等等， 当然也可以启动 (up) 或关闭 (down) 某个网络设备。整个语法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip [-s] link show &lt;== 单纯的查阅该设备相关的信息</span><br><span class="line">[root@linux ~]# ip link set [device] [动作与参数]</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">show：仅显示出这个设备的相关内容，如果加上 -s 会显示更多统计数据；</span><br><span class="line">set ：可以开始设定项目， device 指的是 eth0, eth1 等等设备代号；</span><br><span class="line"></span><br><span class="line">动作与参数：包括以下动作：</span><br><span class="line">   up|down ：启动 (up) 或关闭 (down) 某个设备，其他参数使用预设的以太网参数；</span><br><span class="line">   address ：如果这个设备可以更改 MAC ，用这个参数修改；</span><br><span class="line">   name     ：给予这个设备一个特殊的名字；</span><br><span class="line">   mtu      ：设置最大传输单元。</span><br></pre></td></tr></table></figure>
<p><strong>范例一：显示出所有的设备信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip link show</span><br><span class="line"></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,10000&gt; mtu 16436 qdisc noqueue</span><br><span class="line"></span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line"></span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,10000&gt; mtu 1500 qdisc pfifo_fast qlen 1000</span><br><span class="line"></span><br><span class="line">    link/ether 00:50:fc:22:9a:cb brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line">3: sit0: &lt;NOARP&gt; mtu 1480 qdisc noop</span><br><span class="line"></span><br><span class="line">    link/sit 0.0.0.0 brd 0.0.0.0 </span><br><span class="line"></span><br><span class="line">[root@linux ~]# ip -s link show eth0</span><br><span class="line"></span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,10000&gt; mtu 1500 qdisc pfifo_fast qlen 1000</span><br><span class="line"></span><br><span class="line">    link/ether 00:50:fc:22:9a:cb brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line">    RX: bytes packets errors dropped overrun mcast</span><br><span class="line"></span><br><span class="line">    484011792 2247372 0       0       0       0</span><br><span class="line"></span><br><span class="line">    TX: bytes packets errors dropped carrier collsns</span><br><span class="line"></span><br><span class="line">    2914104290 2867753 0       0       0       0</span><br></pre></td></tr></table></figure>
<p>使用 ip link show 可以显示出整个设备的硬件相关信息，如上所示，包括 MAC地址、MTU等等， 比较有趣的应该是那个 sit0 的设备了，那个 sit0 的设备是将IPv4 和 IPv6 的封包进行转换， 对于我们仅使用 IPv4 的网络是没有作用的。 lo 及 sit0 都是主机内部自行设定的。 而如果加上 -s 的参数后，则这个网卡的相关统计信息就会被列出来， 包括接收 (RX) 及传送 (TX) 的封包数量等等，详细的内容与 ifconfig 所输出的结果相同。</p>
<p><strong>范例二：启动、关闭与设定设备的相关信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip link set eth0 up</span><br><span class="line"></span><br><span class="line"># 启动eth0这个设备； </span><br><span class="line"></span><br><span class="line">[root@linux ~]# ip link set eth0 down</span><br><span class="line"></span><br><span class="line"># 关闭eth0这个设备； </span><br><span class="line"></span><br><span class="line">[root@linux ~]# ip link set eth0 mtu 1000</span><br><span class="line"></span><br><span class="line"># 更改 MTU为1000 bytes，单位就是 bytes 。</span><br></pre></td></tr></table></figure>
<p><strong>范例三：修改网卡代号、MAC 等参数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip link set eth0 name vbird</span><br><span class="line"></span><br><span class="line">SIOCSIFNAME: Device or resource busy</span><br><span class="line"></span><br><span class="line"># 因为该设备目前是启动的，所以不能这样做设定。你应该要这样做： </span><br><span class="line"></span><br><span class="line">[root@linux ~]# ip link set eth0 down       &lt;==关闭设备</span><br><span class="line"></span><br><span class="line">[root@linux ~]# ip link set eth0 name vbird &lt;==重新设定</span><br><span class="line"></span><br><span class="line">[root@linux ~]# ip link show                &lt;==查看信息</span><br><span class="line"></span><br><span class="line">2. vbird: &lt;BROADCAST,MILTICASE&gt; mtu 900 qdisc pfifo_fast qlen 1000</span><br><span class="line"></span><br><span class="line">    link/ehter 00:40:d0:13:c3:46 brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line"># 呵呵，连网卡代号都可以改变！不过，玩玩后记得改回来啊！</span><br><span class="line"></span><br><span class="line"># 因为我们的 ifcfg-eth0 还是使用原本的设备代号！避免有问题，要改回来</span><br><span class="line"></span><br><span class="line">[root@linux ~]# ip link set vbird name eth0 &lt;==设备改回来 </span><br><span class="line"></span><br><span class="line">[root@linux ~]# ip link set eth0 address aa:aa:aa:aa:aa:aa</span><br><span class="line"></span><br><span class="line">[root@linux ~]# ip link show eth0</span><br></pre></td></tr></table></figure>
<h4 id="IP-相关设定：-ip-address"><a href="#IP-相关设定：-ip-address" class="headerlink" title="IP 相关设定： ip address"></a>IP 相关设定： ip address</h4><p>如果说 ip link 是与 OSI 七层模型的第二层数据链路层有关的话，那么 ip address (ip addr) 就是与第三层网络层有关的了。主要是在设定与 IP 有关的各项参数，包括 netmask, broadcast 等等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip address show   &lt;==查看IP参数</span><br><span class="line">[root@linux ~]# ip address [add|del] [IP参数] [dev 设备名] [相关参数]</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">show  ：单纯的显示出设备的 IP 信息；</span><br><span class="line">add|del ：进行相关参数的增加 (add) 或删除 (del) 设定，主要有：</span><br><span class="line">IP 参数 ：主要就是网域的设定，例如 192.168.100.100/24 之类的设定；</span><br><span class="line">dev ：这个 IP 参数所要设定的设备，例如 eth0, eth1 等等；</span><br><span class="line"></span><br><span class="line"> 相关参数：如下所示：</span><br><span class="line">        broadcast：设定广播位址，如果设定值是 + 表示让系统自动计算；</span><br><span class="line">        label    ：该设备的别名，例如eth0:0；</span><br><span class="line">        scope    ：这个设备的领域，通常是以下几个大类：</span><br><span class="line">                   global ：允许来自所有来源的连线；</span><br><span class="line">                   site   ：仅支持IPv6 ，仅允许本主机的连接；</span><br><span class="line">                   link   ：仅允许本设备自我连接；</span><br><span class="line">                   host   ：仅允许本主机内部的连接；</span><br><span class="line">                   所以当然是使用 global 了。预设也是 global ！</span><br></pre></td></tr></table></figure>
<p><strong>范例一：显示出所有设备的 IP 参数：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip address show</span><br><span class="line"></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,10000&gt; mtu 16436 qdisc noqueue</span><br><span class="line"></span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line"></span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line"></span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line"></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,10000&gt; mtu 1500 qdisc pfifo_fast qlen 1000</span><br><span class="line"></span><br><span class="line">    link/ether 00:50:fc:22:9a:cb brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line">    inet 192.168.1.2/24 brd 192.168.1.255 scope global eth0</span><br><span class="line"></span><br><span class="line">    inet6 fe80::250:fcff:fe22:9acb/64 scope link</span><br><span class="line"></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">3: sit0: &lt;NOARP&gt; mtu 1480 qdisc noop</span><br><span class="line"></span><br><span class="line">    link/sit 0.0.0.0 brd 0.0.0.0</span><br></pre></td></tr></table></figure>
<p><strong>范例二：新增一个设备，名称假设为 eth0:vbird </strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip address add 192.168.50.50/24 broadcast + /</span><br><span class="line"></span><br><span class="line">&gt; dev eth0 label eth0:vbird</span><br><span class="line"></span><br><span class="line">[root@linux ~]# ip address show eth0</span><br><span class="line"></span><br><span class="line">2: eth0: mtu 1500 qdisc pfifo_fast qlen 1000</span><br><span class="line"></span><br><span class="line">    link/ether 00:40:d0:13:c3:46 brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line">    inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0</span><br><span class="line"></span><br><span class="line">    inet 192.168.50.50/24 brd 192.168.50.255 scope global eth0:vbird</span><br><span class="line"></span><br><span class="line">    inet6 fe80::240:d0ff:fe13:c346/64 scope link</span><br><span class="line"></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p><strong>范例三：将刚刚的设备删除</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip address del 192.168.50.50/24 dev eth0</span><br></pre></td></tr></table></figure>
<h4 id="路由的设定：-ip-route"><a href="#路由的设定：-ip-route" class="headerlink" title="路由的设定： ip route"></a>路由的设定： ip route</h4><p>这个项目就是路由的查看与设定。事实上ip route 的功能几乎与 route 这个命令一样，但是，它还可以进行额外的参数设置，例如 MTU 的规划等等，相当的强悍啊！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip route show &lt;==单纯的显示出路由的设定</span><br><span class="line"></span><br><span class="line">[root@linux ~]# ip route [add|del] [IP或网域] [via gateway] [dev 设备]</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">show ：单纯的显示出路由表，也可以使用 list ；</span><br><span class="line"></span><br><span class="line">add|del ：增加 (add) 或删除 (del) 路由；</span><br><span class="line"></span><br><span class="line">    IP或网域：可使用 192.168.50.0/24 之类的网域或者是单纯的 IP ；</span><br><span class="line"></span><br><span class="line">    via     ：从那个 gateway 出去，不一定需要；</span><br><span class="line"></span><br><span class="line">    dev     ：由那个设备连出去，需要；</span><br><span class="line"></span><br><span class="line">    mtu     ：可以额外的设定 MTU 的数值；</span><br></pre></td></tr></table></figure>
<p><strong>范例一：显示出目前的路由资料</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip route show</span><br><span class="line"></span><br><span class="line">192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.2</span><br><span class="line"></span><br><span class="line">169.254.0.0/16 dev eth1 scope link</span><br><span class="line"></span><br><span class="line">default via 192.168.1.254 dev eth1</span><br></pre></td></tr></table></figure>
<p><strong>范例二：增加路由，主要是本机直接可沟通的网域</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip route add 192.168.5.0/24 dev eth0</span><br></pre></td></tr></table></figure>
<p><strong>范例三：增加可以通往外部的路由，需透过 router ；</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip route add 192.168.10.0/24 via 192.168.5.100 dev eth0</span><br><span class="line"></span><br><span class="line">[root@linux ~]# ip route show</span><br><span class="line"></span><br><span class="line">192.168.5.0/24 dev eth0 scope link</span><br></pre></td></tr></table></figure>
<p><strong>范例四：增加预设路由</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@linux ~]# ip route add default via 192.168.1.2 dev eth0</span><br><span class="line"></span><br><span class="line"># 那个 192.168.1.2 就是我的预设路由器(gateway)；</span><br></pre></td></tr></table></figure></p>
<p><strong>范例五：删除路由</strong></p>
<p>[root@linux ~]# ip route del 192.168.10.0/24</p>
<p>[root@linux ~]# ip route del 192.168.5.0/24 </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用 ifconfig, ifup , ifdown 与 route 即可， 等以后有经验了之后，再继续回来玩 ip 这个好玩的命令吧！有兴趣的话，也可以自行参考 ethtool 这个命令！</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter源码学习三-jmete基础组件</title>
    <url>/2020/02/22/jmeter%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%89/</url>
    <content><![CDATA[<h4 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h4><ul>
<li>测试计划<br>任何测试计划(test plan)的第一个元素，所有控制器(Controller)和取样器(Sampler)必须作为线程组的子元素，其它元素，如监听器(Listener),可直接作为测试计划的子元素,这种情况下，子元素将作用于所有线程组。<br><img src="/2020/02/22/jmeter源码学习三/jmeter1.png" alt="avatar"></li>
<li>线程Threads(Users)<br><img src="/2020/02/22/jmeter源码学习三/jmeter2.png" alt="avatar"><br>线程组主要用于控制执行测试的线程数量，允许:</li>
</ul>
<ol>
<li>取样错误后要执行的动作<br>a.继续：默认选项，出错后后续的线程继续运行<br>b.Start Next Thread Loop：出错后启动下一组线程运行<br>c.停止线程：后续的线程停止运行，但是会返回出错前的结果<br>d.停止测试：与停止线程的差异在于不返回出错前的结果<br>5)Delay Thread Creation until needed：直到需要时延迟线程的创建<br>6)调度器：设定测试运行时间：比如，我们在要设置此线程组的执行时长为30分钟，我们可以设置脚本运行的开始时间及结束时间，在工具栏点击启动按钮，此测试计划便可按指定的时间执行测试。</li>
<li>设置线程数量 ：<br>虚拟用户数，代表发送请求的用户数，一个线程数占用一个进程或线程。</li>
<li>设置ramp-up period<br>所有线程在多少时间内启动，单位是秒，为0时代表一次请求即并发。如果线程数为30，Ramp-Up Period为2，由表示30个用户线程在2s内全部启动，这个设置，让用户并发广义上的并发，也就是说是在2s内，这30个虚拟用户，每个用户以2/30s的间隔登录系统,达到多用户并发在线的状态。<br>TIPS：ramp-up period时间设置要适当，不能太短，防止测试开始时会产生过大的工作负载,也不能太长，必须保证最后一个线程在第一个线程结束之前开始运行(除非故意要那样做).一般情况下，可设置Ramp-up period = 线程数，在此基础上，根据需要上下调整</li>
<li>设置执行测试的次数<br>每个线程发送请求的次数。如果线程数为30，循环次数为8，那么每个线程发送100次请求，那么此次的性能测试计划共向应用系统发送业务请求次数是30<em>100</em>8＝24000次，以达到业务高请求。</li>
<li>Delay Thread Creation until needed：直到需要时延迟线程的创建</li>
<li>调度器：设定测试运行时间：比如，我们在要设置此线程组的执行时长为30分钟，我们可以设置脚本运行的开始时间及结束时间，在工具栏点击启动按钮，此测试计划便可按指定的时间执行测试。</li>
</ol>
<h4 id="控制器（Controllers-）"><a href="#控制器（Controllers-）" class="headerlink" title="控制器（Controllers ）"></a>控制器（Controllers ）</h4><p>Jmeter 拥有两种类型的控制器:取样器(Sampler)和逻辑控制器(Logical Controller)</p>
<ul>
<li>取样器(Sampler)<br>Sampler:用于发送请求给服务器.例如，如果你想发送一个HTTP请求,添加一个“HTTP请求”Sampler，按它们出现在测试计划tree视图中的顺序执行Sampler。<br>Sampler包含:<br>FTP Request<br>HTTP Request<br>JDBC Request<br>Java object request<br>LDAP Request<br>SOAP/XML-RPC Request<br>WebService (SOAP) Request<br>如果要发送多个相同类型的请求(比如，HTTP请求)到相同服务器,可考虑使用一个默认配置元件.一个控制器有一个或多个缺省的默认元件。记得添加一个监听器到测试计划以便查看或存储请求结果到磁盘.添加Asertion到Sampler,查看Jmeter对请求响应的基本验证.例如,在web应用压测中，服务器可能返回一个成功的”HTTP Response”的代码,但是页面可能有错误，或者缺失.你可以添加一个assertion来检查某些html标签(tag)，符串等.（可用正则表达式）<br><img src="/2020/02/22/jmeter源码学习三/jmeter3.png" alt="avatar"></li>
<li>逻辑控制器(Logical Controller)<br>Logical Controller用于自定义发送请求的逻辑,可改变它的子元素的请求顺序，重复次数等.<br><img src="/2020/02/22/jmeter源码学习三/jmeter4.png" alt="avatar"></li>
<li>测试片段（Test Fragments）<br>Test Fragment为一种特殊类型的控制器，和tree视图中和线程组处在同一层次。和线程组不同的是，除非被模块控制器(Module Controller)或者包含控制器(Include_Controller)引用，否则不会被执行</li>
<li>监听器（Listeners）<br>Listeners提供对Jmeter在运行测试案例时采集的信息访问.图形结果树(Graph Results)监听器在图形上绘制响应时间；“查看结果树(View Results Tree)”监听器显示request和response取样器的详细信息，且可展示基于HTML和XML的响应表现形式.其它监听器提供，摘要或汇总信——此外，监听器可指示保存数据到一个文件，供后续使用。每个监听器提供一个输入域来填写，保存数据的文件</li>
<li>定时器（Timers ）<br>Jmeter不间断的线程发送每个请求。建议添加一个定时器到线程组，来设置一个延迟。如果你不添加延迟，Jmeter可能在一段很短的时间内制造大量请求压倒服务器.定时器将导致Jmeter在发送定时器作用范围内的每个sampler前等待一段时间。如果添加多于一个定时器到线程组，Jmeter采用定时器的设置的延迟时间的总和，执行每个请求取样器前等待一段时间，该时间为前面的时间总合。定时器可以添加到sampler或controller以约束他们要影响的sampler.</li>
<li>断言（Assertions ）<br>断言允许你预测从被测服务器接收的真实结果.使用断言，可测试你的应用程序是否返回你要的结果.</li>
<li>前置处理器（Pre-Processor Elements ）<br>一个Pre-Processor优先于Sampler Request.如果一个Pre-Processor关联到一个Sampler,那么它优先于sampler运行. Pre-Processor最经常用来修改Sampler请求的的设置或更新非来字响应文本的变量.</li>
<li>后置处理器 （Post-Processor Elements ）<br>比Sampler Request后执行。常用来处理响应数据或从中提取值</li>
</ul>
<h4 id="执行顺序-（Execution-order-）"><a href="#执行顺序-（Execution-order-）" class="headerlink" title="执行顺序 （Execution order ）"></a>执行顺序 （Execution order ）</h4><p>在test plan（测试计划）中的元件按照以下顺序执行：<br>（1） Config Elements<em>**</em>（配置元件）<br>（2） Pre-porcessors（前置处理器）<br>（3） Timer（定时器）<br>（4） Sampler（取样器），Test Fragment（测试片段 , 跟函数没有区别，所以个人觉得可以直接理解为一个Sampler）<br>（5） Post-porcessors（后置处理器）<br>（6） Assertions（断言）<br>（7） Listener（监听器）</p>
<p>注意：定时器,断言,前、后置处理器仅在有Sampler的情况下才被执行，Logic Controllers 和Samplers按tree视图中的顺序执行。其它元素依据他们的所处的作用域范围和类型进行处理，同种类型的元素按他们出现在tree视图的顺序进行处理。<br>例如<br>Controller<br>Post-Processor 1<br>Sampler 1<br>Sampler 2<br>Timer 1<br>Assertion 1<br>Pre-Processor 1<br>Timer 2<br>Post-Processor 2</p>
<p>执行顺序为：</p>
<p>Pre-Processor 1<br>Timer 1<br>Timer 2<br>Sampler 1<br>Post-Processor 1<br>Post-Processor 2<br>Assertion 1<br>Pre-Processor 1<br>Timer 1<br>Timer 2<br>Sampler 2<br>Post-Processor 1<br>Post-Processor 2<br>Assertion 1</p>
<h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4><ol>
<li>sampler（取样器），包含http请求、ftp请求等。没有作用域。网上说是器与其他元件产生交互所以没有作用域。但我个人觉得存在交互，比如用户自定义参数、正则提取器。所以个人认为是有作用域的，只不过范围比较小。</li>
<li>Logic Controller（逻辑控制器），内包含各种控制器，如if、foeach等控制器。其本身只对其子节点的sampler有效。</li>
<li>Config Elements（配置元件）：包含session、cookie等管理器，影响其范围内的所有元件。</li>
<li>Pre-porcessors（前置处理器）：在sampler之前执行，如sampler需要大量参数配置时（如post请求需要携带大量参数），作用域其范围内的sampler。</li>
<li>Post-porcessors（后置处理器）：在sampler之后执行，如下一个请求需要钱一个请求请求结果时。作用域其范围内的sampler。</li>
<li>Timer（定时器）：对其作用范围内的每一个sampler有效</li>
<li>Assertions（断言）：对其作用范围内的每一个sampler元件的响应头Response Headers、响应体Response body、或者请求头等做出校验。</li>
<li>Listener（监听器）：收集其作用范围内的每一个sampler元件的执行情况，返回并统计。可表格形式展现，也可图表形式，不过图表形式可能需要安装扩展插件。</li>
<li>Test Fragment（测试片段），它的主要作用是模块化测试过程，类似于编程语言中的函数。即，将测试过程封装成测试片段，就可以在其他地方直接引用了。作用范围内的每一个sampler。</li>
</ol>
]]></content>
      <tags>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter源码学习二</title>
    <url>/2020/01/05/jmeter%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%BA%8C/</url>
    <content><![CDATA[<h4 id="hash树"><a href="#hash树" class="headerlink" title="hash树"></a>hash树</h4><p>理想的情况是希望不经过任何比较，一次存取便能得到所查的记录， 那就必须在记的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和一个唯一的存储位置相对应。因而在查找时，只要根据这个对应关系f找到 给定值K的像f(K)。由此，不需要进行比较便可直接取得所查记录。在此，我们称这个对应关系为哈希（Hash）函数，按这个思想建立的表为哈希表。</p>
<p>在哈希表中对于不同的关键字可能得到同一哈希地址，这种现象称做冲突。在一般情况下，冲突只能尽可能地减少，而不能完全避免。因为哈希函数是从关键字集合 到地址集合的映像。通常关键字的集合比较大，它的元素包括所有可能的关键字，而地址集合的元素仅为哈希表中的地址值。在一般情况下，哈希函数是一个压缩映像函数，这就不可避免的要产生冲突。</p>
<h4 id="哈希树的理论基础"><a href="#哈希树的理论基础" class="headerlink" title="哈希树的理论基础"></a>哈希树的理论基础</h4><p>【质数分辨定理】<br>简单地说就是：n个不同的质数可以“分辨”的连续整数的个数和他们的乘积相等。“分辨”就是指这些连续的整数不可能有完全相同的余数序列。<br><img src="/2020/01/05/jmeter源码学习二/jmeter1.png" alt="avatar"><br>例如：<br>从2起的连续质数，连续10个质数就可以分辨大约M(10) =2<em>3</em>5<em>7</em>11<em>13</em>17<em>19</em>23*29= 6464693230 个数，已经超过计算机中常用整数（32bit）的表达范围。连续100个质数就可以分辨大约M(100) = 4.711930 乘以10的219次方。</p>
<ul>
<li>插入</li>
</ul>
<p>我们选择质数分辨算法来建立一棵哈希树。<br>选择从2开始的连续质数来建立一个十层的哈希树。第一层结点为根结点，根结点下有2个结点；第二层的每个结点下有3个结点；依此类推，即每层结点的子节点数目为连续的质数。到第十层，每个结点下有29个结点。<br>同一结点中的子结点，从左到右代表不同的余数结果。<br>例如：第二层结点下有三个子节点。那么从左到右分别代表：除3余0，除3余1，除3余2.<br>对质数进行取余操作得到的余数决定了处理的路径。</p>
<p>下面我们以随机的10个数的插入为例，来图解HashTree的插入过程<br><img src="/2020/01/05/jmeter源码学习二/jmeter2.png" alt="avatar"></p>
<ul>
<li>优点</li>
</ul>
<p>– 结构简单<br>从 HashTree 的结构来说，非常的简单。每层节点的子节点个数为连续的质数。子节点可以随时创建。因此 HashTree 的结构是动态的，也不像某些 Hash 算法那样需要长时间的初始化过程。HashTree 也没有必要为不存在的关键字提前分配空间。需要注意的是 HashTree 是一个单向增加的结构，即随着所需要存储的数据量增加而增大。即使数据量减少到原来的数量，但是 HashTree 的总节点数不会减少。这样做的目的是为了避免结构的调整带来的额外消耗。</p>
<p>– 查找迅速<br>从算法过程我们可以看出，对于整数，HashTree 层级最多能增加到10。因此最多只需要十次取余和比较操作，就可以知道这个对象是否存在。这个在算法逻辑上决定了 HashTree 的优越性。一般的树状结构，往往随着层次和层次中节点数的增加而导致更多的比较操作。操作次数可以说无法准确确定上限。而 HashTree 的查找次数和元素个数没有关系。如果元素的连续关键字总个数在计算机的整数（32bit）所能表达的最大范围内，那么比较次数就最多不会超过10次，通常低于这个数值。</p>
<p>– 结构不变<br>HashTree 在删除的时候，并不做任何结构调整。这个也是它的一个非常好的优点。常规树结构在增加元素和删除元素的时候都要做一定的结构调整，否则他们将可能退化为链表结构，而导致查找效率的降低。HashTree 采取的是一种“见缝插针”的算法，从来不用担心退化的问题，也不必为优化结构而采取额外的操作，因此大大节约了操作时间。</p>
<ul>
<li>缺点</li>
</ul>
<p>非排序性<br>HashTree 不支持排序，没有顺序特性。如果在此基础上不做任何改进的话并试图通过遍历来实现排序，那么操作效率将远远低于其他类型的数据结构。</p>
<ul>
<li>应用</li>
</ul>
<p>HashTree 可以广泛应用于那些需要对大容量数据进行快速匹配操作的地方。例如：数据库索引系统、短信息中的收条匹配、大量号码路由匹配、信息过滤匹配。HashTree 不需要额外的平衡和防止退化的操作，效率十分理想。</p>
<h4 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h4><p>字典树（Trie）可以保存一些字符串-&gt;值的对应关系。基本上，它跟 Java 的 HashMap 功能相同，都是 key-value 映射，只不过 Trie 的 key 只能是字符串。Trie 的强大之处就在于它的时间复杂度。它的插入和查询时间复杂度都为 O(k) ，其中 k 为 key 的长度，与 Trie 中保存了多少个元素无关。Hash 表号称是 O(1) 的，但在计算 hash 的时候就肯定会是 O(k) ，而且还有碰撞之类的问题；Trie 的缺点是空间消耗很高。<br>Trie树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。<br>Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。<br>以英文单词构建的字典树为例，这棵Trie树中每个结点包括26个孩子结点，因为总共有26个英文字母(假设单词都是小写字母组成)。<br>下面我们有and,as,at,cn,com这些关键词，那么如何构建trie树呢？<br><img src="/2020/01/05/jmeter源码学习二/jmeter3.png" alt="avatar"><br><img src="/2020/01/05/jmeter源码学习二/jmeter4.png" alt="avatar"><br>从上面的图中，我们或多或少的可以发现一些好玩的特性。<br>第一：根节点不包含字符，除根节点外的每一个子节点都包含一个字符。<br>第二：从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。<br>第三：每个单词的公共前缀作为一个字符节点保存。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ul>
<li><p>项目位置<br><img src="/2020/01/05/jmeter源码学习二/jmeter5.png" alt="avatar"><br>HashTree 类用于创建测试对象的树结构。树中的每个元素也是树下一个节点的键。它提供了许多方法来添加对象和分支，以及许多检索的方法。HashTree 为了方便的原因实现了映射接口。特别是 traverse(HashTreeTraverser)方法，它提供了一种方便的方法，通过实现 HashTreeTraverser 接口来遍历任何 HashTree，以便在树上执行一些操作，或者从树中提取信息。</p>
</li>
<li><p>JMX文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;hashTree&gt;</span><br><span class="line">    &lt;TestPlan ...&gt;</span><br><span class="line">    &lt;/TestPlan&gt;</span><br><span class="line">    &lt;hashTree&gt;</span><br><span class="line">    &lt;ThreadGroup ...&gt;</span><br><span class="line">    &lt;/ThreadGroup&gt;</span><br><span class="line">    &lt;hashTree/&gt;</span><br><span class="line">    &lt;/hashTree&gt;</span><br><span class="line">&lt;/hashTree&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;jmeterTestPlan version=&quot;1.2&quot; properties=&quot;5.0&quot; jmeter=&quot;5.0&quot;&gt;</span><br><span class="line">  &lt;hashTree&gt;</span><br><span class="line">    &lt;TestPlan guiclass=&quot;TestPlanGui&quot; testclass=&quot;TestPlan&quot; testname=&quot;测试计划&quot; enabled=&quot;true&quot;&gt;</span><br><span class="line">      &lt;stringProp name=&quot;TestPlan.comments&quot;&gt;&lt;/stringProp&gt;</span><br><span class="line">      &lt;boolProp name=&quot;TestPlan.functional_mode&quot;&gt;false&lt;/boolProp&gt;</span><br><span class="line">      &lt;boolProp name=&quot;TestPlan.tearDown_on_shutdown&quot;&gt;true&lt;/boolProp&gt;</span><br><span class="line">      &lt;boolProp name=&quot;TestPlan.serialize_threadgroups&quot;&gt;false&lt;/boolProp&gt;</span><br><span class="line">      &lt;elementProp name=&quot;TestPlan.user_defined_variables&quot; elementType=&quot;Arguments&quot; guiclass=&quot;ArgumentsPanel&quot; testclass=&quot;Arguments&quot; testname=&quot;用户定义的变量&quot; enabled=&quot;true&quot;&gt;</span><br><span class="line">        &lt;collectionProp name=&quot;Arguments.arguments&quot;/&gt;</span><br><span class="line">      &lt;/elementProp&gt;</span><br><span class="line">      &lt;stringProp name=&quot;TestPlan.user_define_classpath&quot;&gt;&lt;/stringProp&gt;</span><br><span class="line">    &lt;/TestPlan&gt;</span><br><span class="line">    &lt;hashTree&gt;</span><br><span class="line">      &lt;ThreadGroup guiclass=&quot;ThreadGroupGui&quot; testclass=&quot;ThreadGroup&quot; testname=&quot;线程组&quot; enabled=&quot;true&quot;&gt;</span><br><span class="line">        &lt;stringProp name=&quot;ThreadGroup.on_sample_error&quot;&gt;continue&lt;/stringProp&gt;</span><br><span class="line">        &lt;elementProp name=&quot;ThreadGroup.main_controller&quot; elementType=&quot;LoopController&quot; guiclass=&quot;LoopControlPanel&quot; testclass=&quot;LoopController&quot; testname=&quot;循环控制器&quot; enabled=&quot;true&quot;&gt;</span><br><span class="line">          &lt;boolProp name=&quot;LoopController.continue_forever&quot;&gt;false&lt;/boolProp&gt;</span><br><span class="line">          &lt;stringProp name=&quot;LoopController.loops&quot;&gt;1&lt;/stringProp&gt;</span><br><span class="line">        &lt;/elementProp&gt;</span><br><span class="line">        &lt;stringProp name=&quot;ThreadGroup.num_threads&quot;&gt;100&lt;/stringProp&gt;</span><br><span class="line">        &lt;stringProp name=&quot;ThreadGroup.ramp_time&quot;&gt;5&lt;/stringProp&gt;</span><br><span class="line">        &lt;boolProp name=&quot;ThreadGroup.scheduler&quot;&gt;false&lt;/boolProp&gt;</span><br><span class="line">        &lt;stringProp name=&quot;ThreadGroup.duration&quot;&gt;&lt;/stringProp&gt;</span><br><span class="line">        &lt;stringProp name=&quot;ThreadGroup.delay&quot;&gt;&lt;/stringProp&gt;</span><br><span class="line">      &lt;/ThreadGroup&gt;</span><br><span class="line">      &lt;hashTree&gt;</span><br><span class="line">        &lt;HTTPSamplerProxy guiclass=&quot;HttpTestSampleGui&quot; testclass=&quot;HTTPSamplerProxy&quot; testname=&quot;HTTP请求&quot; enabled=&quot;true&quot;&gt;</span><br><span class="line">          &lt;elementProp name=&quot;HTTPsampler.Arguments&quot; elementType=&quot;Arguments&quot; guiclass=&quot;HTTPArgumentsPanel&quot; testclass=&quot;Arguments&quot; testname=&quot;用户定义的变量&quot; enabled=&quot;true&quot;&gt;</span><br><span class="line">            &lt;collectionProp name=&quot;Arguments.arguments&quot;/&gt;</span><br><span class="line">          &lt;/elementProp&gt;</span><br><span class="line">          &lt;stringProp name=&quot;HTTPSampler.domain&quot;&gt;www.baidu.com&lt;/stringProp&gt;</span><br><span class="line">          &lt;stringProp name=&quot;HTTPSampler.port&quot;&gt;&lt;/stringProp&gt;</span><br><span class="line">          &lt;stringProp name=&quot;HTTPSampler.protocol&quot;&gt;https&lt;/stringProp&gt;</span><br><span class="line">          &lt;stringProp name=&quot;HTTPSampler.contentEncoding&quot;&gt;&lt;/stringProp&gt;</span><br><span class="line">          &lt;stringProp name=&quot;HTTPSampler.path&quot;&gt;&lt;/stringProp&gt;</span><br><span class="line">          &lt;stringProp name=&quot;HTTPSampler.method&quot;&gt;GET&lt;/stringProp&gt;</span><br><span class="line">          &lt;boolProp name=&quot;HTTPSampler.follow_redirects&quot;&gt;true&lt;/boolProp&gt;</span><br><span class="line">          &lt;boolProp name=&quot;HTTPSampler.auto_redirects&quot;&gt;false&lt;/boolProp&gt;</span><br><span class="line">          &lt;boolProp name=&quot;HTTPSampler.use_keepalive&quot;&gt;true&lt;/boolProp&gt;</span><br><span class="line">          &lt;boolProp name=&quot;HTTPSampler.DO_MULTIPART_POST&quot;&gt;false&lt;/boolProp&gt;</span><br><span class="line">          &lt;stringProp name=&quot;HTTPSampler.embedded_url_re&quot;&gt;&lt;/stringProp&gt;</span><br><span class="line">          &lt;stringProp name=&quot;HTTPSampler.connect_timeout&quot;&gt;&lt;/stringProp&gt;</span><br><span class="line">          &lt;stringProp name=&quot;HTTPSampler.response_timeout&quot;&gt;&lt;/stringProp&gt;</span><br><span class="line">        &lt;/HTTPSamplerProxy&gt;</span><br><span class="line">        &lt;hashTree/&gt;</span><br><span class="line">        &lt;ResultCollector guiclass=&quot;ViewResultsFullVisualizer&quot; testclass=&quot;ResultCollector&quot; testname=&quot;察看结果树&quot; enabled=&quot;true&quot;&gt;</span><br><span class="line">          &lt;boolProp name=&quot;ResultCollector.error_logging&quot;&gt;false&lt;/boolProp&gt;</span><br><span class="line">          &lt;objProp&gt;</span><br><span class="line">            &lt;name&gt;saveConfig&lt;/name&gt;</span><br><span class="line">            &lt;value class=&quot;SampleSaveConfiguration&quot;&gt;</span><br><span class="line">              &lt;time&gt;true&lt;/time&gt;</span><br><span class="line">              &lt;latency&gt;true&lt;/latency&gt;</span><br><span class="line">              &lt;timestamp&gt;true&lt;/timestamp&gt;</span><br><span class="line">              &lt;success&gt;true&lt;/success&gt;</span><br><span class="line">              &lt;label&gt;true&lt;/label&gt;</span><br><span class="line">              &lt;code&gt;true&lt;/code&gt;</span><br><span class="line">              &lt;message&gt;true&lt;/message&gt;</span><br><span class="line">              &lt;threadName&gt;true&lt;/threadName&gt;</span><br><span class="line">              &lt;dataType&gt;true&lt;/dataType&gt;</span><br><span class="line">              &lt;encoding&gt;false&lt;/encoding&gt;</span><br><span class="line">              &lt;assertions&gt;true&lt;/assertions&gt;</span><br><span class="line">              &lt;subresults&gt;true&lt;/subresults&gt;</span><br><span class="line">              &lt;responseData&gt;false&lt;/responseData&gt;</span><br><span class="line">              &lt;samplerData&gt;false&lt;/samplerData&gt;</span><br><span class="line">              &lt;xml&gt;false&lt;/xml&gt;</span><br><span class="line">              &lt;fieldNames&gt;true&lt;/fieldNames&gt;</span><br><span class="line">              &lt;responseHeaders&gt;false&lt;/responseHeaders&gt;</span><br><span class="line">              &lt;requestHeaders&gt;false&lt;/requestHeaders&gt;</span><br><span class="line">              &lt;responseDataOnError&gt;false&lt;/responseDataOnError&gt;</span><br><span class="line">              &lt;saveAssertionResultsFailureMessage&gt;true&lt;/saveAssertionResultsFailureMessage&gt;</span><br><span class="line">              &lt;assertionsResultsToSave&gt;0&lt;/assertionsResultsToSave&gt;</span><br><span class="line">              &lt;bytes&gt;true&lt;/bytes&gt;</span><br><span class="line">              &lt;sentBytes&gt;true&lt;/sentBytes&gt;</span><br><span class="line">              &lt;url&gt;true&lt;/url&gt;</span><br><span class="line">              &lt;threadCounts&gt;true&lt;/threadCounts&gt;</span><br><span class="line">              &lt;idleTime&gt;true&lt;/idleTime&gt;</span><br><span class="line">              &lt;connectTime&gt;true&lt;/connectTime&gt;</span><br><span class="line">            &lt;/value&gt;</span><br><span class="line">          &lt;/objProp&gt;</span><br><span class="line">          &lt;stringProp name=&quot;filename&quot;&gt;&lt;/stringProp&gt;</span><br><span class="line">        &lt;/ResultCollector&gt;</span><br><span class="line">        &lt;hashTree/&gt;</span><br><span class="line">      &lt;/hashTree&gt;</span><br><span class="line">    &lt;/hashTree&gt;</span><br><span class="line">  &lt;/hashTree&gt;</span><br><span class="line">&lt;/jmeterTestPlan&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>HashTree 的结构一般是 TestPlan–&gt;ThreadGroup–&gt;Sampler–&gt;ResultCollector</p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashTree(Map&lt;Object, HashTree&gt; _map, Object key)：若 HashTree 不为空则使用 HashTree，若 key 不为空则设为 top-level（root）节点，也可能是空。这个构造函数是最为主要的构造函数，它还有几个变形体都是调用它</span><br><span class="line"> private HashTree(Map&lt;Object, HashTree&gt; _map, Object key) &#123;</span><br><span class="line">        if(_map != null) &#123;</span><br><span class="line">            data = _map;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            data = new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        if(key != null) &#123;</span><br><span class="line">            data.put(key, new HashTree());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">public HashTree getTree(Object[] treePath) &#123;</span><br><span class="line">	if (treePath != null) &#123;</span><br><span class="line">		return getTree(Arrays.asList(treePath));</span><br><span class="line">	&#125;</span><br><span class="line">	return this;</span><br><span class="line">&#125;</span><br><span class="line">traverseInto 完成树遍历和执行的递归方法对 HashTreeTraverser 的回调。使用深度优先遍历 hashTree</span><br><span class="line">public void traverse(HashTreeTraverser visitor) &#123;</span><br><span class="line">	for (Object item : list()) &#123;</span><br><span class="line">		visitor.addNode(item, getTree(item));</span><br><span class="line">		getTree(item).traverseInto(visitor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line">traverse(HashTreeTraverser visitor)：允许 HashTreeTraverser 接口的任何实现轻松遍历（深度优先）HashTree 的所有节点。</span><br><span class="line">private void traverseInto(HashTreeTraverser visitor) &#123;</span><br><span class="line">	if (list().isEmpty()) &#123;</span><br><span class="line">		visitor.processPath();</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		for (Object item : list()) &#123;</span><br><span class="line">			final HashTree treeItem = getTree(item);</span><br><span class="line">			visitor.addNode(item, treeItem);</span><br><span class="line">			treeItem.traverseInto(visitor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	visitor.subtractNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clear：清除所有内容的 HashTree<br>clone：创建此 HashTree 的克隆<br>createNewTree：从名字可看出，该函数创建一个 tree，也存在多个重载函数，供多种访问方式。<br>getArray：获取当前HashTree节点的所有keys，同样存在多个重载函数，提供多种访问方式<br>remove：删除指定分支<br>replaceKey：替换指定 key<br>search：在 HashTree 中搜索指定关键字，返回 map 对应的 HashTree 或者null<br>list：获取 HashTree 中的节点的集合，同样存在多个重载函数，提供多种访问方式<br>还有对 map 的一些操作，如：hashCode、equals、keySet、size、toString<br>综上所述，加载 jmx 脚本，本身这个操作非常复杂。jmx 脚本中通常会包含参数化文件，用户自定义的参数化，JMeter 自定义函数，各种 Sampler 的实现，断言，甚至用户自定义的插件等等。<br>同时还有各种监听接口的初始化。这些都是要找到实现类加载的，HashTree 源码中包含非常多的实现类。遍历任何 HashTree，以便在树上执行一些操作，或者从树中提取信息，去掉没用的节点元素，替换掉可以替换的控制器，这些都是通过递归实现的。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://blog.csdn.net/zuozewei/article/details/86748517" target="_blank" rel="noopener">https://blog.csdn.net/zuozewei/article/details/86748517</a></p>
]]></content>
      <tags>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-运行时数据区</title>
    <url>/2021/06/22/jvm%E5%B0%8F%E7%BB%93%E4%BA%8C/</url>
    <content><![CDATA[<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul>
<li>线程是一个程序里的运行单元，JVM允许一个程序有多个线程并行的执行；</li>
<li>在HotSpot JVM，每个线程都与操作系统的本地线程直接映射。</li>
<li>当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后。本地线程也会回收。</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用java线程中的run（）方法.</li>
<li>查看jvm线程的方法：使用jconsole</li>
</ul>
<p><strong>HotSpot JVM后台主要线程：</strong></p>
<ul>
<li>虚拟机线程：这种线程的操作时需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li>
<li>周期任务线程：这种线程是时间周期事件的提现（比如中断），他们一般用于周期性操作的调度执行。</li>
<li>GC线程：这种线程对于JVM里不同种类的垃圾收集行为提供了支持</li>
<li>编译线程：这种线程在运行时会降字节码编译成本地代码</li>
<li>信号调度线程：这种线程接收信号并发送给JVM,在它内部通过调用适当的方法进行处理。</li>
</ul>
<h4 id="程序计数器（pc寄存器）"><a href="#程序计数器（pc寄存器）" class="headerlink" title="程序计数器（pc寄存器）"></a>程序计数器（pc寄存器）</h4><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装到寄存器才能够运行。JVM中的PC寄存器是对计算机PC寄存器的一种抽象模拟。</p>
<p>作用：PC寄存器是用来存储指向下一条指令的地址，也即将将要执行的指令代码。由执行引擎读取下一条指令。</p>
<ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li>
<li>在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值（undefined）。</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令</li>
<li>它是唯一一个在java虚拟机规范中没有规定任何OOM情况的区域</li>
</ul>
<p><img src="/2021/06/22/jvm小结二/jvm1.png" alt="avatar"></p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul>
<li>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</li>
<li>本地方法栈，也是线程私有的。</li>
<li>允许被实现成固定或者是可动态拓展的内存大小。（在内存溢出方面是相同的）</li>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverFlowError异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会抛出一个OutOfMemoryError异常。</li>
<li>本地方法是使用C语言实现的。它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库</li>
<li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限</li>
</ul>
<ol>
<li>本地方法可以通过本地方法接口来 访问虚拟机内部的运行时数据区</li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ol>
<ul>
<li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li>
<li>在hotSpot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li>
</ul>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p><strong>虚拟机栈背景</strong></p>
<p>由于跨平台性的设计，java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。</p>
<p>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p><strong>内存中的堆与栈</strong></p>
<ul>
<li>栈是运行时的单位，而堆是存储的单位；即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</li>
<li>一般来讲，对象主要都是放在堆空间的，是运行时数据区比较大的一块</li>
<li>栈空间存放 基本数据类型的局部变量，以及引用数据类型的对象的引用</li>
<li>java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。</li>
<li>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应这个一次次的java方法调用。它是线程私有的</li>
<li>生命周期和线程是一致的</li>
<li>作用：主管java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li>
<li>局部变量：相对于成员变量（或属性）</li>
<li>基本数据变量： 相对于引用类型变量（类，数组，接口）</li>
</ul>
<p><strong>栈的特点</strong></p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于PC寄存器（程序计数器）</li>
<li>JVM直接对java栈的操作只有两个</li>
<li>每个方法执行，伴随着进栈（入栈，压栈）</li>
<li>执行结束后的出栈工作</li>
<li>对于栈来说不存在垃圾回收问题</li>
</ul>
<p><strong>栈中可能出现的异常</strong></p>
<p>java虚拟机规范允许Java栈的大小是动态的或者是固定不变的</p>
<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量，java虚拟机将会抛出一个 StackOverFlowError异常</li>
<li>如果java虚拟机栈可以动态拓展，并且在尝试拓展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个 OutOfMemoryError异常。</li>
</ul>
<p><strong>设置栈的内存大小</strong></p>
<p>我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 （IDEA设置方法：Run-EditConfigurations-VM options 填入指定栈的大小-Xss256k）</p>
<p><strong>栈的存储结构和运行原理</strong></p>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以栈帧(Stack Frame)的格式存在</li>
<li>在这个线程上正在执行的每个方法都对应各自的一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
<li>JVM直接对java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出/后进先出的和原则。</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧(Current Frame),与当前栈帧对应的方法就是当前方法（Current Frame）</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈帧。</li>
<li>不同线程中所包含的栈帧是不允许相互引用的，即不可能在另一个栈帧中引用另外一个线程的栈帧</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li>
</ul>
<p><img src="/2021/06/22/jvm小结二/jvm2.png" alt="avatar"></p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Heap，通过new关键字创建的对象，都存放在堆内存中。</p>
<ul>
<li>特点:</li>
</ul>
<ol>
<li>线程共享，堆中的对象都存在线程安全的问题</li>
<li>垃圾回收，垃圾回收机制重点区域。</li>
</ol>
<ul>
<li>jvm内存的划分：</li>
</ul>
<ol>
<li>JVM内存划分为堆内存和非堆内存，堆内存分为年轻代（Young Generation）、老年代（Old Generation），非堆内存就一个永久代（Permanent Generation）。</li>
<li>年轻代又分为Eden和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1。<br>非堆内存用途：永久代，也称为方法区，存储程序运行时长期存活的对象，比如类的元数据、方法、常量、属性等。</li>
<li>年轻代（New）：年轻代用来存放JVM刚分配的Java对象</li>
<li>年老代（Tenured)：年轻代中经过垃圾回收没有回收掉的对象将被Copy到年老代</li>
<li>永久代（Perm）：永久代存放Class、Method元信息，其大小跟项目的规模、类、方法的量有关，一般设置为128M就足够，设置原则是预留30%的空间，方法区。</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下iptables总结</title>
    <url>/2021/02/02/linux%E4%B8%8Biptables%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在linux操作系统中，Netfilter组件是集成在linux内核中扩展各种网络服务的结构化底层框架，在内核级提供防火墙功能。内核中选取五个位置放了五个hook(勾子) function(INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING)，而这五个hook function向用户开放，用户可以通过一个命令工具（iptables）向其写入规则。</p>
<p><img src="/2021/02/02/linux下iptables总结/iptables1.png" alt="avatar"></p>
<p>报文流向：</p>
<p>流入本机：PREROUTING –&gt; INPUT–&gt;用户空间进程</p>
<p>流出本机：用户空间进程–&gt;OUTPUT–&gt; POSTROUTING</p>
<p>转发：PREROUTING –&gt; FORWARD –&gt; POSTROUTING</p>
<p>内核中数据包的传输过程：</p>
<ol>
<li>当一个数据包进入网卡时，数据包首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去</li>
<li>如果数据包就是进入本机的，数据包就会到达INPUT链。经INPUT链检查后，数据包被发往本地进程。本地进程进行相应处理后发送响应数据包，数据包经过OUTPUT链，然后到达POSTROUTING链输出；如果数据包是要转发出去的，且内核允许转发，数据包就会向右移动，经过FORWARD链，然后到达POSTROUTING链输出。</li>
</ol>
<p>企业内部的主机A若配了一个公网地址6.6.6.6，访问互联网上其他网段的公有地址不受限制，但若访问互联网上同网段的地址即6.0.0.0/8网段的地址，由于A的路由表就有到达该网段的路由记录，就直接访问了，不会去查询路由器，但是实际上访问的不是互联网上的主机，而是本地局域网的主机，也就是说该网段的所有公有地址A都将无法访问。所以企业内部的主机一般是私有地址，但是互联网上没有私有地址的路由，也就是说私有地址无法连接互联网，可以利用防火墙的nat表（network address translation 地址转换规则表）将私有地址转换为公有地址再去访问互联网。</p>
<p>SNAT</p>
<p>企业内部的主机A想访问互联网上的主机C，首先将请求数据包（源：ipA，目标：ipC）发送到防火墙所在主机B，B收到后将数据包源地址改为本机公网网卡的ip（源：ipA，目标：ipB），然后经互联网发送给C；C收到后将回应包（源：ipC，目标：ipB）转发给C的路由器，经互联网将回应包转发给B，B收到回应包后修改其目的地址，即回应包改为（源：ipC，目标：ipA）然后将数据包转发给A。</p>
<p>在这个过程中，修改了请求报文的源地址，叫做SNAT（source NAT POSTROUTING），用于局域网访问互联网。</p>
<p>不能在防火墙B的prerouting链上设置转换源地址的防火墙策略，因为若在B的prerouting链上设置转换源地址的防火墙策略，此时还未检查路由表，还不知道要到达数据包中目标主机需经过本机的哪个网卡接口，即还不知道需将源地址替换为哪个公网网卡的ip，需在postrouting设置转换源地址的防火墙策略。</p>
<p>DNAT</p>
<p>互联网主机C想访问企业内部的web服务器A，但A的地址是私有地址，无法直接访问。此时，C可以访问防火墙的公网地址，C的请求数据包（源：ipC，目标：ipB）到达防火墙B后，在B的prerouting上将请求数据包的目标地址进行修改，并将数据包（源：ipC，目标：ipA）发送给A。A收到后进行回复发送响应包（源：ipA，目的ipC）到防火墙，防火墙收到后对数据包源地址进行修改，并将响应包（源：ipB，目标：ipC）给C。利用这种机制可以将企业内部的服务发布到互联网。</p>
<p>在这个过程中，修改了请求报文的目标地址，叫做DNAT（destination NAT POSTROUTING），用于互联网访问局域网。</p>
<p>必须在防火墙的prerouting上设置修改目标地址的防火墙策略，因为若不在此处修改，请求数据包通过prerouting和路由表后，由于目标主机是本机，就会将数据包发往input，进而被发往本地进程。</p>
<p>iptables -t nat -A PREROUTING -d 本机IP -p tcp –dport 本机端口 -j DNAT –to-destination 目标机IP:目标机端口<br>iptables -t nat -A PREROUTING -d 192.168.172.130 -p tcp –dport 8000 -j DNAT –to-destination 192.168.172.131:80<br>iptables -t nat -A POSTROUTING -d 192.168.172.131 -p tcp –dport 80 -j SNAT –to 192.168.172.130</p>
<p>iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; –sport 源端口 &lt;-d 目标IP/目标子网&gt; –dport 目标端口 -j 动作</p>
<p>iptables -t nat -A PREROUTING -d 10.175.131.164 -p tcp –dport 8000 -j DNAT –to-destination 192.168.122.232:80<br>iptables -t nat -A POSTROUTING -d 192.168.122.232 -p tcp –dport 80 -j SNAT –to 10.175.131.164</p>
<h3 id="iptables命令"><a href="#iptables命令" class="headerlink" title="iptables命令"></a>iptables命令</h3><p>iptables命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-t&lt;表&gt;：指定要操纵的表；</span><br><span class="line">-A：向规则链中添加条目；</span><br><span class="line">-D：从规则链中删除条目；</span><br><span class="line">-i：向规则链中插入条目；</span><br><span class="line">-R：替换规则链中的条目；</span><br><span class="line">-L：显示规则链中已有的条目；</span><br><span class="line">-F：清楚规则链中已有的条目；</span><br><span class="line">-Z：清空规则链中的数据包计算器和字节计数器；</span><br><span class="line">-N：创建新的用户自定义规则链；</span><br><span class="line">-P：定义规则链中的默认目标；</span><br><span class="line">-h：显示帮助信息；</span><br><span class="line">-p：指定要匹配的数据包协议类型；</span><br><span class="line">-s：指定要匹配的数据包源ip地址；</span><br><span class="line">-j&lt;目标&gt;：指定要跳转的目标；</span><br><span class="line">-i&lt;网络接口&gt;：指定数据包进入本机的网络接口；</span><br><span class="line">-o&lt;网络接口&gt;：指定数据包要离开本机所使用的网络接口。</span><br></pre></td></tr></table></figure></p>
<p>iptables命令选项输入顺序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作</span><br></pre></td></tr></table></figure></p>
<p>表名包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">raw：高级功能，如：网址过滤。</span><br><span class="line">mangle：数据包修改（QOS），用于实现服务质量。</span><br><span class="line">nat：地址转换，用于网关路由器。</span><br><span class="line">filter：包过滤，用于防火墙规则。</span><br></pre></td></tr></table></figure>
<p>规则链名包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INPUT链：处理输入数据包。</span><br><span class="line">OUTPUT链：处理输出数据包。</span><br><span class="line">PORWARD链：处理转发数据包。</span><br><span class="line">PREROUTING链：用于目标地址转换（DNAT）。</span><br><span class="line">POSTOUTING链：用于源地址转换（SNAT）。</span><br></pre></td></tr></table></figure>
<p>动作包括：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accept：接收数据包。</span><br><span class="line">DROP：丢弃数据包。</span><br><span class="line">REDIRECT：重定向、映射、透明代理。</span><br><span class="line">SNAT：源地址转换。</span><br><span class="line">DNAT：目标地址转换。</span><br><span class="line">MASQUERADE：IP伪装（NAT），用于ADSL。</span><br><span class="line">LOG：日志记录。</span><br></pre></td></tr></table></figure></p>
<p>实例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d 10.175.131.164 -p tcp --dport 8000 -j DNAT --to-destination 192.168.122.232:80</span><br><span class="line">iptables -t nat -A POSTROUTING -d 192.168.122.232 -p tcp --dport 80 -j SNAT --to 10.175.131.164</span><br><span class="line"></span><br><span class="line">显示规则</span><br><span class="line">iptables -L INPUT --line-numbers</span><br><span class="line"></span><br><span class="line">删除一条规则</span><br><span class="line">iptables -D INPUT 7</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### rinetd 端口转发</span><br><span class="line"></span><br><span class="line">rinetd是一个轻量级TCP转发工具，简单配置就可以实现端口映射/转发/重定向。</span><br><span class="line"></span><br><span class="line">源码下载</span><br></pre></td></tr></table></figure></p>
<p>wget <a href="https://li.nux.ro/download/nux/misc/el7/x86_64/rinetd-0.62-9.el7.nux.x86_64.rpm" target="_blank" rel="noopener">https://li.nux.ro/download/nux/misc/el7/x86_64/rinetd-0.62-9.el7.nux.x86_64.rpm</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">安装rinetd</span><br></pre></td></tr></table></figure></p>
<p>rpm -ivh rinetd-0.62-9.el7.nux.x86_64.rpm<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">编辑配置文件</span><br></pre></td></tr></table></figure></p>
<p>vi rinetd.conf<br>    0.0.0.0 1234 127.0.0.1 22<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">启动转发</span><br></pre></td></tr></table></figure></p>
<p>rinetd -c /etc/rinetd.conf<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### ncat 端口转发</span><br><span class="line">netcat（简称nc）被誉为网络安全界的”瑞士军刀“，一个简单而有用的工具，这里介绍一种使用netcat实现端口转发的方法。</span><br><span class="line"></span><br><span class="line">安装ncat</span><br></pre></td></tr></table></figure></p>
<p>yum install nmap-ncat -y<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">监听本机 9876 端口，将数据转发到 192.168.172.131的 80 端口</span><br></pre></td></tr></table></figure></p>
<p>ncat –sh-exec “ncat 192.168.172.131 80” -l 9876  –keep-open<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### socat 端口转发</span><br><span class="line"></span><br><span class="line">socat安装</span><br></pre></td></tr></table></figure></p>
<p>yum install -y socat<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在本地监听12345端口，并将请求转发至192.168.172.131的22端口。</span><br></pre></td></tr></table></figure></p>
<p>socat TCP4-LISTEN:12345,reuseaddr,fork TCP4:192.168.172.131:22<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### portmap 端口转发</span><br><span class="line"></span><br><span class="line">下载地址</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.vuln.cn/wp-content/uploads/2016/06/lcx_vuln.cn_.zip" target="_blank" rel="noopener">http://www.vuln.cn/wp-content/uploads/2016/06/lcx_vuln.cn_.zip</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">监听本地1234端口，转发给192.168.172.131的22端口</span><br></pre></td></tr></table></figure></p>
<p>./portmap -m 1 -p1 1234 -h2 192.168.172.131 -p2 22<br>08、portfwd端口转发<br>portfwd是meterpreter中内置的功能，也提供了单机版，用于TCP/UDP端口转发服务<br>Github 项目地址：<br><a href="https://github.com/rssnsj/portfwd" target="_blank" rel="noopener">https://github.com/rssnsj/portfwd</a><br>（1）下载编译<br>git clone <a href="https://github.com/rssnsj/portfwd.git" target="_blank" rel="noopener">https://github.com/rssnsj/portfwd.git</a><br>cd portfwd/src<br>make<br>（2）将本地的12345端口转发到192.168.172.131：22</p>
<p>./tcpfwd 0.0.0.0:12345 192.168.172.131:22<br>09、NATBypass端口转发<br>一款lcx（htran）在golang下的实现<br>Gihub项目地址：<br><a href="https://github.com/cw1997/NATBypass" target="_blank" rel="noopener">https://github.com/cw1997/NATBypass</a><br>（1）内网主机主动连接外网主机打通隧道<br>在目标机器上执行：nb -slave 127.0.0.1:3389 公网IP:51<br>在公网的机器执行：nb -listen 51 3340<br>在公网主机上连接 127.0.0.1:3340，即可连接上内网机器的3389端口。<br><code>`</code></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><a href="https://blog.csdn.net/beanewself/article/details/78317626" target="_blank" rel="noopener">https://blog.csdn.net/beanewself/article/details/78317626</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1688152" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1688152</a></li>
<li><a href="https://www.jianshu.com/p/d3f30fb9ebf6" target="_blank" rel="noopener">https://www.jianshu.com/p/d3f30fb9ebf6</a></li>
<li><a href="https://blog.csdn.net/lizhigang_bj/article/details/80495395" target="_blank" rel="noopener">https://blog.csdn.net/lizhigang_bj/article/details/80495395</a></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux文件系统</title>
    <url>/2021/11/02/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h4 id="inode-结构"><a href="#inode-结构" class="headerlink" title="inode 结构"></a>inode 结构</h4><p>了解文件操作命令例如rm、mv、cp的底层原理时，需要先了解 linux 中文件系统的基本原理。</p>
<p>在linux 系统中，磁盘通常被格式化为 ext3 或 ext4 格式，这两种文件系统对文件的存储和访问是通过一种被称为 inode 即 i 节点的机制来实现的。</p>
<p>除文件名和文件内容之外，一个文件还有哪些信息呢？其实这些额外的信息和文件的存储及读写方式有关。当我们读写文件时，通常是以流的形式，即认为文件的内容是连续的。但是在磁盘上，一个文件的内容通常是由多个固定大小的数据块即block构成的，并且这些数据块通常是不连续的。这时就需要一个额外的数据结构来保存各数据块的位置、数据块之间的顺序关系、文件大小、文件访问权限、文件的拥有者及修改时间等信息，即文件的元信息，而维护这些元信息的数据结构就被称为 i 结点。可以说，一个i 节点中包含了进程访问文件时所需要的所有信息。由于一个文件的数据块是不连续的，属于同一文件的数据块可能遍布整个磁盘，因而可以认为 i 节点中含有一个帮助定位文件数据块的 “目录结构”。</p>
<p><img src="/2021/11/02/linux文件系统/inode.png" alt="avatar"></p>
<p>可见，i节点中主要有两大部分，一部分是i 节点号与文件名的对应表，另一部分就是i 节点对应文件的元信息，其中的指针指向了磁盘上的构成文件的多个数据块。在图中可以看出，每个i 节点号对应一个文件。</p>
<p>由于i节点存储了文件的元信息，因而 i节点本身也是要占用磁盘空间的。 i 节点的内容独立于文件内容，这里有必要区分“更改文件本身”的内容和更改“文件对应的i节点” 的内容。当对文件执行写入、编辑后保存等更改文件内容的操作时，我们更改的是文件内容本身。而更改i节点信息通常有如下情形：</p>
<p>更改文件内容后，导致文件元信息发生了变化，例如文件的大小、文件的访问时间等，这时文件对应i 节点的信息也会发生变化。<br>文件的拥有者、访问权限发生了变化，例如对文件执行了 chown、chgrp、chmod 等命令。<br>因而，inode 内容发生了变化，对应的文件内容不一定发生了变化。</p>
<p>在 linux 系统中用 i 节点号来标识一个i 节点。 i 节点号是一个整数，在单个磁盘分区中是唯一的。linux 中挂载多个磁盘分区时，不同的分区中可能有相同的 i 节点号，本文只考虑单一的磁盘分区，因而认为 i 节点号是唯一的。</p>
<p><strong>硬链接</strong></p>
<p>一般情况下，一个文件名对应一个i 节点。但是linux 提供了一种共享 i 节点的方法——硬链接。例如对 data.txt 创建一个硬链接，之后查看 data.txt 的 i 节点的信息：</p>
<p><img src="/2021/11/02/linux文件系统/inode2.png" alt="avatar"></p>
<p>可见，这时有两个文件名链接到同一个i 节点上，这里的i 节点的链接数是2。可以认为，硬链接文件和原文件就是同一个文件，只不过有两个名字，类似于 C++ 中的引用。当一个文件有多个链接时，删除其中一个文件名并不会删除文件本身，而只是减少文件的链接数。当链接数为 0 时，文件内容才会真正被删除。</p>
<p><strong>符号链接</strong></p>
<p>除了硬链接，linux 系统还提供了一种符号链接。符号链接并不增加目标文件 i 节点的链接数。符号链接本身也是一个文件，其中存储了目标文件的完整路径，类似于windows系统中的快捷方式。符号链接与硬链接的另一个区别是符号链接可以对目录建立链接，而硬链接不能对目录建立链接。因为如果允许对目录建立硬链接，有可能形成链接环。符号链接的使用及属性如下：</p>
<p><img src="/2021/11/02/linux文件系统/inode3.png" alt="avatar"></p>
<p>可见，符号链接并不增加 i 节点的链接数。</p>
<p><strong>unlink 命令</strong></p>
<p>unlink 用于删除文件名。删除文件名是指在原目录下不再含有此文件名。要注意的是，这里的表述是删除文件名，并不一定删除磁盘上文件的内容。只有在文件的链接数为1，即当前文件名是文件的最后一个链接并且有没有进程打开此文件的时候，unlink() 才会真正删除文件内容。用 unlink 真正的删除一个文件内容，必须同时满足以上两个条件。</p>
<p>如果文件链接数为1，但是仍然有进程打开这一文件，那么 unlink 后，虽然在原目录中已经没有了被删除文件的名字，但是实际上系统还是保留了这一文件，直到打开这一文件的所有进程全部关闭此文件后，系统才会真正删除磁盘上的文件内容。由此可见，用unlink直接删除打开的文件是安全的。删除已经打开的文件，对使用此文件的进程，不会有任何影响，也不会导致进程崩溃（注意这里讨论的是删除已被打开的文件，通常是数据文件，并未讨论删除正在运行的可执行文件）。</p>
<p>对于符号链接，unlink 删除的是符号链接本身，而不是其指向的文件。</p>
<p><strong>rm 命令</strong></p>
<p>rm 命令也是删除文件。为了查看rm 与 unlink 的区别，用 strace 跟踪执行 rm 命令时使用的系统调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strace rm data.txt 2&gt;&amp;1 | grep &apos;data.txt&apos; </span><br><span class="line">execve(&quot;/bin/rm&quot;, [&quot;rm&quot;, &quot;data.txt&quot;], [/* 13 vars */]) = 0</span><br><span class="line">lstat(&quot;data.txt&quot;, &#123;st_mode=S_IFREG|0644, st_size=10, ...&#125;) = 0</span><br><span class="line">stat(&quot;data.txt&quot;, &#123;st_mode=S_IFREG|0644, st_size=10, ...&#125;) = 0</span><br><span class="line">access(&quot;data.txt&quot;, W_OK)                = 0</span><br><span class="line">unlink(&quot;data.txt&quot;)                      = 0</span><br></pre></td></tr></table></figure>
<p>跟踪 unlink 命令的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strace unlink data.txt 2&gt;&amp;1 | grep &apos;data.txt&apos;</span><br><span class="line">execve(&quot;/bin/unlink&quot;, [&quot;unlink&quot;, &quot;data.txt&quot;], [/* 13 vars */]) = 0</span><br><span class="line">unlink(&quot;data.txt&quot;)</span><br></pre></td></tr></table></figure>
<p>可以看出，在linux 中，rm 命令比 unlink 命令多了一些权限的检查，之后也是调用了 unlink() 系统调用。在文件允许删除的情况下，rm 命令和 unlink 命令其实是没有区别的。</p>
<p><strong>rename 命令</strong></p>
<p>rename 命令通常用于重命名文件，由于本文研究的是文件的移动和删除，因而只需关注 rename 最简单的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strace rename data.txt  dest_file data.txt 2&gt;&amp;1 | egrep  &apos;data.txt|dest_file&apos;</span><br><span class="line">execve(&quot;/usr/bin/rename&quot;, [&quot;rename&quot;, &quot;data.txt&quot;, &quot;dest_file&quot;, &quot;data.txt&quot;], [/* 13 vars */]) = 0</span><br><span class="line">rename(&quot;data.txt&quot;, &quot;dest_file&quot;)         = 0</span><br></pre></td></tr></table></figure>
<p>可以看出，rename 就是对 rename() 系统调用的封装。</p>
<p>查看 man page 可以看出，当目标文件已经存在时，在权限允许的情况下，rename() 会直接覆盖原来的文件。这里“覆盖原有文件”可能有两种情况：</p>
<p>将原文件清空后写入<br>删除了旧文件后新建一个同名文件</p>
<p>在目标文件 dest_file 已经存在的情况下，执行 rename 后，dest_file 的 i 节点号发生了变化，因而rename() 系统调用的作用类似于上述第二种情形：即删除文件后再新建一个同名文件。</p>
<p><strong>mv 命令</strong></p>
<p>mv 命令通常用于重命名文件。当目标文件不存在时，跟踪其执行过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strace mv data.txt  dest_file 2&gt;&amp;1 | egrep  &apos;data.txt|dest_file&apos;</span><br><span class="line">execve(&quot;/bin/mv&quot;, [&quot;mv&quot;, &quot;data.txt&quot;, &quot;dest_file&quot;], [/* 13 vars */]) = 0</span><br><span class="line">stat(&quot;dest_file&quot;, 0x7ffe1b4aab50)       = -1 ENOENT (No such file or directory)</span><br><span class="line">lstat(&quot;data.txt&quot;, &#123;st_mode=S_IFREG|0644, st_size=726, ...&#125;) = 0</span><br><span class="line">lstat(&quot;dest_file&quot;, 0x7ffe1b4aa900)      = -1 ENOENT (No such file or directory)</span><br><span class="line">rename(&quot;data.txt&quot;, &quot;dest_file&quot;)         = 0</span><br></pre></td></tr></table></figure>
<p>当目标文件存在时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strace mv src_data data.txt 2&gt;&amp;1 | egrep &apos;src_data|data.txt&apos;</span><br><span class="line">execve(&quot;/bin/mv&quot;, [&quot;mv&quot;, &quot;src_data&quot;, &quot;data.txt&quot;], [/* 13 vars */]) = 0</span><br><span class="line">stat(&quot;data.txt&quot;, &#123;st_mode=S_IFREG|0644, st_size=726, ...&#125;) = 0</span><br><span class="line">lstat(&quot;src_data&quot;, &#123;st_mode=S_IFREG|0644, st_size=726, ...&#125;) = 0</span><br><span class="line">lstat(&quot;data.txt&quot;, &#123;st_mode=S_IFREG|0644, st_size=726, ...&#125;) = 0</span><br><span class="line">stat(&quot;data.txt&quot;, &#123;st_mode=S_IFREG|0644, st_size=726, ...&#125;) = 0</span><br><span class="line">access(&quot;data.txt&quot;, W_OK)                = 0</span><br><span class="line">rename(&quot;src_data&quot;, &quot;data.txt&quot;)          = 0</span><br></pre></td></tr></table></figure>
<p>可以看出，mv 的主要功能就是检查初始文件和目标文件是否存在及是否有访问权限，之后执行 rename 系统调用，因而，当目标文件存在时，mv 的行为由 rename() 系统调用决定，即类似于删除文件后再重建一个同名文件。</p>
<p><strong>cp 命令</strong></p>
<p>对于cp 命令，当目标文件不存在时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strace cp data.txt dest_data 2&gt;&amp;1 | egrep &apos;data.txt|dest_data&apos;</span><br><span class="line">execve(&quot;/bin/cp&quot;, [&quot;cp&quot;, &quot;data.txt&quot;, &quot;dest_data&quot;], [/* 13 vars */]) = 0</span><br><span class="line">stat(&quot;dest_data&quot;, 0x7fff135827f0)       = -1 ENOENT (No such file or directory)</span><br><span class="line">stat(&quot;data.txt&quot;, &#123;st_mode=S_IFREG|0644, st_size=726, ...&#125;) = 0</span><br><span class="line">stat(&quot;dest_data&quot;, 0x7fff13582640)       = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;data.txt&quot;, O_RDONLY)              = 3</span><br><span class="line">open(&quot;dest_data&quot;, O_WRONLY|O_CREAT, 0100644) = 4</span><br></pre></td></tr></table></figure>
<p>如果目标文件存在，在执行cp 命令之后，文件的 inode 号并没有改变，并且可以看出，cp 使用了 open 及O_TRUNC 参数打开了目标文件。因而当目标文件已经存在时，cp 命令实际是清空了目标文件内容，之后把新的内容写入目标文件。</p>
<p>特别需要关注的是 cp 命令。当目标文件存在时，cp 命令并不是先删除已经存在的目标文件，而是将原目标文件内容清空后再写入。了</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux网络基础总结</title>
    <url>/2019/05/07/linux%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>最近在做linux网络相关的业务，使用过程中发现有些知识点依然比较模糊。总结如下，</p>
<h4 id="Linux处理数据包过程"><a href="#Linux处理数据包过程" class="headerlink" title="Linux处理数据包过程"></a>Linux处理数据包过程</h4><p>&emsp;&emsp;当外界向主机发送数据时，在它从网卡流入后需要对它做路由决策，根据其目标决定是流入本机数据还是转发给其他主机。<br>&emsp;&emsp;如果是流入本机的数据，则数据会从内核空间进入用户空间(被应用程序接收、处理)。当用户空间响应(应用程序生成新的数据包)时，响应数据包是本机产生的新数据，在响应包流出之前，需要做路由决策，根据目标决定从哪个网卡流出。<br>&emsp;&emsp;如果不是流入本机的，而是要转发给其他主机的，则必然涉及到另一个流出网卡，此时数据包必须从流入网卡完整地转发给流出网卡，这要求Linux主机能够完成这样的转发。但Linux主机默认未开启ip_forward功能，这使得数据包无法转发而被丢弃。Linux主机和路由器不同，路由器本身就是为了转发数据包，所以路由器内部默认就能在不同网卡间转发数据包，而Linux主机默认则不能转发。如下图：<br><img src="/2019/05/07/linux网络基础总结/network.png" alt="avatar"><br>另外，IP地址是属于内核的(不仅如此，整个tcp/ip协议栈都属于内核，包括端口号)，只要能和其中一个地址通信，就能和另一个地址通信(这么说是不准确的，即使地址属于内核，但还存在一个检查数据包是否丢弃的问题，不过这不是本文内容)，而不管是否开启了数据包转发功能。例如某Linux主机有两网卡eth0:172.16.10.5和eth1:192.168.100.20，某192.168.100.22主机网关指向192.168.100.20，若它ping 172.16.10.5，结果将是通的，因为地址属于内核，从eth1进来的数据包被内核分析时，发现目标地址为本机地址，直接就回应192.168.100.22，回应数据包继续从eth1出去。<br>如果Linux主机有多块网卡，如果不开启数据包转发功能，则这些网卡之间是无法互通的。例如eth0是172.16.10.0/24网段，而eth1是192.168.100.0/24网段，到达该Linux主机的数据包无法从eth0交给eth1或者从eth1交给eth0，除非Linux主机开启了数据包转发功能。<br>在Linux上开启转发功能有多种方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">shell&gt; sysctl -w net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure></p>
<p>以上两种方法是临时生效的，若要永久生效，则应该写入配置文件。在CentOS 6中，将/etc/sysctl.conf文件中的”net.ipv4.ip_forward”值改为1即可，但在CentOS 7中，systemd管理了太多的功能，sysctl的配置文件也分化为多个，包括/etc/sysctl.conf、/etc/sysctl.d/<em>.conf和/usr/lib/sysctl.d/</em>.conf，并且这些文件中默认都没有net.ipv4.ip_forward项。当然，直接将此项写入到这些配置文件中也都是可以的，建议写在/etc/sysctl.d/*.conf中，这是systemd提供自定义内核修改项的目录。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; echo &quot;net.ipv4.ip_forward=1&quot; &gt; /etc/sysctl.d/ip_forward.conf</span><br></pre></td></tr></table></figure></p>
<p>可以使用以下几种方式查看是否开启了转发功能。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@test ~]# sysctl net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line">[root@test ~]# cat /proc/sys/net/ipv4/ip_forward</span><br><span class="line">0</span><br><span class="line">[root@test ~]# sysctl -a | grep ip_forward</span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line">[root@test ~]#</span><br></pre></td></tr></table></figure></p>
<h4 id="网卡相关配置"><a href="#网卡相关配置" class="headerlink" title="网卡相关配置"></a>网卡相关配置</h4><h5 id="网卡配置文件"><a href="#网卡配置文件" class="headerlink" title="网卡配置文件"></a>网卡配置文件</h5><p>对于网卡信息的配置通常包括：配置IP地址、子网掩码和网关。网卡信息保存在网卡配置文件中。网卡配置文件位于/etc/sysconfig/network-scripts目录下。一块网卡对应一个网卡配置文件，配置文件命名规则：<br>ifcfg-网卡类型以及网卡的序列号<br>由于以太网卡类型是eth，网卡的序列号从0开始，所以第一块网卡的配置文件名称为ifcfg-eth0，第二块网卡为ifcfg-eth1，以此类推。<br>网卡配置文件中常用配置文件名的还以如下：<br>DEVICE=eth0，定义该网卡的识别名称。<br>BOOTPROTO=dhcp，启动该网卡的识别名称。<br>static/none：代表固定的IP地址；bootp/dhcp：通过BOOTP或DHCP协议取得IP地址。<br>HWADDR=00:02:B3:0B:64:22，该网卡的MAC地址。<br>ONBOOT=yes，启动network服务时，是否启用该网卡。当RedHat系统启动network服务时，network服务一次读取保存于/etc/sysconfig/network-scripts/目录下所有网卡的配置文件。如果网卡配置文件的ONBOOT设置为yes，则network服务就会调用ifup命令启动该网卡；如果网卡的配置文件的ONBOOT参数为no，network会跳过启动这个网卡的工作。<br>TYPE=Ethernet，网卡的类型。<br>USERCTL=no，是否允许普通用户启动或者停止该网卡。<br>IPV6INIT=no，是否在该网卡上启动IPV6的功能。<br>PEERDNS=yes，是否允许网卡在启动时向DHCP服务器查询DNS信息，并自动覆盖/etc/resolv.conf配置文件。<br>以下配置项用于指定该网卡的静态IP地址，此时BOOTPROTO必须为static或者none。<br>IPADDR=192.168.1.55，静态方式指定网卡的IP地址。<br>NETMASK=255.255.255.0，定义该网卡的子网掩码。<br>MTU=1500，设置网卡的MAC帧最大传输单位大小。<br>GATEWAY=192.168.1.1，设置网络的默认网关。<br>DNS1=192.168.128.5，指定主要的DNS服务器地址。<br>DNS2=192.168.128.6，指定备用的DNS服务器地址。</p>
<h5 id="配置网卡信息"><a href="#配置网卡信息" class="headerlink" title="配置网卡信息"></a>配置网卡信息</h5><p>配置网卡信息可以直接修改网卡配置文件中的相关内容，但是这种方法对用户的要求比较高。在RedHat Enterprise Linux5中常用于设置IP地址的三个命令，分别是：system-config-network、setup和ifconfig。其中ifconfig设置IP地址的方法将在常用命令部分中介绍。<br>（1）system-config-network命令<br>在命令提示行下输入system-config-network命令将会启动可视化网络配置界面（对于新手这个方式比较简单）<br>（2）setup设置网卡信息<br>在命令行下输入setup命令后将会进入系统设置界面，然后选择网卡设置进入网卡设置界面（很多系统都可以使用setup命令设置，运用比较广）<br>（3）ifconfig网卡常用命令<br>ifconfig命令的功能比较强大，可以用来查看和设置网卡信息。<br>a.查看网卡信息<br>命令语法：ifconfig [参数]<br>参数说明：<br>无参数：显示当前活动的网卡</p>
<ul>
<li>a：显示系统中所有网卡的配置信息<br>网卡设备名称：显示指定网卡的配置信息<br>eg：查看eth0网卡信息：#ifconfig eth0<br>b.设置IP地址<br>命令语法：ifconfig 网卡设备名 IP地址 netmask 子网掩码<br>（注：ifconfig命令设置的IP地址即时生效，但是重启机器后，IP地址又回复到原IP地址，所以ifconfig命令只能用于设置临时的IP地址）<br>eg：ifconfig eth0 192.168.168.156 netmask 255.255.255.0<br>c.修改MAC地址<br>命令语法：ifconfig 网卡设备名 hw ether MAC地址<br>（注：修改网卡的MAC地址前要禁用网卡，修改后要启用网卡）<br>eg：ifconfig eth0 hw ether 00:0C:29:03:F3:76<br>几个常用的命令：<br>1.ifdown禁用网卡<br>语法：ifdown 网卡设备名<br>2.ifup启用网卡<br>语法：ifup 网卡设备名<br>3.绑定IP和MAC地址<br>实现方法：创建/etc/ethers文件，文件内容“ip地址 mac地址”，然后执行“arp -f”命令，是配置生效。<br>eg：将IP地址193.168.168.154与MAC地址00:0C:29:03:F3:75绑定。<br>echo “193.168.168.154 00:0C:29:03:F3:75”&gt;&gt;/etc/ethers<br>arp -f<h5 id="查询及设置网卡参数Ethtool"><a href="#查询及设置网卡参数Ethtool" class="headerlink" title="查询及设置网卡参数Ethtool"></a>查询及设置网卡参数Ethtool</h5>概要：<br>ethtool ethX      //查询ethX网口基本设置<br>ethtool –h        //显示ethtool的命令帮助(help)<br>ethtool –i ethX    //查询ethX网口的相关信息<br>ethtool –d ethX    //查询ethX网口注册性信息<br>ethtool –r ethX    //重置ethX网口到自适应模式<br>ethtool –S ethX    //查询ethX网口收发包统计<br>ethtool –s ethX [speed 10|100|1000]\         //设置网口速率10/100/1000M<br>[duplex half|full]\           //设置网口半/全双工<br>[autoneg on|off]\            //设置网口是否自协商<br>[port tp|aui|bnc|mii]\         //设置网口类型<br>[phyad N]\<br>[xcvr internal|exteral]\<br>[wol p|u|m|b|a|g|s|d…]\<br>[sopass xx:yy:zz:aa:bb:cc]\<br>[msglvl N]<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）[root@linux /]# ethtool eth1</span><br><span class="line"></span><br><span class="line">Settings for eth0:</span><br><span class="line">	Supported ports: [ TP ]</span><br><span class="line">	Supported link modes:   10baseT/Half 10baseT/Full </span><br><span class="line">	                        100baseT/Half 100baseT/Full </span><br><span class="line">	                        1000baseT/Full </span><br><span class="line">	Supports auto-negotiation: Yes</span><br><span class="line">	Advertised link modes:  10baseT/Half 10baseT/Full </span><br><span class="line">	                        100baseT/Half 100baseT/Full </span><br><span class="line">	                        1000baseT/Full </span><br><span class="line">	Advertised auto-negotiation: Yes</span><br><span class="line">	Speed: 1000Mb/s</span><br><span class="line">	Duplex: Full</span><br><span class="line">	Port: Twisted Pair</span><br><span class="line">	PHYAD: 1</span><br><span class="line">	Transceiver: internal</span><br><span class="line">	Auto-negotiation: on</span><br><span class="line">	Supports Wake-on: g</span><br><span class="line">	Wake-on: d</span><br><span class="line">	Link detected: yes</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>怎样使ethtool设置永久保存在网络设备中？<br>解决方法一:<br>    ethtool设置可通过/etc/sysconfig/network-scripts/ifcfg-ethX文件保存,从而在设备下次启动时激活选项。<br>例如：ethtool -s eth0 speed 100 duplex full autoneg off<br>此指令将eth0设备设置为全双工自适应，速度为100Mbs。若要eth0启动时设置这些参数, 修改文件/etc/sysconfig/network-scripts/ifcfg-eth0 ，添加如下一行:<br>ETHTOOL_OPTS=”speed 100 duplex full autoneg off”<br>解决方法二:<br>将ethtool设置写入/etc/rc.d/rc.local之中。</p>
<h4 id="DNS配置文件-etc-resolv-conf"><a href="#DNS配置文件-etc-resolv-conf" class="headerlink" title="DNS配置文件/etc/resolv.conf"></a>DNS配置文件/etc/resolv.conf</h4><p>/etc/resolv.conf它是DNS客户机配置文件，用于设置DNS服务器的IP地址及DNS域名，还包含了主机的域名搜索顺序。该文件是由域名解析器（resolver，一个根据主机名解析IP地址的库）使用的配置文件。它的格式很简单，每行以一个关键字开头，后接一个或多个由空格隔开的参数。resolv.conf的关键字主要有四个，分别是：<br>nameserver    //定义DNS服务器的IP地址<br>domain       //定义本地域名<br>search        //定义域名的搜索列表<br>sortlist        //对返回的域名进行排序</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://www.cnblogs.com/f-ck-need-u/p/7074594.html" target="_blank" rel="noopener">http://www.cnblogs.com/f-ck-need-u/p/7074594.html</a><br><a href="https://www.cnblogs.com/wolfkingzzy/archive/2012/04/07/Linux%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE.html" target="_blank" rel="noopener">https://www.cnblogs.com/wolfkingzzy/archive/2012/04/07/Linux%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE.html</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>maven自定义archetype项目脚手架</title>
    <url>/2020/04/03/maven%E8%87%AA%E5%AE%9A%E4%B9%89archetype%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>maven是一个很好的代码构建工具，采用“约定优先于配置”的原则进行项目管理，相信很多的java开发者应该都了解maven并可能在工作当中都是通过maven来管理项目的，在创建的项目的时候，我们往往会使用maven内置的项目骨架也就是archetype来快速生成项目结构。但是在一个团队做开发的过程中，可能仅仅依靠maven预先提供的archetyp可能是不够的，团队之间协作有自己的定义方式，每个人的结构定义风格也不尽相同，在这样的背景下我们有必要去定义一个统一的代码骨架供团队使用，这样做的好处是当团队需要开始一个新项目的时候，可以利用自定义的maven骨架一键生成项目。</p>
<p>archetype是在maven-archetype-plugin插件执行generate目标的时候进行配置的，我们经常使用到maven的内嵌的骨架包括：maven-archetype-webapp、maven-archetype-quickstart。前者用来快速搭建一个web工程项目，后者用来快速搭建一个普通的java工程项目。</p>
<h4 id="单模块项目的archetype"><a href="#单模块项目的archetype" class="headerlink" title="单模块项目的archetype"></a>单模块项目的archetype</h4><p>单模块项目的archetype脚手架项目的结构<br><img src="/2020/04/03/maven自定义archetype项目脚手架/mvn1.png" alt="avatar"><br>上图中的各个文件详解：</p>
<ul>
<li>根目录beast-archetype下的pom.xml和一般的maven项目一样主要定义archetype项目的坐标等信息。</li>
<li>所有的项目骨架内容都集中在src/main/resources/archetype-resources文件夹下。</li>
<li>archetype-resources中的pom.xml定义了待生成项目的pom文件的内容，/src/main/java、/src/test/java中分别定义了待生成项目中相应目录下的内容</li>
<li>/src/main/resources/META-INF/maven/archetype-metadata.xml中定义相关的元数据描述(其中该文件的位置固定为resources/META-INF/maven文件夹下,且名称固定为archetype-metadata.xml)。</li>
</ul>
<p>1.beast-archetype/pom.xml内容如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.thebeastshop&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;beast-archetype&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;beast-archetype&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.apache.org&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;beast-archetype&lt;/finalName&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中：上面${}标识的变量都是通过maven中的命令行传进来的，如：mvn archetype:generate -DgroupId=com.thebeastshop<br>2.src/main/resources/archetype-resources/pom.xml内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">            http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;$&#123;groupId&#125;&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;$&#123;artifactId&#125;&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;$&#123;artifactId&#125;&lt;/name&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">             &lt;plugin&gt; </span><br><span class="line">                 &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; </span><br><span class="line">                 &lt;configuration&gt; </span><br><span class="line">                    &lt;skip&gt;true&lt;/skip&gt; </span><br><span class="line">                 &lt;/configuration&gt; </span><br><span class="line">             &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">        &lt;pluginManagement&gt;</span><br><span class="line">            &lt;plugins&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">                    &lt;configuration&gt;</span><br><span class="line">                        &lt;source&gt;1.7&lt;/source&gt;</span><br><span class="line">                        &lt;target&gt;1.7&lt;/target&gt;</span><br><span class="line">                    &lt;/configuration&gt;</span><br><span class="line">                &lt;/plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">                    &lt;configuration&gt;</span><br><span class="line">                        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                    &lt;/configuration&gt;</span><br><span class="line">                &lt;/plugin&gt;</span><br><span class="line">            &lt;/plugins&gt;</span><br><span class="line">        &lt;/pluginManagement&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中：上面${}标识的变量都是通过maven中的命令行传进来的，如：mvn archetype:generate -DgroupId=com.thebeastshop<br>3.src/main/resources/META-INF/maven/archetype-metadata.xml内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;archetype-descriptor  name=&quot;beast-archetype&quot;</span><br><span class="line">        xmlns=&quot;http://maven.apache.org/plugins/maven-archetype-plugin/archetype-descriptor/1.0.0&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;</span><br><span class="line">            http://maven.apache.org/plugins/maven-archetype-plugin/archetype-descriptor/1.0.0</span><br><span class="line">            http://maven.apache.org/xsd/archetype-descriptor-1.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;requiredProperties&gt;</span><br><span class="line">        &lt;requiredProperty key=&quot;package-name&quot; /&gt;</span><br><span class="line">    &lt;/requiredProperties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;fileSets&gt;</span><br><span class="line">        &lt;fileSet filtered=&quot;true&quot; packaged=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">            &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**/*.java&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">        &lt;/fileSet&gt;</span><br><span class="line">        &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">        &lt;/fileSet&gt;</span><br><span class="line">        &lt;fileSet filtered=&quot;true&quot; packaged=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">            &lt;directory&gt;src/test/java&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**/*.java&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">        &lt;/fileSet&gt;</span><br><span class="line">        &lt;fileSet encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">            &lt;directory&gt;src/test/resources&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">        &lt;/fileSet&gt;</span><br><span class="line">    &lt;/fileSets&gt;</span><br><span class="line">&lt;/archetype-descriptor&gt;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ul>
<li>packaged=”true”标识src/main/resources/archetype-resources/src/main/java中对应的内容是否要放入到package中,比如package为com.thebeastshop,那么如果该属性为true,则对应的java文件会放到com/thebeastshop文件夹下，也就是包路径下。</li>
<li>filtered=”true”标识下面提到的${}是否要进行替换</li>
</ul>
<p>4.src/main/resources/archetype-resources/src/main/java/Demo.java内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package $&#123;package&#125;;</span><br><span class="line"></span><br><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main( String[] args )</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println( &quot;Hello My Archetype!&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.这样我们就手写好了一个自定义的maven的archetype骨架项目，我们只需要通过mvn clean install 命令把该jar包安装到本地仓库，然后通过本地仓库中的该jar包来生成一个项目看看效果，使用如下命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate </span><br><span class="line">　　-DgroupId=comthebeastshop </span><br><span class="line">　　-DartifactId=beast-test </span><br><span class="line">　　-Dpackage=&quot;com.thebeastshop.test&quot; </span><br><span class="line">　　-DarchetypeGroupId=com.thebeastshop </span><br><span class="line">　　-DarchetypeArtifactId=beast-archetype -DarchetypeVersion=1.1 -X -DarchetypeCatalog=local</span><br></pre></td></tr></table></figure></p>
<h4 id="多模块项目的archetype"><a href="#多模块项目的archetype" class="headerlink" title="多模块项目的archetype"></a>多模块项目的archetype</h4><p>1.多模块骨架项目的项目结构<br><img src="/2020/04/03/maven自定义archetype项目脚手架/mvn2.png" alt="avatar"></p>
<p>这跟单模块项目区别不大，但是有几个概念需要说明：</p>
<ul>
<li>“<strong>rootArtifactId</strong>”占位符会被parent项目的artifactId替换</li>
<li>${rootArtifactId}也会被parent项目的artifactId替换</li>
<li><p>src/main/resources/archetype-resources里必须要有一个顶级pom文件（如果是单工程就是工程pom文件），同时子文件夹代表了模块定义<br>2.模板工程定义描述文件：META-INF/maven/archetype-metadata.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;archetype-descriptor  name=&quot;beast-archetype&quot;</span><br><span class="line">        xmlns=&quot;http://maven.apache.org/plugins/maven-archetype-plugin/archetype-descriptor/1.0.0&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;</span><br><span class="line">            http://maven.apache.org/plugins/maven-archetype-plugin/archetype-descriptor/1.0.0</span><br><span class="line">            http://maven.apache.org/xsd/archetype-descriptor-1.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;requiredProperties&gt;</span><br><span class="line">        &lt;requiredProperty key=&quot;groupId&quot;&gt;</span><br><span class="line">            &lt;defaultValue&gt;com.thebeastshop&lt;/defaultValue&gt;</span><br><span class="line">        &lt;/requiredProperty&gt;</span><br><span class="line">        &lt;requiredProperty key=&quot;artifactId&quot;&gt;</span><br><span class="line">            &lt;defaultValue&gt;test&lt;/defaultValue&gt;</span><br><span class="line">        &lt;/requiredProperty&gt;</span><br><span class="line">        &lt;requiredProperty key=&quot;package&quot;&gt;</span><br><span class="line">            &lt;defaultValue&gt;com.thebeastshop.test&lt;/defaultValue&gt;</span><br><span class="line">        &lt;/requiredProperty&gt;</span><br><span class="line">    &lt;/requiredProperties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module id=&quot;$&#123;rootArtifactId&#125;-api&quot; name=&quot;$&#123;rootArtifactId&#125;-api&quot; dir=&quot;__rootArtifactId__-api&quot;&gt;</span><br><span class="line">            &lt;fileSets&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot; packaged=&quot;true&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot; packaged=&quot;true&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/java&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/resources&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">            &lt;/fileSets&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;module id=&quot;$&#123;rootArtifactId&#125;-core&quot; name=&quot;$&#123;rootArtifactId&#125;-core&quot; dir=&quot;__rootArtifactId__-core&quot;&gt;</span><br><span class="line">            &lt;fileSets&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot; packaged=&quot;true&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot; packaged=&quot;true&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/java&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/resources&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">            &lt;/fileSets&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;module id=&quot;$&#123;rootArtifactId&#125;-dao&quot; name=&quot;$&#123;rootArtifactId&#125;-dao&quot; dir=&quot;__rootArtifactId__-dao&quot;&gt;</span><br><span class="line">            &lt;fileSets&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot; packaged=&quot;true&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot; packaged=&quot;true&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/java&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                        &lt;include&gt;mapper&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/resources&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">            &lt;/fileSets&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;module id=&quot;$&#123;rootArtifactId&#125;-main&quot; name=&quot;$&#123;rootArtifactId&#125;-main&quot; dir=&quot;__rootArtifactId__-main&quot;&gt;</span><br><span class="line">            &lt;fileSets&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot; packaged=&quot;true&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot; packaged=&quot;true&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/java&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/resources&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/assembly&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/bin&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">            &lt;/fileSets&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">        &lt;module id=&quot;$&#123;rootArtifactId&#125;-mybatisGen&quot; name=&quot;$&#123;rootArtifactId&#125;-mybatisGen&quot; dir=&quot;__rootArtifactId__-mybatisGen&quot;&gt;</span><br><span class="line">            &lt;fileSets&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot; packaged=&quot;true&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet filtered=&quot;true&quot; encoding=&quot;UTF-8&quot; packaged=&quot;true&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/java&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">                &lt;fileSet encoding=&quot;UTF-8&quot;&gt;</span><br><span class="line">                    &lt;directory&gt;src/test/resources&lt;/directory&gt;</span><br><span class="line">                    &lt;includes&gt;</span><br><span class="line">                        &lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">                    &lt;/includes&gt;</span><br><span class="line">                &lt;/fileSet&gt;</span><br><span class="line">            &lt;/fileSets&gt;</span><br><span class="line">        &lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/archetype-descriptor&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性变量定义,这些属性可以在资源元文件里的任意一个文件里通过${var}来引用，所以的元文件最终都可以选择通过velocity引擎来执行替换后生成。默认的属性有：groupId，artifactId，packeage，version等</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>CI&amp;CD</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql锁小结</title>
    <url>/2021/05/28/mysql%E9%94%81%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h4 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h4><p>mysql锁分为共享锁和排他锁，也叫做读锁和写锁。</p>
<p>读锁是共享的，可以通过lock in share mode实现，这时候只能读不能写。</p>
<p>写锁是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为表锁和⾏锁两种。</p>
<p>表锁会锁定整张表并且阻塞其他⽤户对该表的所有读写操作，⽐如alter修改表结构的时候会锁表。</p>
<p>⾏锁⼜可以分为乐观锁和悲观锁，悲观锁可以通过for update实现，乐观锁则通过版本号实现。</p>
<h4 id="mysql-排它锁之行锁、间隙锁、后码锁"><a href="#mysql-排它锁之行锁、间隙锁、后码锁" class="headerlink" title="mysql 排它锁之行锁、间隙锁、后码锁"></a>mysql 排它锁之行锁、间隙锁、后码锁</h4><p>MySQL InnoDB支持三种行锁定</p>
<ol>
<li>行锁（Record Lock）:锁直接加在索引记录上面，锁住的是key。</li>
<li>间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而设计的。</li>
<li>后码锁（Next-Key Lock）：行锁和间隙锁组合起来就叫Next-Key Lock。</li>
</ol>
<p>默认情况下，InnoDB工作在可重复读隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。</p>
<h4 id="行锁-Record-Lock"><a href="#行锁-Record-Lock" class="headerlink" title="行锁(Record Lock)"></a>行锁(Record Lock)</h4><ul>
<li>当需要对表中的某条数据进行写操作（insert、update、delete、select for update）时，需要先获取记录的排他锁（X锁），这个就称为行锁。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table x(`id` int, `num` int, index `idx_id` (`id`));</span><br><span class="line">insert into x values(1, 1), (2, 2);</span><br><span class="line"></span><br><span class="line">-- 事务A</span><br><span class="line">START TRANSACTION;</span><br><span class="line">update x set id = 1 where id = 1;</span><br><span class="line"></span><br><span class="line">-- 事务B</span><br><span class="line">-- 如果事务A没有commit，id=1的记录拿不到X锁，将出现等待</span><br><span class="line">START TRANSACTION;</span><br><span class="line">update x set id = 1 where id = 1;</span><br><span class="line"></span><br><span class="line">-- 事务C</span><br><span class="line">-- id=2的记录可以拿到X锁，不会出现等待</span><br><span class="line">START TRANSACTION;</span><br><span class="line">update x set id = 2 where id = 2;</span><br></pre></td></tr></table></figure>
<ul>
<li>针对InnoDB RR隔离级别，上述SQL示例展示了行锁的特点：“锁定特定行不允许进行修改”，但行锁是基于表索引的，如果where条件中用的是num字段（非索引列）将产生不一样的现象：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 事务A</span><br><span class="line">START TRANSACTION;</span><br><span class="line">update x set num = 1 where num = 1;</span><br><span class="line"></span><br><span class="line">-- 事务B</span><br><span class="line">-- 由于事务A中num字段上没有索引将产生表锁，导致整张表的写操作都会出现等待</span><br><span class="line">START TRANSACTION;</span><br><span class="line">update x set num = 1 where num = 1;</span><br><span class="line"></span><br><span class="line">-- 事务C</span><br><span class="line">-- 同理，会出现等待</span><br><span class="line">START TRANSACTION;</span><br><span class="line">update x set num = 2 where num = 2;</span><br><span class="line"></span><br><span class="line">-- 事务D</span><br><span class="line">-- 等待</span><br><span class="line">START TRANSACTION;</span><br><span class="line">insert into x values(3, 3);</span><br></pre></td></tr></table></figure>
<h4 id="Gap锁-Gap-Lock"><a href="#Gap锁-Gap-Lock" class="headerlink" title="Gap锁(Gap Lock)"></a>Gap锁(Gap Lock)</h4><p>在MySQL中select称为快照读，不需要锁，而insert、update、delete、select for update则称为当前读，需要给数据加锁，幻读中的“读”即是针对当前读。</p>
<p>RR事务隔离级别允许存在幻读，但InnoDB RR级别却通过Gap锁避免了幻读</p>
<p>产生间隙锁的条件（RR事务隔离级别下）</p>
<ul>
<li>使用普通索引锁定</li>
<li>使用多列唯一索引</li>
<li>使用唯一索引锁定多行记录</li>
</ul>
<p><strong>唯一索引的间隙锁</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试环境</span><br><span class="line"></span><br><span class="line">MySQL，InnoDB，默认的隔离级别（RR）</span><br><span class="line"></span><br><span class="line">数据表</span><br><span class="line"></span><br><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` int(1) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(8) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">数据</span><br><span class="line"></span><br><span class="line">INSERT INTO `test` VALUES (&apos;1&apos;, &apos;小罗&apos;);</span><br><span class="line">INSERT INTO `test` VALUES (&apos;5&apos;, &apos;小黄&apos;);</span><br><span class="line">INSERT INTO `test` VALUES (&apos;7&apos;, &apos;小明&apos;);</span><br><span class="line">INSERT INTO `test` VALUES (&apos;11&apos;, &apos;小红&apos;);</span><br></pre></td></tr></table></figure>
<p>以上数据，会生成隐藏间隙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(-infinity, 1] (1, 5] (5, 7] (7, 11] (11, +infinity]</span><br></pre></td></tr></table></figure>
<p><strong>只使用记录锁，不会产生间隙锁</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 开启事务1 */</span><br><span class="line">BEGIN;</span><br><span class="line">/* 查询 id = 5 的数据并加记录锁 */</span><br><span class="line">SELECT * FROM `test` WHERE `id` = 5 FOR UPDATE;</span><br><span class="line">/* 延迟30秒执行，防止锁释放 */</span><br><span class="line">SELECT SLEEP(30);</span><br><span class="line"></span><br><span class="line">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span><br><span class="line"></span><br><span class="line">/* 事务2插入一条 name = &apos;小张&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (4, &apos;小张&apos;); # 正常执行</span><br><span class="line"></span><br><span class="line">/* 事务3插入一条 name = &apos;小张&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (8, &apos;小东&apos;); # 正常执行</span><br><span class="line"></span><br><span class="line">/* 提交事务1，释放事务1的锁 */</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<p>以上，由于主键是唯一索引，而且是只使用一个索引查询，并且只锁定一条记录，所以，只会对 id = 5 的数据加上记录锁，而不会产生间隙锁。</p>
<p><strong>产生间隙锁</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 开启事务1 */</span><br><span class="line">BEGIN;</span><br><span class="line">/* 查询 id 在 7 - 11 范围的数据并加记录锁 */</span><br><span class="line">SELECT * FROM `test` WHERE `id` BETWEEN 5 AND 11 FOR UPDATE;</span><br><span class="line">/* 延迟30秒执行，防止锁释放 */</span><br><span class="line">SELECT SLEEP(30);</span><br><span class="line"></span><br><span class="line">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span><br><span class="line"></span><br><span class="line">/* 事务2插入一条 id = 3，name = &apos;小张1&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (3, &apos;小张1&apos;); # 正常执行</span><br><span class="line"></span><br><span class="line">/* 事务3插入一条 id = 4，name = &apos;小白&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (4, &apos;小白&apos;); # 正常执行</span><br><span class="line"></span><br><span class="line">/* 事务4插入一条 id = 6，name = &apos;小东&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (6, &apos;小东&apos;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 事务5插入一条 id = 8， name = &apos;大罗&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (8, &apos;大罗&apos;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 事务6插入一条 id = 9， name = &apos;大东&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (9, &apos;大东&apos;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 事务7插入一条 id = 11， name = &apos;李西&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (11, &apos;李西&apos;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 事务8插入一条 id = 12， name = &apos;张三&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (12, &apos;张三&apos;); # 正常执行</span><br><span class="line"></span><br><span class="line">/* 提交事务1，释放事务1的锁 */</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看到，(5, 7]、(7, 11] 这两个区间，都不可插入数据，其它区间，都可以正常插入数据。所以当我们给 (5, 7] 这个区间加锁的时候，会锁住 (5, 7]、(7, 11] 这两个区间。</p>
<p><strong>锁住不存在的数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 开启事务1 */</span><br><span class="line">BEGIN;</span><br><span class="line">/* 查询 id = 3 这一条不存在的数据并加记录锁 */</span><br><span class="line">SELECT * FROM `test` WHERE `id` = 3 FOR UPDATE;</span><br><span class="line">/* 延迟30秒执行，防止锁释放 */</span><br><span class="line">SELECT SLEEP(30);</span><br><span class="line"></span><br><span class="line">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span><br><span class="line"></span><br><span class="line">/* 事务2插入一条 id = 3，name = &apos;小张1&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (2, &apos;小张1&apos;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 事务3插入一条 id = 4，name = &apos;小白&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (4, &apos;小白&apos;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 事务4插入一条 id = 6，name = &apos;小东&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (6, &apos;小东&apos;); # 正常执行</span><br><span class="line"></span><br><span class="line">/* 事务5插入一条 id = 8， name = &apos;大罗&apos; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (8, &apos;大罗&apos;); # 正常执行</span><br><span class="line"></span><br><span class="line">/* 提交事务1，释放事务1的锁 */</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<p>我们可以看出，指定查询某一条记录时，如果这条记录不存在，会产生间隙锁</p>
<p>结论</p>
<ul>
<li>对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁，如：WHERE id = 5 FOR UPDATE;</li>
<li>对于查找某一范围内的查询语句，会产生间隙锁，如：WHERE id BETWEEN 5 AND 7 FOR UPDATE;</li>
</ul>
<p><strong>普通索引的间隙锁</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `test1` (</span><br><span class="line">  `id` int(1) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `number` int(1) NOT NULL COMMENT &apos;数字&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `number` (`number`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">id 是主键，number上建立了一个普通索引。先加一些数据：</span><br><span class="line"></span><br><span class="line">INSERT INTO `test1` VALUES (1, 1);</span><br><span class="line">INSERT INTO `test1` VALUES (5, 3);</span><br><span class="line">INSERT INTO `test1` VALUES (7, 8);</span><br><span class="line">INSERT INTO `test1` VALUES (11, 12);</span><br><span class="line"></span><br><span class="line">test1表中 number 索引存在的隐藏间隙：</span><br><span class="line"></span><br><span class="line">(-infinity, 1] (1, 3] (3, 8] (8, 12] (12, +infinity]</span><br></pre></td></tr></table></figure>
<p><strong>执行以下的事务（事务1最后提交）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 开启事务1 */</span><br><span class="line">BEGIN;</span><br><span class="line">/* 查询 number = 5 的数据并加记录锁 */</span><br><span class="line">SELECT * FROM `test1` WHERE `number` = 3 FOR UPDATE;</span><br><span class="line">/* 延迟30秒执行，防止锁释放 */</span><br><span class="line">SELECT SLEEP(30);</span><br><span class="line"></span><br><span class="line">-- 注意：以下的语句不是放在一个事务中执行，而是分开多次执行，每次事务中只有一条添加语句</span><br><span class="line"></span><br><span class="line">/* 事务2插入一条 number = 0 的数据 */</span><br><span class="line">INSERT INTO `test1` (`number`) VALUES (0); -- 正常执行</span><br><span class="line"></span><br><span class="line">/* 事务3插入一条 number = 1 的数据 */</span><br><span class="line">INSERT INTO `test1` (`number`) VALUES (1); -- 被阻塞</span><br><span class="line"></span><br><span class="line">/* 事务4插入一条 number = 2 的数据 */</span><br><span class="line">INSERT INTO `test1` (`number`) VALUES (2); -- 被阻塞</span><br><span class="line"></span><br><span class="line">/* 事务5插入一条 number = 4 的数据 */</span><br><span class="line">INSERT INTO `test1` (`number`) VALUES (4); -- 被阻塞</span><br><span class="line"></span><br><span class="line">/* 事务6插入一条 number = 8 的数据 */</span><br><span class="line">INSERT INTO `test1` (`number`) VALUES (8); -- 正常执行</span><br><span class="line"></span><br><span class="line">/* 事务7插入一条 number = 9 的数据 */</span><br><span class="line">INSERT INTO `test1` (`number`) VALUES (9); -- 正常执行</span><br><span class="line"></span><br><span class="line">/* 事务8插入一条 number = 10 的数据 */</span><br><span class="line">INSERT INTO `test1` (`number`) VALUES (10); -- 正常执行</span><br><span class="line"></span><br><span class="line">/* 提交事务1 */</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，number (1 - 8) 的间隙中，插入语句都被阻塞了，而不在这个范围内的语句，正常执行，这就是因为有间隙锁的原因。</p>
<p>结论</p>
<ul>
<li>在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样</li>
<li>在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序</li>
</ul>
<h4 id="ACID靠什么保证"><a href="#ACID靠什么保证" class="headerlink" title="ACID靠什么保证"></a>ACID靠什么保证</h4><p>A原⼦性由undo log⽇志保证，它记录了需要回滚的⽇志信息，事务回滚时撤销已经执⾏成功的sql</p>
<p>C⼀致性⼀般由代码层⾯来保证</p>
<p>I隔离性由MVCC来保证</p>
<p>D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复</p>
<h4 id="分表后的ID怎么保证唯⼀性"><a href="#分表后的ID怎么保证唯⼀性" class="headerlink" title="分表后的ID怎么保证唯⼀性"></a>分表后的ID怎么保证唯⼀性</h4><p>因为我们主键默认都是⾃增的，那么分表之后的主键在不同表就肯定会有冲突了。有⼏个办法考虑：</p>
<ol>
<li>设定步⻓，⽐如1-1024张表我们设定1024的基础步⻓，这样主键落到不同的表就不会冲突了。</li>
<li>分布式ID，⾃⼰实现⼀套分布式ID⽣成算法或者使⽤开源的⽐如雪花算法这种</li>
<li>分表后不使⽤主键作为查询依据，⽽是每张表单独新增⼀个字段作为唯⼀主键使⽤，⽐如订单表订单号是唯⼀的，不管最终落在哪张表都基于订单号作为查询依据，更新也⼀样。</li>
</ol>
<h4 id="分表后⾮sharding-key的查询"><a href="#分表后⾮sharding-key的查询" class="headerlink" title="分表后⾮sharding_key的查询"></a>分表后⾮sharding_key的查询</h4><ol>
<li><p>可以做⼀个mapping表，⽐如这时候商家要查询订单列表怎么办呢？不带user_id查询的话你总不能扫全表吧？所以我们可以做⼀个映射关系表，保存商家和⽤户的关系，查询的时候先通过商家查询到⽤户列表，再通过user_id去查询。</p>
</li>
<li><p>打宽表，⼀般⽽⾔，商户端对数据实时性要求并不是很⾼，⽐如查询订单列表，可以把订单表同步到离线（实时）数仓，再基于数仓去做成⼀张宽表，再基于其他如es提供查询服务。</p>
</li>
<li><p>数据量不是很⼤的话，⽐如后台的⼀些查询之类的，也可以通过多线程扫表，然后再聚合结果的⽅式来做。或者异步的形式也是可以的。</p>
</li>
</ol>
<h4 id="mysql主从同步"><a href="#mysql主从同步" class="headerlink" title="mysql主从同步"></a>mysql主从同步</h4><ol>
<li>master提交完事务后，写⼊binlog</li>
<li>slave连接到master，获取binlog</li>
<li>master创建dump线程，推送binglog到slave</li>
<li>slave启动⼀个IO线程读取同步过来的master的binlog，记录到relay log中继⽇志中</li>
<li>slave再开启⼀个sql线程读取relay log事件并在slave执⾏，完成同步</li>
<li>slave记录⾃⼰的binglog</li>
</ol>
<p>由于mysql默认的复制⽅式是异步的，主库把⽇志发送给从库后不关⼼从库是否已经处理，这样会产⽣⼀个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，⽇志就丢失了。由此产⽣两个概念。<br><img src="/2021/05/28/mysql锁小结/mysql1.png" alt="avatar"></p>
<p>全同步复制</p>
<p>主库写⼊binlog后强制同步⽇志到从库，所有的从库都执⾏完成后才返回给客户端，但是很显然这个⽅式的话性能会受到严重影响。</p>
<p>半同步复制</p>
<p>和全同步不同的是，半同步复制的逻辑是这样，从库写⼊⽇志成功后返回ACK确认给主库，主库收到⾄少⼀个从库的确认就认为写操作完成。</p>
<p>那主从的延迟怎么解决呢？</p>
<ol>
<li>针对特定的业务场景，读写请求都强制⾛主库</li>
<li>读请求⾛从库，如果没有数据，去主库做⼆次查询</li>
</ol>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol>
<li><a href="https://juejin.cn/post/6844903997090824200" target="_blank" rel="noopener">https://juejin.cn/post/6844903997090824200</a></li>
</ol>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>python中函数用法</title>
    <url>/2020/09/12/python%E4%B8%AD%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>函数（Functions）是指可重复使用的程序片段。它们允许你为某个代码块赋予名字，允许你通过这一特殊的名字在你的程序任何地方来运行代码块，并可重复任何次数。这就是所谓的调用（Calling）函数。我们已经使用过了许多内置的函数，例如 len 和 range。</p>
<p>函数概念可能是在任何复杂的软件（无论使用的是何种编程语言）中最重要的构建块，所以我们接下来将在本章中探讨有关函数的各个方面。</p>
<p>函数可以通过关键字 def 来定义。这一关键字后跟一个函数的标识符名称，再跟一对圆括号，其中可以包括一些变量的名称，再以冒号结尾，结束这一行。随后而来的语句块是函数的一部分。下面的案例将会展示出这其实非常简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def say_hello():</span><br><span class="line">    # 该块属于这一函数</span><br><span class="line">    print(&apos;hello world&apos;)</span><br><span class="line"># 函数结束</span><br><span class="line"></span><br><span class="line">say_hello()  # 调用函数</span><br><span class="line">say_hello()  # 再次调用函数</span><br><span class="line"></span><br><span class="line">$ python function1.py</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>我们以上文解释过的方式定义名为 say_hello 的函数。这个函数不使用参数，因此在括号中没有声明变量。函数的参数只是输入到函数之中，以便我可以传递不同的值给它，并获得相应的结果。</p>
<p>要注意到我们可以两次调用相同的函数，这意味着我们不必重新把代码再写一次。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数可以获取参数，这个参数的值由你所提供，借此，函数便可以利用这些值来做一些事情。这些参数与变量类似，这些变量的值在我们调用函数时已被定义，且在函数运行时均已赋值完成。</p>
<p>函数中的参数通过将其放置在用以定义函数的一对圆括号中指定，并通过逗号予以分隔。当我们调用函数时，我们以同样的形式提供需要的值。要注意在此使用的术语——在定义函数时给定的名称称作“形参”（Parameters），在调用函数时你所提供给函数的值称作“实参”（Arguments）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_max(a, b):</span><br><span class="line">    if a &gt; b:</span><br><span class="line">        print(a, &apos;is maximum&apos;)</span><br><span class="line">    elif a == b:</span><br><span class="line">        print(a, &apos;is equal to&apos;, b)</span><br><span class="line">    else:</span><br><span class="line">        print(b, &apos;is maximum&apos;)</span><br><span class="line"></span><br><span class="line"># 直接传递字面值</span><br><span class="line">print_max(3, 4)</span><br><span class="line"></span><br><span class="line">x = 5</span><br><span class="line">y = 7</span><br><span class="line"></span><br><span class="line"># 以参数的形式传递变量</span><br><span class="line">print_max(x, y)</span><br><span class="line"></span><br><span class="line">$ python function_param.py</span><br><span class="line">4 is maximum</span><br><span class="line">7 is maximum</span><br></pre></td></tr></table></figure>
<p>它是如何工作的</p>
<p>在这里，我们将函数命名为 print_max 并使用两个参数分别称作 a 和 b。我们使用一个简单的 if…else 语句来找出更大的那个数，并将它打印出来。</p>
<p>第一次调用函数 print_max 时，我们以实参的形式直接向函数提供这一数字。在第二次调用时，我们将变量作为实参来调用函数。print_max(x, y) 将使得实参 x 的值将被赋值给形参 a，而实参 y 的值将被赋值给形参 b。在两次调用中，print_max 都以相同的方式工作。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>当你在一个函数的定义中声明变量时，它们不会以任何方式与身处函数之外但具有相同名称的变量产生关系，也就是说，这些变量名只存在于函数这一局部（Local）。这被称为变量的作用域（Scope）。所有变量的作用域是它们被定义的块，从定义它们的名字的定义点开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = 50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func(x):</span><br><span class="line">    print(&apos;x is&apos;, x)</span><br><span class="line">    x = 2</span><br><span class="line">    print(&apos;Changed local x to&apos;, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(x)</span><br><span class="line">print(&apos;x is still&apos;, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python function_local.py</span><br><span class="line">x is 50</span><br><span class="line">Changed local x to 2</span><br><span class="line">x is still 50</span><br></pre></td></tr></table></figure>
<p>当我们第一次打印出存在于函数块的第一行的名为 x 的值时，Python 使用的是在函数声明之上的主代码块中声明的这一参数的值。</p>
<p>接着，我们将值 2 赋值给 x。x 是我们这一函数的局部变量。因此，当我们改变函数中 x 的值的时候，主代码块中的 x 则不会受到影响。</p>
<p>随着最后一句 print 语句，我们展示出主代码块中定义的 x 的值，由此确认它实际上不受先前调用的函数中的局部变量的影响。</p>
<h2 id="global-语句"><a href="#global-语句" class="headerlink" title="global 语句"></a>global 语句</h2><p>如果你想给一个在程序顶层的变量赋值（也就是说它不存在于任何作用域中，无论是函数还是类），那么你必须告诉 Python 这一变量并非局部的，而是全局（Global）的。我们需要通过 global 语句来完成这件事。因为在不使用 global 语句的情况下，不可能为一个定义于函数之外的变量赋值。</p>
<p>你可以使用定义于函数之外的变量的值（假设函数中没有具有相同名字的变量）。然而，这种方式不会受到鼓励而且应该避免，因为它对于程序的读者来说是含糊不清的，无法弄清楚变量的定义究竟在哪。而通过使用 global 语句便可清楚看出这一变量是在最外边的代码块中定义的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = 50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    global x</span><br><span class="line"></span><br><span class="line">    print(&apos;x is&apos;, x)</span><br><span class="line">    x = 2</span><br><span class="line">    print(&apos;Changed global x to&apos;, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">print(&apos;Value of x is&apos;, x)</span><br><span class="line"></span><br><span class="line">$ python function_global.py</span><br><span class="line">x is 50</span><br><span class="line">Changed global x to 2</span><br><span class="line">Value of x is 2</span><br></pre></td></tr></table></figure>
<p>global 语句用以声明 x 是一个全局变量——因此，当我们在函数中为 x 进行赋值时，这一改动将影响到我们在主代码块中使用的 x 的值。</p>
<p>你可以在同一句 global 语句中指定不止一个的全局变量，例如 global x, y, z。</p>
<h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><p>对于一些函数来说，你可能为希望使一些参数可选并使用默认的值，以避免用户不想为他们提供值的情况。默认参数值可以有效帮助解决这一情况。你可以通过在函数定义时附加一个赋值运算符（=）来为参数指定默认参数值。</p>
<p>要注意到，默认参数值应该是常数。更确切地说，默认参数值应该是不可变的——这将在后面的章节中予以更详细的解释。就目前来说，只要记住就行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def say(message, times=1):</span><br><span class="line">    print(message * times)</span><br><span class="line"></span><br><span class="line">say(&apos;Hello&apos;)</span><br><span class="line">say(&apos;World&apos;, 5)</span><br><span class="line"></span><br><span class="line">$ python function_default.py</span><br><span class="line">Hello</span><br><span class="line">WorldWorldWorldWorldWorld</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>只有那些位于参数列表末尾的参数才能被赋予默认参数值，意即在函数的参数列表中拥有默认参数值的参数不能位于没有默认参数值的参数之前。<br>这是因为值是按参数所处的位置依次分配的。举例来说，def func(a, b=5) 是有效的，但 def func(a=5, b) 是无效的。</p>
</blockquote>
<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>如果你有一些具有许多参数的函数，而你又希望只对其中的一些进行指定，那么你可以通过命名它们来给这些参数赋值——这就是关键字参数（Keyword Arguments）——我们使用命名（关键字）而非位置（一直以来我们所使用的方式）来指定函数中的参数。</p>
<p>这样做有两大优点——其一，我们不再需要考虑参数的顺序，函数的使用将更加容易。其二，我们可以只对那些我们希望赋予的参数以赋值，只要其它的参数都具有默认参数值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func(a, b=5, c=10):</span><br><span class="line">    print(&apos;a is&apos;, a, &apos;and b is&apos;, b, &apos;and c is&apos;, c)</span><br><span class="line"></span><br><span class="line">func(3, 7)</span><br><span class="line">func(25, c=24)</span><br><span class="line">func(c=50, a=100)</span><br><span class="line"></span><br><span class="line">$ python function_keyword.py</span><br><span class="line">a is 3 and b is 7 and c is 10</span><br><span class="line">a is 25 and b is 5 and c is 24</span><br><span class="line">a is 100 and b is 5 and c is 50</span><br></pre></td></tr></table></figure>
<p>名为 func 的函数有一个没有默认参数值的参数，后跟两个各自带有默认参数值的参数。</p>
<p>在第一次调用函数时，func(3, 7)，参数 a 获得了值 3，参数 b 获得了值 7，而 c 获得了默认参数值 10。</p>
<p>在第二次调用函数时，func(25, c=24)，由于其所处的位置，变量 a 首先获得了值 25。然后，由于命名——即关键字参数——指定，变量 c 获得了值 24。变量 b 获得默认参数值 5。</p>
<p>在第三次调用函数时，func(c=50, a=100)，我们全部使用关键字参数来指定值。在这里要注意到，尽管 a 在 c 之前定义，但我们还是在变量 a 之前指定了变量 c。</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>有时你可能想定义的函数里面能够有任意数量的变量，也就是参数数量是可变的，这可以通过使用星号来实现（将下方案例保存为 function_varargs.py）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def total(a=5, *numbers, **phonebook):</span><br><span class="line">    print(&apos;a&apos;, a)</span><br><span class="line"></span><br><span class="line">    #遍历元组中的所有项目</span><br><span class="line">    for single_item in numbers:</span><br><span class="line">        print(&apos;single_item&apos;, single_item)</span><br><span class="line"></span><br><span class="line">    #遍历字典中的所有项目</span><br><span class="line">    for first_part, second_part in phonebook.items():</span><br><span class="line">        print(first_part,second_part)</span><br><span class="line"></span><br><span class="line">print(total(10,1,2,3,Jack=1123,John=2231,Inge=1560))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python function_varargs.py</span><br><span class="line">a 10</span><br><span class="line">single_item 1</span><br><span class="line">single_item 2</span><br><span class="line">single_item 3</span><br><span class="line">Inge 1560</span><br><span class="line">John 2231</span><br><span class="line">Jack 1123</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>当我们声明一个诸如 *param 的星号参数时，从此处开始直到结束的所有位置参数（Positional Arguments）都将被收集并汇集成一个称为“param”的元组（Tuple）。</p>
<p>类似地，当我们声明一个诸如 **param 的双星号参数时，从此处开始直至结束的所有关键字参数都将被收集并汇集成一个名为 param 的字典（Dictionary）。</p>
<h2 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h2><p>return 语句用于从函数中返回，也就是中断函数。我们也可以选择在中断函数时从函数中返回一个值。</p>
<p>案例（保存为 function_return.py）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def maximum(x, y):</span><br><span class="line">    if x &gt; y:</span><br><span class="line">        return x</span><br><span class="line">    elif x == y:</span><br><span class="line">        return &apos;The numbers are equal&apos;</span><br><span class="line">    else:</span><br><span class="line">        return y</span><br><span class="line"></span><br><span class="line">print(maximum(2, 3))    </span><br><span class="line"></span><br><span class="line">$ python function_return.py</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>maximum 函数将会返回参数中的最大值，在本例中是提供给函数的数值。它使用一套简单的 if…else 语句来找到较大的那个值并将其返回。</p>
<p>要注意到如果 return 语句没有搭配任何一个值则代表着 返回 None。None 在 Python 中一个特殊的类型，代表着虚无。举个例子， 它用于指示一个变量没有值，如果有值则它的值便是 None（虚无）。</p>
<p>每一个函数都在其末尾隐含了一句 return None，除非你写了你自己的 return 语句。你可以运行 print(some_function())，其中 some_function 函数不使用 return 语句，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def some_function():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>Python 中的 pass 语句用于指示一个没有内容的语句块。</p>
<p>提示：有一个名为 max 的内置函数已经实现了“找到最大数”这一功能，所以尽可能地使用这一内置函数</p>
<h2 id="DocStrings"><a href="#DocStrings" class="headerlink" title="DocStrings"></a>DocStrings</h2><p>Python 有一个甚是优美的功能称作文档字符串（Documentation Strings），在称呼它时通常会使用另一个短一些的名字docstrings。DocStrings 是一款你应当使用的重要工具，它能够帮助你更好地记录程序并让其更加易于理解。令人惊叹的是，当程序实际运行时，我们甚至可以通过一个函数来获取文档！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_max(x, y):</span><br><span class="line">    &apos;&apos;&apos;打印两个数值中的最大数。</span><br><span class="line"></span><br><span class="line">    这两个数都应该是整数&apos;&apos;&apos;</span><br><span class="line">    # 如果可能，将其转换至整数类型</span><br><span class="line">    x = int(x)</span><br><span class="line">    y = int(y)</span><br><span class="line"></span><br><span class="line">    if x &gt; y:</span><br><span class="line">        print(x, &apos;is maximum&apos;)</span><br><span class="line">    else:</span><br><span class="line">        print(y, &apos;is maximum&apos;)</span><br><span class="line"></span><br><span class="line">print_max(3, 5)</span><br><span class="line">print(print_max.__doc__)</span><br><span class="line"></span><br><span class="line">$ python function_docstring.py</span><br><span class="line">5 is maximum</span><br><span class="line">打印两个数值中的最大数。</span><br><span class="line"></span><br><span class="line">    这两个数都应该是整数</span><br></pre></td></tr></table></figure>
<p>函数的第一行逻辑行中的字符串是该函数的 文档字符串（DocString）。这里要注意文档字符串也适用于后面相关章节将提到的模块（Modules）与类（Class） 。</p>
<p>该文档字符串所约定的是一串多行字符串，其中第一行以某一大写字母开始，以句号结束。第二行为空行，后跟的第三行开始是任何详细的解释说明。5在此强烈建议你在你所有重要功能的所有文档字符串中都遵循这一约定。</p>
<p>我们可以通过使用函数的 <strong>doc</strong>（注意其中的双下划綫）属性（属于函数的名称）来获取函数 print_max 的文档字符串属性。只消记住 Python 将所有东西都视为一个对象，这其中自然包括函数。我们将在后面的类（Class）章节讨论有关对象的更多细节。</p>
<p>如果你曾使用过 Python 的 help() 函数，那么你应该已经了解了文档字符串的用途了。它所做的便是获取函数的 <strong>doc</strong> 属性并以一种整洁的方式将其呈现给你。你可以在上方的函数中尝试一下——只需在程序中包含 help(print_max) 就行了。要记住你可以通过按下 q 键来退出 help。</p>
<p>自动化工具可以以这种方式检索你的程序中的文档。因此，我强烈推荐你为你编写的所有重要的函数配以文档字符串。你的 Python 发行版中附带的 pydoc 命令与 help() 使用文档字符串的方式类似。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的异步IO</title>
    <url>/2021/05/05/python%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5IO/</url>
    <content><![CDATA[<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程，又称微线程，纤程。英文名Coroutine。</p>
<h4 id="协程是啥"><a href="#协程是啥" class="headerlink" title="协程是啥"></a>协程是啥</h4><p>首先我们得知道协程是啥？协程其实可以认为是比线程更小的执行单元。 为啥说他是一个执行单元，因为他自带CPU上下文。这样只要在合适的时机， 我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复CPU上下文那么程序还是可以运行的。</p>
<p>通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定。</p>
<h4 id="协程和线程差异"><a href="#协程和线程差异" class="headerlink" title="协程和线程差异"></a>协程和线程差异</h4><p>那么这个过程看起来比线程差不多。其实不然, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。</p>
<h4 id="协程的问题"><a href="#协程的问题" class="headerlink" title="协程的问题"></a>协程的问题</h4><p>但是协程有一个问题，就是系统并不感知，所以操作系统不会帮你做切换。 那么谁来帮你做切换？让需要执行的协程更多的获得CPU时间才是问题的关键。</p>
<p>目前的协程框架一般都是设计成 1:N 模式。所谓 1:N 就是一个线程作为一个容器里面放置多个协程。 那么谁来适时的切换这些协程？答案是有协程自己主动让出CPU，也就是每个协程池里面有一个调度器， 这个调度器是被动调度的。意思就是他不会主动调度。而且当一个协程发现自己执行不下去了(比如异步等待网络的数据回来，但是当前还没有数据到)， 这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要CPU的协程。 切换这个协程的CPU上下文把CPU的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，或者它调用主动让出CPU的API之类，触发下一次调度。</p>
<p>其实是有问题的，假设这个线程中有一个协程是CPU密集型的他没有IO操作， 也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况， 所以这种情况下需要程序员自己避免。这是一个问题，假设业务开发的人员并不懂这个原理的话就可能会出现问题。</p>
<h4 id="协程的好处"><a href="#协程的好处" class="headerlink" title="协程的好处"></a>协程的好处</h4><p>在IO密集型的程序中由于IO操作远远慢于CPU的操作，所以往往需要CPU去等IO操作。 同步IO下系统需要切换线程，让操作系统可以在IO过程中执行其他的东西。 这样虽然代码是符合人类的思维习惯但是由于大量的线程切换带来了大量的性能的浪费，尤其是IO密集型的程序。</p>
<p>所以人们发明了异步IO。就是当数据到达的时候触发我的回调。来减少线程切换带来性能损失。 但是这样的坏处也是很大的，主要的坏处就是操作被 “分片” 了，代码写的不是 “一气呵成” 这种。 而是每次来段数据就要判断 数据够不够处理哇，够处理就处理吧，不够处理就在等等吧。这样代码的可读性很低，其实也不符合人类的习惯。</p>
<p>但是协程可以很好解决这个问题。比如 把一个IO操作 写成一个协程。当触发IO操作的时候就自动让出CPU给其他协程。要知道协程的切换很轻的。 协程通过这种对异步IO的封装 既保留了性能也保证了代码的容易编写和可读性。在高IO密集型的程序下很好。但是高CPU密集型的程序下没啥好处。</p>
<h4 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def A():</span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;----A---&quot;)</span><br><span class="line">        yield</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def B(c):</span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;----B---&quot;)</span><br><span class="line">        c.__next__()</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    a = A()</span><br><span class="line">    B(a)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def consumer():</span><br><span class="line">    r = &apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        n = yield r</span><br><span class="line">        if not n:</span><br><span class="line">            return</span><br><span class="line">        print(&apos;[CONSUMER] Consuming %s...&apos; % n)</span><br><span class="line">        r = &apos;200 OK&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def produce(c):</span><br><span class="line">    c.send(None)</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&apos;[PRODUCER] Producing %s...&apos; % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(&apos;[PRODUCER] Consumer return: %s&apos; % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">produce(c)</span><br></pre></td></tr></table></figure>
<p>注意到consumer函数是一个generator，把一个consumer传入produce后：</p>
<ol>
<li>首先调用c.send(None)启动生成器；</li>
<li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</li>
<li>consumer通过yield拿到消息，处理，又通过yield把结果传回；</li>
<li>produce拿到consumer处理的结果，继续生产下一条消息；</li>
<li>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</li>
</ol>
<p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p>
<h3 id="协程-greenlet版"><a href="#协程-greenlet版" class="headerlink" title="协程-greenlet版"></a>协程-greenlet版</h3><p>为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from greenlet import greenlet</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;---A---&quot;)</span><br><span class="line">        gr2.switch()</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;---B--&quot;)</span><br><span class="line">        gr1.switch()</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gr1 = greenlet(test1)</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line"></span><br><span class="line"># 切换到gr1中运行</span><br><span class="line">gr1.switch()</span><br></pre></td></tr></table></figure>
<h3 id="协程-gevent"><a href="#协程-gevent" class="headerlink" title="协程-gevent"></a>协程-gevent</h3><p>greenlet已经实现了协程，但是这个还的人工切换，是不是觉得太麻烦了，不要捉急，python还有一个比greenlet更强大的并且能够自动切换任务的模块gevent</p>
<p>其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。</p>
<p>由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。</p>
<p><strong>gevent的使用</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import gevent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f(n):</span><br><span class="line">    for i in range(n):</span><br><span class="line">        print(&quot;gevent is %s,i is %s &quot; % (gevent.getcurrent(), i))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(f, 5)</span><br><span class="line">g2 = gevent.spawn(f, 5)</span><br><span class="line">g3 = gevent.spawn(f, 5)</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2848: f(5)&gt;,i is 0 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2848: f(5)&gt;,i is 1 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2848: f(5)&gt;,i is 2 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2848: f(5)&gt;,i is 3 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2848: f(5)&gt;,i is 4 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2948: f(5)&gt;,i is 0 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2948: f(5)&gt;,i is 1 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2948: f(5)&gt;,i is 2 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2948: f(5)&gt;,i is 3 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2948: f(5)&gt;,i is 4 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2a48: f(5)&gt;,i is 0 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2a48: f(5)&gt;,i is 1 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2a48: f(5)&gt;,i is 2 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2a48: f(5)&gt;,i is 3 </span><br><span class="line">gevent is &lt;Greenlet at 0x1070a2a48: f(5)&gt;,i is 4</span><br></pre></td></tr></table></figure></p>
<p><strong>gevent切换执行</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import gevent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f(n):</span><br><span class="line">    for i in range(n):</span><br><span class="line">        print(&quot;gevent is %s,i is %s &quot; % (gevent.getcurrent(), i))</span><br><span class="line">        gevent.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(f, 5)</span><br><span class="line">g2 = gevent.spawn(f, 5)</span><br><span class="line">g3 = gevent.spawn(f, 5)</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2848: f(5)&gt;,i is 0 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2948: f(5)&gt;,i is 0 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2a48: f(5)&gt;,i is 0 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2848: f(5)&gt;,i is 1 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2948: f(5)&gt;,i is 1 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2a48: f(5)&gt;,i is 1 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2848: f(5)&gt;,i is 2 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2948: f(5)&gt;,i is 2 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2a48: f(5)&gt;,i is 2 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2848: f(5)&gt;,i is 3 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2948: f(5)&gt;,i is 3 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2a48: f(5)&gt;,i is 3 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2848: f(5)&gt;,i is 4 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2948: f(5)&gt;,i is 4 </span><br><span class="line">gevent is &lt;Greenlet at 0x10a0d2a48: f(5)&gt;,i is 4</span><br></pre></td></tr></table></figure></p>
<p><strong>gevent版-TCP服务器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import gevent</span><br><span class="line"></span><br><span class="line">from gevent import socket, monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def handle_request(conn):</span><br><span class="line">    while True:</span><br><span class="line">        data = conn.recv(1024)</span><br><span class="line">        if not data:</span><br><span class="line">            conn.close()</span><br><span class="line">            break</span><br><span class="line">        print(&quot;recv:&quot;, data)</span><br><span class="line">        conn.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def server(port):</span><br><span class="line">    s = socket.socket()</span><br><span class="line">    s.bind((&apos;&apos;, port))</span><br><span class="line">    s.listen(5)</span><br><span class="line">    while True:</span><br><span class="line">        cli, addr = s.accept()</span><br><span class="line">        gevent.spawn(handle_request, cli)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    server(7788)</span><br></pre></td></tr></table></figure>
<h3 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h3><p>asyncio的编程模型就是一个消息循环。我们从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO。</p>
<p>用asyncio实现Hello world代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def hello():</span><br><span class="line">    print(&quot;Hello world!&quot;)</span><br><span class="line">    # 异步调用asyncio.sleep(1):</span><br><span class="line">    r = yield from asyncio.sleep(1)</span><br><span class="line">    print(&quot;Hello again!&quot;)</span><br><span class="line"></span><br><span class="line"># 获取EventLoop:</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"># 执行coroutine</span><br><span class="line">loop.run_until_complete(hello())</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>
<p>@asyncio.coroutine把一个generator标记为coroutine类型，然后，我们就把这个coroutine扔到EventLoop中执行。</p>
<p>hello()会首先打印出Hello world!，然后，yield from语法可以让我们方便地调用另一个generator。由于asyncio.sleep()也是一个coroutine，所以线程不会等待asyncio.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()返回时，线程就可以从yield from拿到返回值（此处是None），然后接着执行下一行语句。</p>
<p>把asyncio.sleep(1)看成是一个耗时1秒的IO操作，在此期间，主线程并未等待，而是去执行EventLoop中其他可以执行的coroutine了，因此可以实现并发执行。</p>
<p><strong>小结</strong></p>
<p>asyncio提供了完善的异步IO支持；</p>
<p>异步操作需要在coroutine中通过yield from完成；</p>
<p>多个coroutine可以封装成一组Task然后并发执行。</p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>为了简化并更好地标识异步IO，从Python 3.5开始引入了新的语法async和await，可以让coroutine的代码更简洁易读。</p>
<ol>
<li>把@asyncio.coroutine替换为async；</li>
<li>把yield from替换为await。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># @asyncio.coroutine</span><br><span class="line"># def hello():</span><br><span class="line">#     print(&apos;Hello world! (%s)&apos; % threading.currentThread())</span><br><span class="line">#     yield from asyncio.sleep(1)</span><br><span class="line">#     print(&apos;Hello again! (%s)&apos; % threading.currentThread())</span><br><span class="line"></span><br><span class="line">async def hello():</span><br><span class="line">    print(&quot;Hello world!&quot;)</span><br><span class="line">    r = await asyncio.sleep(1)</span><br><span class="line">    print(&quot;Hello again!&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [hello(), hello()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>
<h3 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h3><p>asyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把asyncio用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发支持。</p>
<p>asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">from aiohttp import web</span><br><span class="line"></span><br><span class="line">async def index(request):</span><br><span class="line">    await asyncio.sleep(0.5)</span><br><span class="line">    return web.Response(body=b&apos;&lt;h1&gt;Index&lt;/h1&gt;&apos;)</span><br><span class="line"></span><br><span class="line">async def hello(request):</span><br><span class="line">    await asyncio.sleep(0.5)</span><br><span class="line">    text = &apos;&lt;h1&gt;hello, %s!&lt;/h1&gt;&apos; % request.match_info[&apos;name&apos;]</span><br><span class="line">    return web.Response(body=text.encode(&apos;utf-8&apos;))</span><br><span class="line"></span><br><span class="line">async def init(loop):</span><br><span class="line">    app = web.Application(loop=loop)</span><br><span class="line">    app.router.add_route(&apos;GET&apos;, &apos;/&apos;, index)</span><br><span class="line">    app.router.add_route(&apos;GET&apos;, &apos;/hello/&#123;name&#125;&apos;, hello)</span><br><span class="line">    srv = await loop.create_server(app.make_handler(), &apos;127.0.0.1&apos;, 8000)</span><br><span class="line">    print(&apos;Server started at http://127.0.0.1:8000...&apos;)</span><br><span class="line">    return srv</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(init(loop))</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的模块</title>
    <url>/2020/09/13/python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>编写模块有很多种方法，其中最简单的一种便是创建一个包含函数与变量、以 .py 为后缀的文件。</p>
<p>另一种方法是使用撰写 Python 解释器本身的本地语言来编写模块。举例来说，你可以使用 C 语言来撰写 Python 模块，并且在编译后，你可以通过标准 Python 解释器在你的 Python 代码中使用它们。</p>
<p>一个模块可以被其它程序导入并运用其功能。我们在使用 Python 标准库的功能时也同样如此。首先，我们要了解如何使用标准库模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">print(&apos;The command line arguments are:&apos;)</span><br><span class="line">for i in sys.argv:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">print(&apos;\n\nThe PYTHONPATH is&apos;, sys.path, &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">$ python module_using_sys.py we are arguments</span><br><span class="line">The command line arguments are:</span><br><span class="line">module_using_sys.py</span><br><span class="line">we</span><br><span class="line">are</span><br><span class="line">arguments</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The PYTHONPATH is [&apos;/tmp/py&apos;,</span><br><span class="line"># many entries here, not shown here</span><br><span class="line">&apos;/Library/Python/2.7/site-packages&apos;,</span><br><span class="line">&apos;/usr/local/lib/python2.7/site-packages&apos;]</span><br></pre></td></tr></table></figure>
<p>首先，我们通过 import 语句导入 sys 模块。基本上，这句代码将转化为我们告诉 Python 我们希望使用这一模块。sys 模块包含了与 Python 解释器及其环境相关的功能，也就是所谓的系统功能（system）。</p>
<p>当 Python 运行 import sys 这一语句时，它会开始寻找 sys 模块。在这一案例中，由于其是一个内置模块，因此 Python 知道应该在哪里找到它。</p>
<p>如果它不是一个已编译好的模块，即用 Python 编写的模块，那么 Python 解释器将从它的 sys.path 变量所提供的目录中进行搜索。如果找到了对应模块，则该模块中的语句将在开始运行，并能够为你所使用。在这里需要注意的是，初始化工作只需在我们第一次导入模块时完成。</p>
<p>sys 模块中的 argv 变量通过使用点号予以指明，也就是 sys.argv 这样的形式。它清晰地表明了这一名称是 sys 模块的一部分。这一处理方式的另一个优点是这个名称不会与你程序中的其它任何一个 argv 变量冲突。</p>
<p>sys.argv 变量是一系列字符串的列表（List）（列表将在后面的章节予以详细解释）。具体而言，sys.argv 包含了命令行参数（Command Line Arguments）这一列表，也就是使用命令行传递给你的程序的参数。</p>
<p>如果你正在使用一款 IDE 来编写并运行这些程序，请在程序菜单中寻找相关指定命令行参数的选项。</p>
<p>在这里，当我们运行 python module_using_sys.py we are arguments 时，我们通过 python 命令来运行 module_using_sys.py 模块，后面的内容则是传递给程序的参数。 Python 将命令行参数存储在 sys.argv 变量中供我们使用。</p>
<p>在这里要记住的是，运行的脚本名称在 sys.argv 的列表中总会位列第一。因此，在这一案例中我们将会有如下对应关系：’module_using_sys.py’ 对应 sys.argv[0]，’we’ 对应 sys.argv[1]，’are’ 对应 sys.argv[2]，’arguments’ 对应 sys.argv[3]。要注意到 Python 从 0 开始计数，而不是 1。</p>
<p>sys.path 内包含了导入模块的字典名称列表。你能观察到 sys.path 的第一段字符串是空的——这一空字符串代表当前目录也是 sys.path 的一部分，它与 PYTHONPATH 环境变量等同。这意味着你可以直接导入位于当前目录的模块。否则，你必须将你的模块放置在 sys.path 内所列出的目录中。</p>
<p>另外要注意的是当前目录指的是程序启动的目录。你可以通过运行 import os; print(os.getcwd()) 来查看你的程序目前所处在的目录。</p>
<h2 id="按字节码编译的-pyc-文件"><a href="#按字节码编译的-pyc-文件" class="headerlink" title="按字节码编译的 .pyc 文件"></a>按字节码编译的 .pyc 文件</h2><p>导入一个模块是一件代价高昂的事情，因此 Python 引入了一些技巧使其能够更快速的完成。其中一种方式便是创建按字节码编译的（Byte-Compiled）文件，这一文件以 .pyc 为其扩展名，是将 Python 转换成中间形式的文件（还记得《介绍》一章中介绍的 Python 是如何工作的吗？）。这一 .pyc 文件在你下一次从其它不同的程序导入模块时非常有用——它将更加快速，因为导入模块时所需要的一部分处理工作已经完成了。同时，这些按字节码编译的文件是独立于运行平台的。</p>
<p>注意：这些 .pyc 文件通常会创建在与对应的 .py 文件所处的目录中。如果 Python 没有相应的权限对这一目录进行写入文件的操作，那么 .pyc 文件将不会被创建。</p>
<h2 id="from-import-语句"><a href="#from-import-语句" class="headerlink" title="from..import 语句"></a>from..import 语句</h2><p>如果你希望直接将 argv 变量导入你的程序（为了避免每次都要输入 sys.），那么你可以通过使用 from sys import argv 语句来实现这一点。</p>
<p>警告：一般来说，你应该尽量避免使用 from…import 语句，而去使用 import 语句。这是为了避免在你的程序中出现名称冲突，同时也为了使程序更加易读。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from math import sqrt</span><br><span class="line">print(&quot;Square root of 16 is&quot;, sqrt(16))</span><br></pre></td></tr></table></figure>
<h2 id="模块的-name"><a href="#模块的-name" class="headerlink" title="模块的 name"></a>模块的 <strong>name</strong></h2><p>每个模块都有一个名称，而模块中的语句可以找到它们所处的模块的名称。这对于确定模块是独立运行的还是被导入进来运行的这一特定目的来说大为有用。正如先前所提到的，当模块第一次被导入时，它所包含的代码将被执行。我们可以通过这一特性来使模块以不同的方式运行，这取决于它是为自己所用还是从其它从的模块中导入而来。这可以通过使用模块的 <strong>name</strong> 属性来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print(&apos;This program is being run by itself&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;I am being imported from another module&apos;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">$ python module_using_name.py</span><br><span class="line">This program is being run by itself</span><br><span class="line"></span><br><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import module_using_name</span><br><span class="line">I am being imported from another module</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>每一个 Python 模块都定义了它的 <strong>name</strong> 属性。如果它与 <strong>main</strong> 属性相同则代表这一模块是由用户独立运行的，因此我们便可以采取适当的行动。</p>
<h2 id="编写你自己的模块"><a href="#编写你自己的模块" class="headerlink" title="编写你自己的模块"></a>编写你自己的模块</h2><p>编写你自己的模块很简单，这其实就是你一直在做的事情！这是因为每一个 Python 程序同时也是一个模块。你只需要保证它以 .py 为扩展名即可。下面的案例会作出清晰的解释。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def say_hi():</span><br><span class="line">    print(&apos;Hi, this is mymodule speaking.&apos;)</span><br><span class="line"></span><br><span class="line">__version__ = &apos;0.1&apos;</span><br></pre></td></tr></table></figure>
<p>上方所呈现的就是一个简单的模块。正如你所看见的，与我们一般所使用的 Python 的程序相比其实并没有什么特殊的区别。我们接下来将看到如何在其它 Python 程序中使用这一模块。</p>
<p>要记住该模块应该放置于与其它我们即将导入这一模块的程序相同的目录下，或者是放置在 sys.path 所列出的其中一个目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import mymodule</span><br><span class="line"></span><br><span class="line">mymodule.say_hi()</span><br><span class="line">print(&apos;Version&apos;, mymodule.__version__)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">$ python mymodule_demo.py</span><br><span class="line">Hi, this is mymodule speaking.</span><br><span class="line">Version 0.1</span><br></pre></td></tr></table></figure>
<p>你会注意到我们使用相同的点符来访问模块中的成员。Python 很好地重用了其中的符号，这充满了“Pythonic”式的气息，这使得我们可以不必学习新的方式来完成同样的事情。</p>
<p>下面是一个使用 from…import 语法的范本（保存为 mymodule_demo2.py）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from mymodule import say_hi, __version__</span><br><span class="line"></span><br><span class="line">say_hi()</span><br><span class="line">print(&apos;Version&apos;, __version__)</span><br></pre></td></tr></table></figure>
<p>mymodule_demo2.py 所输出的内容与 mymodule_demo.py 所输出的内容是一样的。</p>
<p>在这里需要注意的是，如果导入到 mymodule 中的模块里已经存在了 <strong>version</strong> 这一名称，那将产生冲突。这可能是因为每个模块通常都会使用这一名称来声明它们各自的版本号。因此，我们大都推荐最好去使用 import 语句，尽管这会使你的程序变得稍微长一些。</p>
<p>你还可以使用：</p>
<p>from mymodule import *<br>这将导入诸如 say_hi 等所有公共名称，但不会导入 <strong>version</strong> 名称，因为后者以双下划线开头。</p>
<h2 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir 函数"></a>dir 函数</h2><p>内置的 dir() 函数能够返回由对象所定义的名称列表。 如果这一对象是一个模块，则该列表会包括函数内所定义的函数、类与变量。</p>
<p>该函数接受参数。 如果参数是模块名称，函数将返回这一指定模块的名称列表。 如果没有提供参数，函数将返回当前模块的名称列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line"></span><br><span class="line"># 给出 sys 模块中的属性名称</span><br><span class="line">&gt;&gt;&gt; dir(sys)</span><br><span class="line">[&apos;__displayhook__&apos;, &apos;__doc__&apos;,</span><br><span class="line">&apos;argv&apos;, &apos;builtin_module_names&apos;,</span><br><span class="line">&apos;version&apos;, &apos;version_info&apos;]</span><br><span class="line"># 此处只展示部分条目</span><br><span class="line"></span><br><span class="line"># 给出当前模块的属性名称</span><br><span class="line">&gt;&gt;&gt; dir()</span><br><span class="line">[&apos;__builtins__&apos;, &apos;__doc__&apos;,</span><br><span class="line">&apos;__name__&apos;, &apos;__package__&apos;,&apos;sys&apos;]</span><br><span class="line"></span><br><span class="line"># 创建一个新的变量 &apos;a&apos;</span><br><span class="line">&gt;&gt;&gt; a = 5</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dir()</span><br><span class="line">[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;a&apos;]</span><br><span class="line"></span><br><span class="line"># 删除或移除一个名称</span><br><span class="line">&gt;&gt;&gt; del a</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dir()</span><br><span class="line">[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;__package__&apos;]</span><br></pre></td></tr></table></figure>
<p>首先我们看到的是 dir 在被导入的 sys 模块上的用法。我们能够看见它所包含的一个巨大的属性列表。</p>
<p>随后，我们以不传递参数的形式使用 dir 函数。在默认情况下，它将返回当前模块的属性列表。要注意到被导入模块的列表也会是这一列表的一部分。</p>
<p>给了观察 dir 函数的操作，我们定义了一个新的变量 a 并为其赋予了一个值，然后在检查 dir 返回的结果，我们就能发现，同名列表中出现了一个新的值。我们通过 del 语句移除了一个变量或是属性，这一变化再次反映在 dir 函数所处的内容中。</p>
<p>关于 del 的一个小小提示——这一语句用于删除一个变量或名称，当这一语句运行后，在本例中即 del a，你便不再能访问变量 a——它将如同从未存在过一般。</p>
<p>要注意到 dir() 函数能对任何对象工作。例如运行 dir(str) 可以访问 str（String，字符串）类的属性。</p>
<p>同时，还有一个 vars() 函数也可以返回给你这些值的属性，但只是可能，它并不能针对所有类都能正常工作。</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>现在，你必须开始遵守用以组织你的程序的层次结构。变量通常位于函数内部，函数与全局变量通常位于模块内部。如果你希望组织起这些模块的话，应该怎么办？这便是包（Packages）应当登场的时刻。</p>
<p>包是指一个包含模块与一个特殊的 <strong>init</strong>.py 文件的文件夹，后者向 Python 表明这一文件夹是特别的，因为其包含了 Python 模块。</p>
<p>让我们这样设想：你想创建一个名为“world”的包，其中还包含着 “asia”、“africa”等其它子包，同时这些子包都包含了诸如“india”、 “madagascar”等模块。</p>
<p>下面是你会构建出的文件夹的结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;some folder present in the sys.path&gt;/</span><br><span class="line">    - world/</span><br><span class="line">        - __init__.py</span><br><span class="line">        - asia/</span><br><span class="line">            - __init__.py</span><br><span class="line">            - india/</span><br><span class="line">                - __init__.py</span><br><span class="line">                - foo.py</span><br><span class="line">        - africa/</span><br><span class="line">            - __init__.py</span><br><span class="line">            - madagascar/</span><br><span class="line">                - __init__.py</span><br><span class="line">                - bar.py</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如同函数是程序中的可重用部分那般，模块是一种可重用的程序。包是用以组织模块的另一种层次结构。Python 所附带的标准库就是这样一组有关包与模块的例子。</p>
<p>我们已经了解了如何使用这些模块并创建你自己的模块。</p>
<p>接下来，我们将学习一些有趣的概念，它们被称作数据结构。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的进程</title>
    <url>/2021/03/15/python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="1-多进程-vs多任务"><a href="#1-多进程-vs多任务" class="headerlink" title="1. 多进程 vs多任务"></a>1. 多进程 vs多任务</h3><p>多任务：就是操作系统可以同时运行多个任务<br>多进程：正在运行着的代码，就成为进程。多个正在运行的代码。</p>
<h3 id="2-fork（）"><a href="#2-fork（）" class="headerlink" title="2. fork（）"></a>2. fork（）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 注意，fork函数，只在Unix/Linux/Mac上运行，windows不可以</span><br><span class="line">pid = os.fork()</span><br><span class="line"></span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&apos;哈哈1&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;哈哈2&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>程序执行到os.fork()时，操作系统会创建一个新的进程（子进程），然后复制父进程的所有信息到子进程中</p>
</li>
<li><p>然后父进程和子进程都会从fork()函数中得到一个返回值，在子进程中这个值一定是0，而父进程中是子进程的 id号</p>
</li>
</ul>
<p>普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
<p>子进程永远返回0，而父进程返回子进程的ID。</p>
<p>这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p>
<h3 id="多进程修改全局变量"><a href="#多进程修改全局变量" class="headerlink" title="多进程修改全局变量"></a>多进程修改全局变量</h3><p>多进程中，每个进程中所有数据（包括全局变量）都各有拥有一份，互不影响<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid = os.fork()</span><br><span class="line">num = 0</span><br><span class="line"></span><br><span class="line">if pid == 0:</span><br><span class="line">    num += 1</span><br><span class="line">    print(&apos;哈哈1---num=%d&apos; % num)</span><br><span class="line">else:</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    num += 1</span><br><span class="line">    print(&apos;哈哈2---num=%d&apos; % num)</span><br></pre></td></tr></table></figure></p>
<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。<br>join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line"># 子进程要执行的代码</span><br><span class="line">def run_proc(name, age, **kwargs):</span><br><span class="line">    for i in range(10):</span><br><span class="line">        print(&apos;子进程运行中，name= %s,age=%d ,pid=%d...&apos; % (name, age,os.getpid()))</span><br><span class="line">        print(kwargs)</span><br><span class="line">        sleep(0.5)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    print(&apos;父进程 %d.&apos; % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(&apos;test&apos;,18), kwargs=&#123;&quot;m&quot;:20&#125;)</span><br><span class="line">    print(&apos;子进程将要执行&apos;)</span><br><span class="line">    p.start()</span><br><span class="line">    sleep(1)</span><br><span class="line">    p.terminate()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&apos;子进程已结束&apos;)</span><br></pre></td></tr></table></figure>
<p><strong>Process语法结构如下：</strong></p>
<p>Process([group [, target [, name [, args [, kwargs]]]]])</p>
<ul>
<li>target：表示这个进程实例所调用对象；</li>
<li>args：表示调用对象的位置参数元组；</li>
<li>kwargs：表示调用对象的关键字参数字典；</li>
<li>name：为当前进程实例的别名；</li>
<li>group：大多数情况下用不到；</li>
</ul>
<p>Process类常用方法：</p>
<ul>
<li>is_alive()：判断进程实例是否还在执行；</li>
<li>join([timeout])：是否等待进程实例执行结束，或等待多少秒；</li>
<li>start()：启动进程实例（创建子进程）；</li>
<li>run()：如果没有给定target参数，对这个对象调用start()方法时，就将执行对象中的run()方法；</li>
<li>terminate()：不管任务是否完成，立即终止；</li>
</ul>
<p>Process类常用属性：</p>
<ul>
<li>name：当前进程实例别名，默认为Process-N，N为从1开始递增的整数；</li>
<li>pid：当前进程实例的PID值；</li>
</ul>
<h4 id="进程的创建-Process子类"><a href="#进程的创建-Process子类" class="headerlink" title="进程的创建-Process子类"></a>进程的创建-Process子类</h4><p>创建新的进程还能够使用类的方式，可以自定义一个类，继承Process类，每次实例化这个类的时候，就等同于实例化一个进程对象，请看下面的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">#继承Process类</span><br><span class="line">class Process_Class(Process):</span><br><span class="line">    #因为Process类本身也有__init__方法，这个子类相当于重写了这个方法，</span><br><span class="line">    #但这样就会带来一个问题，我们并没有完全的初始化一个Process类，所以就不能使用从这个类继承的一些方法和属性，</span><br><span class="line">    #最好的方法就是将继承类本身传递给Process.__init__方法，完成这些初始化操作</span><br><span class="line">    def __init__(self,interval):</span><br><span class="line">        Process.__init__(self)</span><br><span class="line">        self.interval = interval</span><br><span class="line"></span><br><span class="line">    #重写了Process类的run()方法</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;子进程(%s) 开始执行，父进程为（%s）&quot;%(os.getpid(),os.getppid()))</span><br><span class="line">        t_start = time.time()</span><br><span class="line">        time.sleep(self.interval)</span><br><span class="line">        t_stop = time.time()</span><br><span class="line">        print(&quot;(%s)执行结束，耗时%0.2f秒&quot;%(os.getpid(),t_stop-t_start))</span><br><span class="line"></span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(&quot;当前程序进程(%s)&quot;%os.getpid())        </span><br><span class="line">    p1 = Process_Class(2)</span><br><span class="line">    #对一个不包含target属性的Process类执行start()方法，就会运行这个类中的run()方法，所以这里会执行p1.run()</span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(&quot;(%s)执行结束，耗时%0.2f&quot;%(os.getpid(),t_stop-t_start))</span><br></pre></td></tr></table></figure>
<h4 id="进程池Pool"><a href="#进程池Pool" class="headerlink" title="进程池Pool"></a>进程池Pool</h4><p>初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import os</span><br><span class="line">import random</span><br><span class="line">from multiprocessing.pool import Pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def worker(msg):</span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(&quot;%s开始执行,进程号为%d&quot; % (msg, os.getpid()))</span><br><span class="line">    # random.random()随机生成0~1之间的浮点数</span><br><span class="line">    time.sleep(random.random() * 2)</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(msg, &quot;执行完毕，耗时%0.2f&quot; % (t_stop - t_start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">po = Pool(3)</span><br><span class="line">for i in range(0, 10):</span><br><span class="line">    # Pool.apply_async(要调用的目标,(传递给目标的参数元祖,))</span><br><span class="line">    # 每次循环将会用空闲出来的子进程去调用目标</span><br><span class="line">    # po.apply_async(worker, (i,))</span><br><span class="line">    po.apply(worker, (i,))</span><br><span class="line"></span><br><span class="line">print(&quot;----start----&quot;)</span><br><span class="line">po.close()  # 关闭进程池，关闭后po不再接收新的请求</span><br><span class="line">po.join()  # 等待po中所有子进程执行完成，必须放在close语句之后</span><br><span class="line">print(&quot;-----end-----&quot;)</span><br></pre></td></tr></table></figure>
<p>multiprocessing.Pool常用函数解析：</p>
<p>apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；</p>
<p>apply(func[, args[, kwds]])：使用阻塞方式调用func</p>
<p>close()：关闭Pool，使其不再接受新的任务；</p>
<p>terminate()：不管任务是否完成，立即终止；</p>
<p>join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；</p>
<h4 id="进程间通信-Queue"><a href="#进程间通信-Queue" class="headerlink" title="进程间通信-Queue"></a>进程间通信-Queue</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">from multiprocessing import Queue</span><br><span class="line">q=Queue(3) #初始化一个Queue对象，最多可接收三条put消息</span><br><span class="line">q.put(&quot;消息1&quot;) </span><br><span class="line">q.put(&quot;消息2&quot;)</span><br><span class="line">print(q.full())  #False</span><br><span class="line">q.put(&quot;消息3&quot;)</span><br><span class="line">print(q.full()) #True</span><br><span class="line"></span><br><span class="line">#因为消息列队已满下面的try都会抛出异常，第一个try会等待2秒后再抛出异常，第二个Try会立刻抛出异常</span><br><span class="line">try:</span><br><span class="line">    q.put(&quot;消息4&quot;,True,2)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;消息列队已满，现有消息数量:%s&quot;%q.qsize())</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    q.put_nowait(&quot;消息4&quot;)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;消息列队已满，现有消息数量:%s&quot;%q.qsize())</span><br><span class="line"></span><br><span class="line">#推荐的方式，先判断消息列队是否已满，再写入</span><br><span class="line">if not q.full():</span><br><span class="line">    q.put_nowait(&quot;消息4&quot;)</span><br><span class="line"></span><br><span class="line">#读取消息时，先判断消息列队是否为空，再读取</span><br><span class="line">if not q.empty():</span><br><span class="line">    for i in range(q.qsize()):</span><br><span class="line">        print(q.get_nowait())</span><br></pre></td></tr></table></figure>
<p>初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Queue.qsize()：返回当前队列包含的消息数量；</span><br><span class="line"></span><br><span class="line">Queue.empty()：如果队列为空，返回True，反之False ；</span><br><span class="line"></span><br><span class="line">Queue.full()：如果队列满了，返回True,反之False；</span><br><span class="line"></span><br><span class="line">Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；</span><br></pre></td></tr></table></figure></p>
<p>1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常；</p>
<p>2）如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Queue.get_nowait()：相当Queue.get(False)；</span><br><span class="line"></span><br><span class="line">Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True；</span><br></pre></td></tr></table></figure></p>
<p>1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常；</p>
<p>2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Queue.put_nowait(item)：相当Queue.put(item, False)；</span><br></pre></td></tr></table></figure></p>
<p><strong>生产者消费者</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process, Queue</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line"># 写数据进程执行的代码:</span><br><span class="line">def write(q):</span><br><span class="line">    for value in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]:</span><br><span class="line">        print &apos;Put %s to queue...&apos; % value</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"># 读数据进程执行的代码:</span><br><span class="line">def read(q):</span><br><span class="line">    while True:</span><br><span class="line">        if not q.empty():</span><br><span class="line">            value = q.get(True)</span><br><span class="line">            print &apos;Get %s from queue.&apos; % value</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    # 父进程创建Queue，并传给各个子进程：</span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    # 启动子进程pw，写入:</span><br><span class="line">    pw.start()    </span><br><span class="line">    # 等待pw结束:</span><br><span class="line">    pw.join()</span><br><span class="line">    # 启动子进程pr，读取:</span><br><span class="line">    pr.start()</span><br><span class="line">    pr.join()</span><br><span class="line">    # pr进程里是死循环，无法等待其结束，只能强行终止:</span><br><span class="line">    print &apos;&apos;</span><br><span class="line">    print &apos;所有数据都写入并且读完&apos;</span><br></pre></td></tr></table></figure></p>
<h4 id="进程池中的Queue"><a href="#进程池中的Queue" class="headerlink" title="进程池中的Queue"></a>进程池中的Queue</h4><p>如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息：</p>
<p>RuntimeError: Queue objects should only be shared between processes through inheritance</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">#修改import中的Queue为Manager</span><br><span class="line">from multiprocessing import Manager,Pool</span><br><span class="line">import os,time,random</span><br><span class="line"></span><br><span class="line">def reader(q):</span><br><span class="line">    print(&quot;reader启动(%s),父进程为(%s)&quot;%(os.getpid(),os.getppid()))</span><br><span class="line">    for i in range(q.qsize()):</span><br><span class="line">        print(&quot;reader从Queue获取到消息：%s&quot;%q.get(True))</span><br><span class="line"></span><br><span class="line">def writer(q):</span><br><span class="line">    print(&quot;writer启动(%s),父进程为(%s)&quot;%(os.getpid(),os.getppid()))</span><br><span class="line">    for i in &quot;dongGe&quot;:</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">    print(&quot;(%s) start&quot;%os.getpid())</span><br><span class="line">    q=Manager().Queue() #使用Manager中的Queue来初始化</span><br><span class="line">    po=Pool()</span><br><span class="line">    #使用阻塞模式创建进程，这样就不需要在reader中使用死循环了，可以让writer完全执行完成后，再用reader去读取</span><br><span class="line">    po.apply(writer,(q,))</span><br><span class="line">    po.apply(reader,(q,))</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    print(&quot;(%s) End&quot;%os.getpid())</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python服务器模型</title>
    <url>/2021/03/10/python%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="单进程服务器"><a href="#单进程服务器" class="headerlink" title="单进程服务器"></a>单进程服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">address = (&quot;&quot;, 8000)</span><br><span class="line">server_sock.bind(address)</span><br><span class="line">server_sock.listen(128)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    print(&apos;-----主进程，，等待新客户端的到来------&apos;)</span><br><span class="line">    client_sock, client_addr = server_sock.accept()</span><br><span class="line">    print(&quot;客户端%s:%s进行了连接!&quot; % client_addr)</span><br><span class="line">    while True:</span><br><span class="line">        recv_data = client_sock.recv(1024)</span><br><span class="line">        if len(recv_data) &gt; 0:</span><br><span class="line">            print(&quot;接收到的数据为：&quot;, recv_data.decode())</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;[%s]客户端已经关闭&apos; % str(client_addr))</span><br><span class="line">            break</span><br><span class="line">    client_sock.close()</span><br><span class="line">server_sock.close()</span><br></pre></td></tr></table></figure>
<ul>
<li>同一时刻只能为一个客户进行服务，不能同时为多个客户服务</li>
<li>类似于找一个“明星”签字一样，客户需要耐心等待才可以获取到服务</li>
<li>当服务器为一个客户端服务时，而另外的客户端发起了connect，只要服务器listen的队列有空闲的位置，就会为这个新客户端进行连接，并且客户端可以发送数据，但当服务器为这个新客户端服务时，可能一次性把所有数据接收完毕</li>
<li>当recv接收数据时，返回值为空，即没有返回数据，那么意味着客户端已经调用了close关闭了；因此服务器通过判断recv接收数据是否为空 来判断客户端是否已经下线</li>
</ul>
<h3 id="多进程服务器"><a href="#多进程服务器" class="headerlink" title="多进程服务器"></a>多进程服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import socket</span><br><span class="line">from multiprocessing import Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def handle_client(client_sock, client_addr):</span><br><span class="line">    while True:</span><br><span class="line">        recv_data = client_sock.recv(1024)</span><br><span class="line">        if len(recv_data) &gt; 0:</span><br><span class="line">            print(&apos;recv[%s]:%s&apos; % (str(client_addr), recv_data.decode()))</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;[%s]客户端已经关闭&apos; % str(client_addr))</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    client_sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">    address = (&quot;&quot;, 8000)</span><br><span class="line">    server_sock.bind(address)</span><br><span class="line">    server_sock.listen(128)</span><br><span class="line">    while True:</span><br><span class="line">        print(&apos;-----主进程，，等待新客户端的到来------&apos;)</span><br><span class="line">        client_sock, client_addr = server_sock.accept()</span><br><span class="line">        print(&apos;-----主进程，，接下来创建一个新的进程负责数据处理[%s]-----&apos; % str(client_addr))</span><br><span class="line">        process = Process(target=handle_client, args=(client_sock, client_addr))</span><br><span class="line">        process.start()</span><br><span class="line">        # 因为已经向子进程中copy了一份（引用），并且父进程中这个套接字也没有用处了</span><br><span class="line">        # 所以关闭</span><br><span class="line">        client_sock.close()</span><br><span class="line">        # 当为所有的客户端服务完之后再进行关闭，表示不再接收新的客户端的链接</span><br><span class="line">    server_sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<ul>
<li>通过为每个客户端创建一个进程的方式，能够同时为多个客户端进行服务</li>
<li>当客户端不是特别多的时候，这种方式还行，如果有几百上千个，就不可取了，因为每次创建进程等过程需要好较大的资源</li>
</ul>
<h3 id="多线程服务器"><a href="#多线程服务器" class="headerlink" title="多线程服务器"></a>多线程服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def handle_client(client_sock, client_addr):</span><br><span class="line">    while True:</span><br><span class="line">        recv_data = client_sock.recv(1024)</span><br><span class="line">        if len(recv_data) &gt; 0:</span><br><span class="line">            print(&apos;recv[%s]:%s&apos; % (str(client_addr), recv_data.decode()))</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;[%s]客户端已经关闭&apos; % str(client_addr))</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    client_sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">    address = (&quot;&quot;, 8001)</span><br><span class="line">    server_sock.bind(address)</span><br><span class="line">    server_sock.listen(128)</span><br><span class="line">    while True:</span><br><span class="line">        print(&apos;-----主线程，，等待新客户端的到来------&apos;)</span><br><span class="line">        client_sock, client_addr = server_sock.accept()</span><br><span class="line">        print(&apos;-----主线程，，接下来创建一个新的线程负责数据处理[%s]-----&apos; % str(client_addr))</span><br><span class="line">        thread = Thread(target=handle_client, args=(client_sock, client_addr))</span><br><span class="line">        thread.start()</span><br><span class="line">        # 因为线程中共享这个套接字，如果关闭了会导致这个套接字不可用，</span><br><span class="line">        # 但是此时在线程中这个套接字可能还在收数据，因此不能关闭</span><br><span class="line">        # client_sock.close()</span><br><span class="line">    server_sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="单进程服务器-非堵塞模式"><a href="#单进程服务器-非堵塞模式" class="headerlink" title="单进程服务器-非堵塞模式"></a>单进程服务器-非堵塞模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># 用来存储所有的新链接的客户端</span><br><span class="line">client_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">    address = (&quot;&quot;, 8000)</span><br><span class="line">    server_sock.bind(address)</span><br><span class="line">    server_sock.listen(128)</span><br><span class="line"></span><br><span class="line">    # 将套接字设置为非堵塞</span><br><span class="line">    # 设置为非堵塞后，如果accept时，恰巧没有客户端connect，那么accept会</span><br><span class="line">    # 产生一个异常，所以需要try来进行处理</span><br><span class="line">    server_sock.setblocking(False)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            client_info = server_sock.accept()</span><br><span class="line">        except BlockingIOError:</span><br><span class="line">            pass</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;一个新的客户端到来%s：&quot; % str(client_info))</span><br><span class="line">            # 将套接字设置为非堵塞</span><br><span class="line">            client_info[0].setblocking(False)</span><br><span class="line">            client_list.append(client_info)</span><br><span class="line"></span><br><span class="line">        # 用来存储需要删除的客户端信息</span><br><span class="line">        need_del_client_info_list = []</span><br><span class="line"></span><br><span class="line">        for client_socket, client_addr in client_list:</span><br><span class="line">            try:</span><br><span class="line">                recv_data = client_socket.recv(1024)</span><br><span class="line">                if len(recv_data) &gt; 0:</span><br><span class="line">                    print(&apos;recv[%s]:%s&apos; % (str(client_addr), recv_data.decode()))</span><br><span class="line">                else:</span><br><span class="line">                    print(&apos;[%s]客户端已经关闭&apos; % str(client_addr))</span><br><span class="line">                    client_socket.close()</span><br><span class="line">                    need_del_client_info_list.append((client_socket, client_addr))</span><br><span class="line">            except BlockingIOError:</span><br><span class="line">                pass</span><br><span class="line"></span><br><span class="line">        for client in need_del_client_info_list:</span><br><span class="line">            client_list.remove(client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="select版-TCP服务器"><a href="#select版-TCP服务器" class="headerlink" title="select版-TCP服务器"></a>select版-TCP服务器</h3><p>在多路复用的模型中，比较常用的有select模型和epoll模型。这两个都是系统接口，由操作系统提供。当然，Python的select模块进行了更高级的封装。</p>
<p>网络通信被Unix系统抽象为文件的读写，通常是一个设备，由设备驱动程序提供，驱动可以知道自身的数据是否可用。支持阻塞操作的设备驱动通常会实现一组自身的等待队列，如读/写等待队列用于支持上层(用户层)所需的block或non-block操作。设备的文件的资源如果可用（可读或者可写）则会通知进程，反之则会让进程睡眠，等到数据到来可用的时候，再唤醒进程。</p>
<p>这些设备的文件描述符被放在一个数组中，然后select调用的时候遍历这个数组，如果对于的文件描述符可读则会返回改文件描述符。当遍历结束之后，如果仍然没有一个可用设备文件描述符，select让用户进程则会睡眠，直到等待资源可用的时候在唤醒，遍历之前那个监视的数组。每次遍历都是依次进行判断的。</p>
<p><strong>select 回显服务器</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import select</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.bind((&apos;&apos;, 7788))</span><br><span class="line">server.listen(5)</span><br><span class="line"></span><br><span class="line">inputs = [server, sys.stdin]</span><br><span class="line"></span><br><span class="line">running = True</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    # 调用 select 函数，阻塞等待</span><br><span class="line">    readable, writeable, exceptional = select.select(inputs, [], [])</span><br><span class="line"></span><br><span class="line">    # 数据抵达，循环</span><br><span class="line">    for sock in readable:</span><br><span class="line">        # 监听到有新的连接</span><br><span class="line">        if sock == server:</span><br><span class="line">            conn, addr = server.accept()</span><br><span class="line">            # select 监听的socket</span><br><span class="line">            inputs.append(conn)</span><br><span class="line">        # 监听到键盘有输入</span><br><span class="line">        elif sock == sys.stdin:</span><br><span class="line">            cmd = sys.stdin.readline()</span><br><span class="line">            running = False</span><br><span class="line">            break</span><br><span class="line">        # 有数据到达</span><br><span class="line">        else:</span><br><span class="line">            # 读取客户端连接发送的数据</span><br><span class="line">            data = sock.recv(1024)</span><br><span class="line">            if data:</span><br><span class="line">                sock.send(data)</span><br><span class="line">            else:</span><br><span class="line">                # 移除select监听的socket</span><br><span class="line">                inputs.remove(sock)</span><br><span class="line">                sock.close()</span><br><span class="line">        # 如果检测到用户输入敲击键盘，那么就退出</span><br><span class="line">    if not running:</span><br><span class="line">        break</span><br><span class="line">server.close()</span><br></pre></td></tr></table></figure></p>
<p>另外一个服务器（包含writeList）:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line">import Queue</span><br><span class="line"></span><br><span class="line">SERVER_IP = (&apos;&apos;, 9999)</span><br><span class="line"></span><br><span class="line"># 保存客户端发送过来的消息,将消息放入队列中</span><br><span class="line">message_queue = &#123;&#125;</span><br><span class="line">input_list = []</span><br><span class="line">output_list = []</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    server.bind(SERVER_IP)</span><br><span class="line">    server.listen(8)</span><br><span class="line">    # 设置为非阻塞</span><br><span class="line">    server.setblocking(False)</span><br><span class="line"></span><br><span class="line">    # 初始化将服务端加入监听列表</span><br><span class="line">    input_list.append(server)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        # 开始 select 监听,对input_list中的服务端server进行监听</span><br><span class="line">        stdinput, stdoutput, stderr = select(input_list, output_list, input_list)</span><br><span class="line"></span><br><span class="line">        for obj in stdinput:</span><br><span class="line">            # 判断当前触发的是不是服务端对象, 当触发的对象是服务端对象时,说明有新客户端连接进来了</span><br><span class="line">            if obj == server:</span><br><span class="line">                # 接收客户端的连接, 获取客户端对象和客户端地址信息</span><br><span class="line">                conn, addr = server.accept()</span><br><span class="line">                print(&quot;Client %s connected! &quot; % str(addr))</span><br><span class="line">                # 将客户端对象也加入到监听的列表中, 当客户端发送消息时 select 将触发</span><br><span class="line">                input_list.append(conn)</span><br><span class="line">                # 为连接的客户端单独创建一个消息队列，用来保存客户端发送的消息</span><br><span class="line">                message_queue[conn] = Queue.Queue()</span><br><span class="line">            else:</span><br><span class="line">                # 由于客户端连接进来时服务端接收客户端连接请求，将客户端加入到了监听列表中(input_list)，客户端发送消息将触发</span><br><span class="line">                # 所以判断是否是客户端对象触发</span><br><span class="line">                try:</span><br><span class="line">                    recv_data = obj.recv(1024)</span><br><span class="line">                    # 客户端未断开</span><br><span class="line">                    if recv_data:</span><br><span class="line">                        print(&quot;received %s from client %s&quot; % (recv_data, str(addr)))</span><br><span class="line">                        # 将收到的消息放入到各客户端的消息队列中</span><br><span class="line">                        message_queue[obj].put(recv_data)</span><br><span class="line"></span><br><span class="line">                        # 将回复操作放到output列表中，让select监听</span><br><span class="line">                        if obj not in output_list:</span><br><span class="line">                            output_list.append(obj)</span><br><span class="line">                except ConnectionResetError:</span><br><span class="line">                    # 客户端断开连接了，将客户端的监听从input列表中移除</span><br><span class="line">                    input_list.remove(obj)</span><br><span class="line">                    # 移除客户端对象的消息队列</span><br><span class="line">                    del message_queue[obj]</span><br><span class="line">                    print(&quot;\n[input] Client %s disconnected&quot; % str(addr))</span><br><span class="line">        # 如果现在没有客户端请求,也没有客户端发送消息时，开始对发送消息列表进行处理，是否需要发送消息</span><br><span class="line">        for sendobj in output_list:</span><br><span class="line">            try:</span><br><span class="line">                # 如果消息队列中有消息,从消息队列中获取要发送的消息</span><br><span class="line">                if not message_queue[sendobj].empty():</span><br><span class="line">                    # 从该客户端对象的消息队列中获取要发送的消息</span><br><span class="line">                    send_data = message_queue[sendobj].get()</span><br><span class="line">                    sendobj.send(send_data)</span><br><span class="line">                else:</span><br><span class="line">                    # 将监听移除等待下一次客户端发送消息</span><br><span class="line">                    output_list.remove(sendobj)</span><br><span class="line"></span><br><span class="line">            except ConnectionResetError:</span><br><span class="line">                # 客户端连接断开了</span><br><span class="line">                del message_queue[sendobj]</span><br><span class="line">                output_list.remove(sendobj)</span><br><span class="line">                print(&quot;\n[output] Client  %s disconnected&quot; % str(addr))</span><br></pre></td></tr></table></figure></p>
<p><strong>总结</strong></p>
<p>优点：select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。<br>缺点：</p>
<p>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p>
<p>一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p>
<p>对socket进行扫描时是依次扫描的，即采用轮询的方法，效率较低。</p>
<p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line"></span><br><span class="line"># 创建套接字</span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"># 设置可以重复使用绑定的信息</span><br><span class="line">s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)</span><br><span class="line"></span><br><span class="line"># 绑定本机信息</span><br><span class="line">s.bind((&quot;&quot;,7788))</span><br><span class="line"></span><br><span class="line"># 变为被动</span><br><span class="line">s.listen(10)</span><br><span class="line"></span><br><span class="line"># 创建一个epoll对象</span><br><span class="line">epoll=select.epoll()</span><br><span class="line"></span><br><span class="line"># 测试，用来打印套接字对应的文件描述符</span><br><span class="line"># print s.fileno()</span><br><span class="line"># print select.EPOLLIN|select.EPOLLET</span><br><span class="line"></span><br><span class="line"># 注册事件到epoll中</span><br><span class="line"># epoll.register(fd[, eventmask])</span><br><span class="line"># 注意，如果fd已经注册过，则会发生异常</span><br><span class="line"># 将创建的套接字添加到epoll的事件监听中</span><br><span class="line">epoll.register(s.fileno(),select.EPOLLIN|select.EPOLLET)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">connections = &#123;&#125;</span><br><span class="line">addresses = &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 循环等待客户端的到来或者对方发送数据</span><br><span class="line">while True:</span><br><span class="line"></span><br><span class="line">    # epoll 进行 fd 扫描的地方 -- 未指定超时时间则为阻塞等待</span><br><span class="line">    epoll_list=epoll.poll()</span><br><span class="line"></span><br><span class="line">    # 对事件进行判断</span><br><span class="line">    for fd,events in epoll_list:</span><br><span class="line"></span><br><span class="line">        # print fd</span><br><span class="line">        # print events</span><br><span class="line"></span><br><span class="line">        # 如果是socket创建的套接字被激活</span><br><span class="line">        if fd == s.fileno():</span><br><span class="line">            conn,addr=s.accept()</span><br><span class="line"></span><br><span class="line">            print(&apos;有新的客户端到来%s&apos;%str(addr))</span><br><span class="line"></span><br><span class="line">            # 将 conn 和 addr 信息分别保存起来</span><br><span class="line">            connections[conn.fileno()] = conn</span><br><span class="line">            addresses[conn.fileno()] = addr</span><br><span class="line"></span><br><span class="line">            # 向 epoll 中注册 连接 socket 的 可读 事件</span><br><span class="line">            epoll.register(conn.fileno(), select.EPOLLIN | select.EPOLLET)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        elif events == select.EPOLLIN:</span><br><span class="line">            # 从激活 fd 上接收</span><br><span class="line">            recvData = connections[fd].recv(1024)</span><br><span class="line"></span><br><span class="line">            if len(recvData)&gt;0:</span><br><span class="line">                print(&apos;recv:%s&apos;%recvData)</span><br><span class="line">            else:</span><br><span class="line">                # 从 epoll 中移除该 连接 fd</span><br><span class="line">                epoll.unregister(fd)</span><br><span class="line"></span><br><span class="line">                # server 侧主动关闭该 连接 fd</span><br><span class="line">                connections[fd].close()</span><br><span class="line"></span><br><span class="line">                print(&quot;%s---offline---&quot;%str(addresses[fd]))</span><br></pre></td></tr></table></figure>
<p>EPOLLIN （可读）<br>EPOLLOUT （可写）<br>EPOLLET （ET模式）<br>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<p>LT模式：当epoll检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll时，会再次响应应用程序并通知此事件。</p>
<p>ET模式：当epoll检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll时，不会再次响应应用程序并通知此事件。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python格式化字符串f-string小结</title>
    <url>/2021/05/07/python%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2f-string%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h3 id="格式化字符串f-string概览"><a href="#格式化字符串f-string概览" class="headerlink" title="格式化字符串f-string概览"></a>格式化字符串f-string概览</h3><p>f-string，亦称为格式化字符串常量（formatted string literals），是Python3.6新引入的一种字符串格式化方法，该方法源于PEP 498 – Literal String Interpolation，主要目的是使格式化字符串的操作更加简便。f-string在形式上是以 f 或 F 修饰符引领的字符串（f’xxx’ 或 F’xxx’），以大括号 {} 标明被替换的字段；f-string在本质上并不是字符串常量，而是一个在运行时运算求值的表达式：</p>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>f-string用大括号 {} 表示被替换字段，其中直接填入替换内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; name = &apos;Eric&apos;</span><br><span class="line">&gt;&gt;&gt; f&apos;Hello, my name is &#123;name&#125;&apos;</span><br><span class="line">&apos;Hello, my name is Eric&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; number = 7</span><br><span class="line">&gt;&gt;&gt; f&apos;My lucky number is &#123;number&#125;&apos;</span><br><span class="line">&apos;My lucky number is 7&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; price = 19.99</span><br><span class="line">&gt;&gt;&gt; f&apos;The price of this book is &#123;price&#125;&apos;</span><br><span class="line">&apos;The price of this book is 19.99&apos;</span><br></pre></td></tr></table></figure>
<h4 id="表达式求值与函数调用"><a href="#表达式求值与函数调用" class="headerlink" title="表达式求值与函数调用"></a>表达式求值与函数调用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f&apos;A total number of &#123;24 * 8 + 4&#125;&apos;</span><br><span class="line">&apos;A total number of 196&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f&apos;Complex number &#123;(2 + 2j) / (2 - 3j)&#125;&apos;</span><br><span class="line">&apos;Complex number (-0.15384615384615388+0.7692307692307692j)&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; name = &apos;ERIC&apos;</span><br><span class="line">&gt;&gt;&gt; f&apos;My name is &#123;name.lower()&#125;&apos;</span><br><span class="line">&apos;My name is eric&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; f&apos;The answer is &#123;math.log(math.pi)&#125;&apos;</span><br><span class="line">&apos;The answer is 1.1447298858494002&apos;</span><br></pre></td></tr></table></figure>
<h4 id="引号、大括号与反斜杠"><a href="#引号、大括号与反斜杠" class="headerlink" title="引号、大括号与反斜杠"></a>引号、大括号与反斜杠</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f&quot;He said &#123;&quot;I&apos;m Eric&quot;&#125;&quot;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    f&quot;He said &#123;&quot;I&apos;m Eric&quot;&#125;&quot;</span><br><span class="line">                ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f&apos;He said &#123;&quot;I&apos;m Eric&quot;&#125;&apos;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    f&apos;He said &#123;&quot;I&apos;m Eric&quot;&#125;&apos;</span><br><span class="line">                  ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f&quot;&quot;&quot;He said &#123;&quot;I&apos;m Eric&quot;&#125;&quot;&quot;&quot;</span><br><span class="line">&quot;He said I&apos;m Eric&quot;</span><br><span class="line">&gt;&gt;&gt; f&apos;&apos;&apos;He said &#123;&quot;I&apos;m Eric&quot;&#125;&apos;&apos;&apos;</span><br><span class="line">&quot;He said I&apos;m Eric&quot;</span><br></pre></td></tr></table></figure>
<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f&apos;result is &#123;(lambda x: x ** 2 + 1) (2)&#125;&apos;</span><br><span class="line">&apos;result is 5&apos;</span><br><span class="line">&gt;&gt;&gt; f&apos;result is &#123;(lambda x: x ** 2 + 1) (2):&lt;+7.2f&#125;&apos;</span><br><span class="line">&apos;result is +5.00</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><strong>re.match 函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re.match(pattern,string,flags=0)</span><br><span class="line"></span><br><span class="line">pattern	匹配的正则表达式</span><br><span class="line">string	要匹配的字符串</span><br><span class="line">flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line">print(re.match(&apos;www&apos;, &apos;www.shiyanlou.com&apos;).span())  # 在起始位置匹配</span><br><span class="line">print(re.match(&apos;com&apos;, &apos;www.shiyanlou.com&apos;))         # 不在起始位置匹配</span><br></pre></td></tr></table></figure>
<p><strong>re.search 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re.search(pattern,string,flags=0)</span><br><span class="line"></span><br><span class="line">pattern	要匹配的正则表达式</span><br><span class="line">string	要匹配的字符串</span><br><span class="line">flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line">print(re.search(&apos;www&apos;, &apos;www.shiyanlou.com&apos;).span())  # 在起始位置匹配</span><br><span class="line">print(re.search(&apos;com&apos;, &apos;www.shiyanlou.com&apos;).span())   # 不在起始位置匹配</span><br></pre></td></tr></table></figure>
<p><strong>re.match 与 re.search 的区别</strong></p>
<p>re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None；而 re.search 匹配整个字符串，直到找到一个匹配</p>
<p><strong>检索和替换</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re.sub(pattern,repl,string,count=0,flags=0)</span><br><span class="line"></span><br><span class="line">pattern:正则表达式中模式字符串</span><br><span class="line">repl:替换的字符串，也可为一个函数</span><br><span class="line">string:要被查找替换的原始字符串</span><br><span class="line">count:模式匹配后替换的最大次数,默认 0 表示替换所有的匹配</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line">phone=&quot;2004-959-559 # 这是一个国外电话号码&quot;</span><br><span class="line"></span><br><span class="line">#删除字符串中的 Python注释</span><br><span class="line">num=re.sub(r&apos;#.*$&apos;,&quot;&quot;,phone) #r代表正则表达式,将在后面介绍具体规则</span><br><span class="line">print(&quot;电话号码是：&quot;,num)</span><br><span class="line"></span><br><span class="line"># 删除非数字(-)的字符串 </span><br><span class="line">num = re.sub(r&apos;\D&apos;, &quot;&quot;, phone)</span><br><span class="line">print(&quot;电话号码是：&quot;,num)</span><br></pre></td></tr></table></figure>
<p><strong>re.compile 函数</strong><br>compile 函数用于编译正则表达式，生成一个正则表达（Pattern）对象，供 match() 和 search() 这两个函数使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re.compile(pattern[,flags])</span><br><span class="line"></span><br><span class="line">pattern: 一个字符串形式的正则表达式</span><br><span class="line">flags:可选，表示匹配模式，比如忽略大小写，多行模式，具体参数为：</span><br><span class="line">re.l 忽略大小写</span><br><span class="line">re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境</span><br><span class="line">re.M 多行模式</span><br><span class="line">re.S . 并且包括换行符在内的任意字符（. 不包括换行符)</span><br><span class="line">re.X 为了增加可读性，忽略空格和 # 后面的注释</span><br></pre></td></tr></table></figure>
<p><strong>findall</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">findall(string[,pos[,endpos]])</span><br><span class="line"></span><br><span class="line">string:待匹配的字符串</span><br><span class="line">pos:可选参数，指定字符串的起始位置，默认为 0。</span><br><span class="line">endpos:可选参数，指定字符串的结束位置，默认为字符串的长度。</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line">pattern=re.compile(r&apos;\d+&apos;) #查找数字</span><br><span class="line">result1 = pattern.findall(&apos;runoob 123 google 456&apos;)</span><br><span class="line">result2 = pattern.findall(&apos;run88oob123google456&apos;, 0, 10)</span><br><span class="line">print(result1)</span><br><span class="line">print(result2)</span><br></pre></td></tr></table></figure>
<p><strong>re.split</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re.split(pattern, string[, maxsplit=0, flags=0])</span><br><span class="line"></span><br><span class="line">pattern	匹配的正则表达式</span><br><span class="line">string	要匹配的字符串</span><br><span class="line">maxsplit	分隔次数，maxsplit =1 分隔一次，默认为 0，不限制次数</span><br><span class="line">flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</span><br></pre></td></tr></table></figure>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>字符串匹配是极为常见的一种模式匹配。简单地说，就是判断主串 T 中是否出现模式串 P，即 P 为 T 的子串。特别地，定义主串 T[0…n-1],模式串为 P [0…p-1],则主串与模式串的长度各为 n 与 p</p>
<p><strong>暴力匹配</strong></p>
<p>暴力匹配方法的思想非常朴素：</p>
<ol>
<li>依次从主串的首字符开始，与模式串逐一进行匹配</li>
<li>遇到失配时，则移到主串的第二个字符，将其与模式串首字符比较，逐一进行匹配</li>
<li>重复上述步骤，直至能匹配上，或剩下主串的长度不足以进行匹配</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = &quot;asdadadsfasdfasdfasdtest&quot;</span><br><span class="line">p = &quot;test&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def brute_force_match(s, p):</span><br><span class="line">    s_len = len(s)</span><br><span class="line">    p_len = len(p)</span><br><span class="line"></span><br><span class="line">    for i in range(s_len):</span><br><span class="line">        j = 0</span><br><span class="line">        while j &lt; p_len and i + j &lt; s_len and s[i + j] == p[j]:</span><br><span class="line">            j += 1</span><br><span class="line">            if j == p_len:</span><br><span class="line">                return i</span><br><span class="line">    return -1</span><br><span class="line"></span><br><span class="line">print(brute_force_match(s, p))</span><br></pre></td></tr></table></figure>
<p>算法复杂度分析：i 在主串上移动 (n-p)次，匹配失败时，j 移动次数最多有 p-1 次。因此复杂度为 O(n*p)</p>
<p>对于暴力匹配而言，就存在重复匹配的现象。比如，第一次匹配失败时，主串，模式串失败匹配的位置的字符分别为 a 与 c ,下一次匹配时主串，模式串的起始位置分别为 T1 与 P[0];而在模式串中 c 之前是 ab ,未有重复结构，因此 T1与 P[0]肯定不能匹配上，这样造成了重复匹配。直观上，下一次匹配应从 T2 与 P[0] 开始。</p>
<p><strong>KMP 算法原理</strong></p>
<p>KMP 算法思想归纳如下：将主串 T 的第一个字符与模式串 P 的第一个字符进行匹配。如果相等，则依次比较 T 和 P 的下一个字符。如果不相等，则 主串 T 移动(已匹配字符数-对应的部分匹配值)位，继续匹配。</p>
<p>关于移动位数的解释：已匹配字符数，即当前已完成匹配的字符数量。部分匹配值就是前缀和后缀的最长的共有元素的长度。</p>
<p>前缀指除了最后一个字符以外，一个字符串的全部头部组合</p>
<p>后缀指除了第一个字符以外，一个字符串的全部尾部组合</p>
<p>举个例子：以”ABCDABD”为例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;A&quot;的前缀和后缀都为空集，共有元素的长度为 0；</span><br><span class="line">&quot;AB&quot;的前缀为[A]，后缀为[B]，共有元素的长度为 0；</span><br><span class="line">&quot;ABC&quot;的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度 0；</span><br><span class="line">&quot;ABCD&quot;的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为 0；</span><br><span class="line">“ABCDA&quot;的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为&quot;A”，长度为 1；</span><br><span class="line">“ABCDAB&quot;的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为&quot;AB”，长度为 2；</span><br><span class="line">&quot;ABCDABD&quot;的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为 0。</span><br><span class="line"></span><br><span class="line">部分匹配表如下：</span><br><span class="line"></span><br><span class="line">搜索值	A	B	C	D	A	B	D</span><br><span class="line">部分匹配值	0	0	0	0	1	2	0</span><br></pre></td></tr></table></figure></p>
<p><strong>算法实现</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def same_start_end(s):</span><br><span class="line">    &quot;&quot;&quot;最长前后缀相同的字符位数&quot;&quot;&quot;</span><br><span class="line">    n = len(s)  # 整个字符串长度</span><br><span class="line">    j = 0  # 前缀匹配指向</span><br><span class="line">    i = 1  # 后缀匹配指向</span><br><span class="line">    result_list = [0] * n</span><br><span class="line">    while i &lt; n:</span><br><span class="line">        if j == 0 and s[j] != s[i]:  # 比较不相等并且此时比较的已经是第一个字符了</span><br><span class="line">            result_list[i] = 0  # 值为０</span><br><span class="line">            i += 1  # 向后移动</span><br><span class="line">        elif s[j] != s[i] and j != 0:  # 比较不相等,将j值设置为ｊ前一位的result_list中的值，为了在之前匹配到的子串中找到最长相同前后缀</span><br><span class="line">            j = result_list[j - 1]</span><br><span class="line">        elif s[j] == s[i]:  # 相等则继续比较</span><br><span class="line">            result_list[i] = j + 1</span><br><span class="line">            j = j + 1</span><br><span class="line">            i = i + 1</span><br><span class="line">    return result_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def kmp(s, p):</span><br><span class="line">    &quot;&quot;&quot;kmp算法,s是字符串，p是模式字符串，返回值为匹配到的第一个字符串的第一个字符的索引，没匹配到返回-1&quot;&quot;&quot;</span><br><span class="line">    s_length = len(s)</span><br><span class="line">    p_length = len(p)</span><br><span class="line">    i = 0  # 指向s</span><br><span class="line">    j = 0  # 指向p</span><br><span class="line">    next = same_start_end(p)</span><br><span class="line">    while i &lt; s_length:</span><br><span class="line">        if s[i] == p[j]:  # 对应字符相同</span><br><span class="line">            i += 1</span><br><span class="line">            j += 1</span><br><span class="line">            if j &gt;= p_length:  # 完全匹配</span><br><span class="line">                return i - p_length</span><br><span class="line">        elif s[i] != p[j]:  # 不相同</span><br><span class="line">            if j == 0:  # 与模式比较的是模式的第一个字符</span><br><span class="line">                i += 1</span><br><span class="line">            else:  # 取模式当前字符之前最长相同前后缀的前缀的后一个字符继续比较</span><br><span class="line">                j = next[j]</span><br><span class="line">    if i == s_length:  # 没有找到完全匹配的子串</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://blog.csdn.net/sunxb10/article/details/81036693" target="_blank" rel="noopener">https://blog.csdn.net/sunxb10/article/details/81036693</a></li>
<li><a href="https://blog.csdn.net/lzj_1314/article/details/89135217" target="_blank" rel="noopener">https://blog.csdn.net/lzj_1314/article/details/89135217</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></li>
<li><a href="https://www.cnblogs.com/sfencs-hcy/p/10646437.html" target="_blank" rel="noopener">https://www.cnblogs.com/sfencs-hcy/p/10646437.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python面向对象编程</title>
    <url>/2021/03/18/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="动态语言的定义"><a href="#动态语言的定义" class="headerlink" title="动态语言的定义"></a>动态语言的定义</h3><blockquote>
<p>动态编程语言是高级程序设计语言的一个类别，在计算机科学领域已被广泛应用。它是一类 在运行时可以改变其结构的语言 ：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。动态语言目前非常具有活力。例如JavaScript便是一个动态语言，除此之外如 PHP 、 Ruby 、 Python 等也都属于动态语言，而 C 、 C++ 等语言则不属于动态语言。</p>
</blockquote>
<h3 id="运行的过程中给对象绑定-添加-属性"><a href="#运行的过程中给对象绑定-添加-属性" class="headerlink" title="运行的过程中给对象绑定(添加)属性"></a>运行的过程中给对象绑定(添加)属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age =age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">P = Person(&quot;test1&quot;,24)</span><br><span class="line">P.sex=&quot;male&quot;</span><br><span class="line">P.sex</span><br></pre></td></tr></table></figure>
<h3 id="运行的过程中给类绑定-添加-属性"><a href="#运行的过程中给类绑定-添加-属性" class="headerlink" title="运行的过程中给类绑定(添加)属性"></a>运行的过程中给类绑定(添加)属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P1 = Person(&quot;小丽&quot;, &quot;25&quot;)</span><br><span class="line">P1.sex</span><br></pre></td></tr></table></figure>
<p>Traceback (most recent call last):<br>  File “&lt;pyshell#21&gt;”, line 1, in <module><br>    P1.sex<br>AttributeError: Person instance has no attribute ‘sex’</module></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt; Person.sex = None</span><br><span class="line">&gt;&gt;&gt; P1 = Person(&quot;小丽&quot;, &quot;25&quot;)</span><br><span class="line">&gt;&gt;&gt; print P1.sex</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="运行的过程中给类绑定-添加-方法"><a href="#运行的过程中给类绑定-添加-方法" class="headerlink" title="运行的过程中给类绑定(添加)方法"></a>运行的过程中给类绑定(添加)方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class Person(object):</span><br><span class="line">    def __init__(self, name = None, age = None):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    def eat(self):</span><br><span class="line">        print &quot;eat food&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def run(self, speed):</span><br><span class="line">    print &quot;Keeping moving, the speed is %d km/h&quot; %speed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; P = Person(&quot;老王&quot;, 24)</span><br><span class="line">&gt;&gt;&gt; P.eat()</span><br><span class="line">eat food</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; P.run()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#5&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    P.run()</span><br><span class="line">AttributeError: Person instance has no attribute &apos;run&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; Person.run = types.MethodType(run, None, Person)</span><br><span class="line">&gt;&gt;&gt; P.run(180)</span><br><span class="line">Keeping moving, the speed is 180 km/h</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; def testName(self):</span><br><span class="line">    print self.name</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; Person.testName = types.MethodType(testName, None, Person)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; P.test()</span><br><span class="line">老王</span><br></pre></td></tr></table></figure>
<p>既然给类添加方法，是使用类名.方法名 = xxxx，那么给对象添加一个方法也是类似的对象.方法名 = xxxx</p>
<h3 id="运行的过程中删除属性、方法"><a href="#运行的过程中删除属性、方法" class="headerlink" title="运行的过程中删除属性、方法"></a>运行的过程中删除属性、方法</h3><p>删除的方法:</p>
<p>del 对象.属性名<br>delattr(对象, “属性名”)<br>通过以上例子可以得出一个结论：相对于动态语言，静态语言具有严谨性！所以，玩动态语言的时候，小心动态的坑！</p>
<p>那么怎么避免这种情况呢？ 请使用<strong>slots</strong>，</p>
<h3 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h3><p>现在我们终于明白了，动态语言语句静态语言的不同</p>
<p>动态语言：可以在运行的过程中，修改代码 静态语言：编译时已经确定好代码，运行过程中不能修改</p>
<p>如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。</p>
<p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<strong>slots</strong>变量，来限制该class实例能添加的属性：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class Person(object):</span><br><span class="line">    __slots__ = (&quot;name&quot;, &quot;age&quot;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; P = Person()</span><br><span class="line">&gt;&gt;&gt; P.name = &quot;老王&quot;</span><br><span class="line">&gt;&gt;&gt; P.age = 20</span><br><span class="line">&gt;&gt;&gt; P.score = 100</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: Person instance has no attribute &apos;score&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<strong>，在Python中，实例的变量名如果以</strong>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    __slots__ = (&quot;name&quot;, &quot;age&quot;,&quot;__feature&quot;)</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age, feature):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.__feature = feature</span><br><span class="line"></span><br><span class="line">    def print_person(self):</span><br><span class="line">        print(&quot;name is &#123;&#125;,age is &#123;&#125;&quot;.format(self.name, self.age))</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    p = Person(&quot;test&quot;, 11,&quot;coding&quot;)</span><br><span class="line">    p.print_person()</span><br><span class="line">    p.__feature</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/zyy/Downloads/workspace/python3/learn/lang/Person.py&quot;, line 32, in &lt;module&gt;</span><br><span class="line">    p.__feature</span><br><span class="line">AttributeError: &apos;Person&apos; object has no attribute &apos;__feature&apos;</span><br><span class="line">name is test,age is 11</span><br></pre></td></tr></table></figure></p>
<h4 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h4><p>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。</p>
<p>多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：</p>
<p>对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<p>对扩展开放：允许新增Animal子类；</p>
<p>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    __slot__ = (&quot;__name&quot;, &quot;__leg&quot;)</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, leg):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__leg = leg</span><br><span class="line"></span><br><span class="line">    def get_name(self):</span><br><span class="line">        return self.__name</span><br><span class="line"></span><br><span class="line">    def set_name(self, name):</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    def get_leg(self):</span><br><span class="line">        return self.__leg</span><br><span class="line"></span><br><span class="line">    def set_leg(self, leg):</span><br><span class="line">        self.__leg = leg</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;animal is running&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;Dog is running&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;Cat is running&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    dog = Dog(&quot;dog&quot;, 4)</span><br><span class="line">    cat = Cat(&quot;cat&quot;, 3)</span><br><span class="line">    print(dog.get_name())</span><br><span class="line">    dog.run()</span><br><span class="line">    cat.run()</span><br><span class="line">    print(isinstance(dog, Animal))</span><br><span class="line">    print(isinstance(dog, list))</span><br></pre></td></tr></table></figure>
<h3 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h3><p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Timer(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Start...&apos;)</span><br></pre></td></tr></table></figure>
<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</p>
<h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     name = &apos;Student&apos;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s = Student() # 创建实例s</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 打印类的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 给实例绑定name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span><br><span class="line">Michael</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; del s.name # 如果删除实例的name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span><br><span class="line">Student</span><br></pre></td></tr></table></figure>
<h3 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h3><ol>
<li>使用type()首先，我们来判断对象类型，使用type()函数,基本类型都可以用type()判断;</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type(fn)==types.FunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(lambda x: x)==types.LambdaType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。</p>
</li>
<li><p>如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(&apos;ABC&apos;)</span><br><span class="line">[&apos;__add__&apos;, &apos;__class__&apos;,..., &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;,..., &apos;zfill&apos;]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>rpm包制作流程</title>
    <url>/2020/09/22/rpm%E5%8C%85%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="什么是rpm包？"><a href="#什么是rpm包？" class="headerlink" title="什么是rpm包？"></a>什么是rpm包？</h4><p>rpm 相当于windows中的安装文件，它会自动处理软件包之间的依赖关系。</p>
<p>rpm优点：<br>包管理系统简单，通过几个命令就可以实现包的安装、升级、卸载。<br>安装速度比源码包快的多。<br>缺点：<br>经过编译，不能看到源代码，功能选择不如源码灵活。依赖性强。</p>
<h4 id="包名称"><a href="#包名称" class="headerlink" title="包名称"></a>包名称</h4><p>一个rpm包的名称分为包全名和包名，包全名如httpd-2.2.15-39.el6.centos.x86_64.rpm，包全名中各部分的意义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">httpd       包名</span><br><span class="line">2.2.15      版本号，版本号格式[ 主版本号.[ 次版本号.[ 修正号 ] ] ]</span><br><span class="line">39          软件发布次数</span><br><span class="line">el6.centos  适合的操作系统平台以及适合的操作系统版本</span><br><span class="line">x86_64      适合的硬件平台，硬件平台根据cpu来决定，有i386、i586、i686、x86_64、noarch或者省略，noarch或省略表示不区分硬件平台</span><br><span class="line">rpm         软件包后缀扩展名</span><br></pre></td></tr></table></figure>
<p>使用rpm工具管理包时，如果要操作未安装的包，则使用包全名，如安装包，查看未安装包的信息等；如果要操作已安装的rpm包，则只需要给定其包名即可，如查询已装包生成了哪些文件，查看已装包的信息等。</p>
<p>而对于yum工具来说，只需给定其包名即可，若有需要，再指定版本号，如明确指明要安装1.6.10版本的tree工具，yum install tree-1.6.10。</p>
<h4 id="rpm管理包"><a href="#rpm管理包" class="headerlink" title="rpm管理包"></a>rpm管理包</h4><p>rpm包被安装后，会在/var/lib/rpm下会建立已装rpm数据库，以后有任何rpm的升级、查询、版本比较等包的操作都是从这个目录下获取信息并完成相应操作的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xuexi ~]# ls /var/lib/rpm/ </span><br><span class="line">Basenames     __db.003     Group         Packages        Requirename     Triggername</span><br><span class="line">Conflictname  __db.004     Installtid    Providename     Requireversion</span><br><span class="line">__db.001      Dirnames     Name          Provideversion  Sha1header</span><br><span class="line">__db.002      Filedigests  Obsoletename  Pubkeys         Sigmd5</span><br></pre></td></tr></table></figure>
<p>rpm安装完成后，相关的文件会复制到多个目录下(具体复制的路径是在制作rpm包时指定的)。一般来说，分布形式差不多如下表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc 放置配置文件的目录</span><br><span class="line">/bin、/sbin、/usr/bin或/usr/sbin 一些可执行文件</span><br><span class="line">/lib、/lib64、/usr/lib(/usr/lib64) 一些库文件</span><br><span class="line">/usr/include  一些头文件</span><br><span class="line">/usr/share/doc 一些基本的软件使用手册与帮助文件</span><br><span class="line">/usr/share/man 一些 man page 档案</span><br></pre></td></tr></table></figure>
<h4 id="rpm安装、升级、卸载"><a href="#rpm安装、升级、卸载" class="headerlink" title="rpm安装、升级、卸载"></a>rpm安装、升级、卸载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivhUe --nodeps --test --force --prefix</span><br><span class="line">选项说明：</span><br><span class="line">-i 表示安装，install的意思</span><br><span class="line">-v 显示安装信息，还可以&quot;-vv&quot;、&quot;-vvv&quot;，v提供的越多显示信息越多</span><br><span class="line">-h 显示安装进度，以#显示安装的进度</span><br><span class="line">-U 升级或升级包</span><br><span class="line">-F 只升级已安装的包</span><br><span class="line">-e 卸载包，卸载也有依赖性,&quot;--erase&quot;</span><br><span class="line">--nodeps 忽略依赖性强制安装或卸载(no dependencies)</span><br><span class="line">--test 测试是否能够成功安装指定的rpm包</span><br><span class="line">--prefix 新路径 自行指定安装路径而不是使用默认路径，基本上都不支持该功能，功能极其简单的软件估计才支持重定位安装路径</span><br><span class="line">--force 强制动作</span><br><span class="line">--replacepkgs 替换安装，即重新覆盖安装。</span><br></pre></td></tr></table></figure>
<h4 id="rpm查询功能"><a href="#rpm查询功能" class="headerlink" title="rpm查询功能"></a>rpm查询功能</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-q[p] -q查询已安装的包，-qp查询未安装的包。它们都可接下面的参数</span><br><span class="line">    -a 查询所有已安装的包，也可以指定通配符名称进行查询</span><br><span class="line">    -i 查询指定包的信息（版本、开发商、安装时间等）。从这里面可以查看到软件包属于哪个包组。</span><br><span class="line">    -l 查询包的文件列表和目录（包在生产的时候就指定了文件路径，因此可查未装包）</span><br><span class="line">    -R 查询包的依赖性（Required）</span><br><span class="line">    -c 查询安装后包生成的配置文件</span><br><span class="line">    -d 查询安装后包生成的帮助文档</span><br><span class="line">-f 查询系统文件属于哪个已安装的包（接的是文件而不是包）</span><br><span class="line">--scripts 查询包相关的脚本文档。脚本文档分四类：安装前运行、安装后运行、卸载前运行、卸载后运行</span><br><span class="line"></span><br><span class="line">(1).查询文件/etc/yum.conf是通过哪个包安装的。</span><br><span class="line">[root@xuexi cdrom]# rpm -qf /etc/yum.conf</span><br><span class="line">yum-3.2.29-60.el6.centos.noarch</span><br><span class="line"></span><br><span class="line">(2).查询安装httpd时生成了哪些目录和文件，还可以过滤出提供了哪些命令行工具。</span><br><span class="line">rpm -ql httpd</span><br><span class="line">rpm -ql httpd | grep &apos;bin/&apos;</span><br><span class="line"></span><br><span class="line">(3).查询某个未安装包的依赖性如zip-3.0-1.el6.x86_64.rpm的依赖性。</span><br><span class="line">[root@xuexi cdrom]# rpm -qRp zip-3.0-1.el6.x86_64.rpm</span><br><span class="line">libc.so.6()(64bit) </span><br><span class="line">libc.so.6(GLIBC_2.2.5)(64bit) </span><br><span class="line">libc.so.6(GLIBC_2.3)(64bit) </span><br><span class="line">libc.so.6(GLIBC_2.3.4)(64bit) </span><br><span class="line">libc.so.6(GLIBC_2.4)(64bit) </span><br><span class="line">libc.so.6(GLIBC_2.7)(64bit) </span><br><span class="line">rpmlib(CompressedFileNames) &lt;= 3.0.4-1</span><br><span class="line">rpmlib(FileDigests) &lt;= 4.6.0-1</span><br><span class="line">rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1</span><br><span class="line">rtld(GNU_HASH) </span><br><span class="line">rpmlib(PayloadIsXz) &lt;= 5.2-1</span><br></pre></td></tr></table></figure>
<h4 id="yum管理包"><a href="#yum管理包" class="headerlink" title="yum管理包"></a>yum管理包</h4><p>/etc/yum.conf是yum的默认文件，里面配置的也是全局默认项。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@server2 ~]# cat /etc/yum.conf</span><br><span class="line"></span><br><span class="line">[main]</span><br><span class="line">cachedir=/var/cache/yum/$basearch/$releasever   # 缓存目录</span><br><span class="line">keepcache=0          # 是否保留缓存，设置为1时，安装包时所下载的包将不会被删除</span><br><span class="line">debuglevel=2         # 调试信息的级别</span><br><span class="line">logfile=/var/log/yum.log   # 日志文件位置</span><br><span class="line">exactarch=1         # 设置为1将只会安装和系统架构完全匹配的包</span><br><span class="line">obsoletes=1         # 是否允许更新旧的包</span><br><span class="line">gpgcheck=1          # 是否要进行gpg check</span><br><span class="line">plugins=1           # 是否允许使用yum插件</span><br><span class="line">installonly_limit=5</span><br><span class="line">bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yum</span><br><span class="line">distroverpkg=centos-release    # 指定基准包，yum会根据这个包判断发行版本</span><br></pre></td></tr></table></figure></p>
<h4 id="配置yum仓库"><a href="#配置yum仓库" class="headerlink" title="配置yum仓库"></a>配置yum仓库</h4><p>首先配置yum仓库，配置文件为/etc/yum.conf和/etc/yum.repos.d/中的”.repo”文件，其中/etc/yum.conf配置的是仓库的默认项，一般配置yum源都是在/etc/yum.repos.d/*.repo中配置。注意，该目录中任意repo文件都会被读取。</p>
<p>默认/etc/yum.repos.d/下会有以下几个仓库文件，除了CentOS-Base.repo，其他的都可以删掉，基本没用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@xuexi yum.repos.d]# vim CentOS-Base.repo</span><br><span class="line"></span><br><span class="line">[base]      # 仓库ID，ID必须保证唯一性</span><br><span class="line">name        # 仓库名称，可随意命名</span><br><span class="line">mirrorlist  # 该地址下包含了仓库地址列表，包含一个或多个镜像站点，和baseurl使用一个就可以了</span><br><span class="line">#baseurl    # 仓库地址。网络上的地址则写网络地址，本地地址则写本地地址，格式为“file://”后接路径，如file:///mnt/cdrom</span><br><span class="line">gpgcheck=1  # 指定是否需要签名，1表示需要，0表示不需要</span><br><span class="line">gpgkey=     # 签名文件的路径</span><br><span class="line">enable      # 该仓库是否生效，enable=1表示生效，enable=0表示不生效</span><br><span class="line">cost=       # 开销越高，优先级越低</span><br><span class="line"></span><br><span class="line">【repo配置文件中可用的宏：】</span><br><span class="line">$releasever：程序的版本，对Yum而言指的是redhat-relrase版本。只替换为主版本号，如Redhat6.5 则替换为6</span><br><span class="line">$arch：系统架构</span><br><span class="line">$basharch：系统基本架构，如i686，i586等的基本架构为i386</span><br><span class="line">$YUM0-9：在系统定义的环境变量，可以在yum中使用</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装epel-release-noarch.rpm</span><br><span class="line">rpm -ivh epel-release-latest-6.noarch.rpm</span><br><span class="line"></span><br><span class="line">方法二：直接增加epel仓库</span><br><span class="line">在/etc/yum.repos.d/下任意一个repo文件中添加上epel的仓库即可。</span><br><span class="line">[epel]</span><br><span class="line">name=epel</span><br><span class="line">baseurl=http://mirrors.sohu.com/fedora-epel/6Server/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">然后清除缓存再建立缓存即可。</span><br><span class="line"></span><br><span class="line">shell&gt; yum clean all ; yum makecache</span><br></pre></td></tr></table></figure>
<h4 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: yum [options] COMMAND</span><br><span class="line"></span><br><span class="line">List of Commands:</span><br><span class="line">help           命令的帮助信息，用法：yum help command，如yum help install则查看install命令的用法说明</span><br><span class="line">clean          清除缓存数据，如yum clean all</span><br><span class="line">makecache      生成元数据缓存数据，yum makecache</span><br><span class="line">deplist        列出包的依赖关系</span><br><span class="line">erase          卸载包</span><br><span class="line">fs             为当前文件系统创建快照，或者列出或删除当前已有快照。快照是非常有用的，升级或打补丁前拍个快照，就能放心地升级或打补丁了</span><br><span class="line">fssnapshot     同fs一样</span><br><span class="line">groups         操作包组</span><br><span class="line">history        查看yum事务信息，yum是独占模式的进程，所以有时候查看事务信息还是有用的</span><br><span class="line">info           输出包或包组的信息，例如该包是谁制作的，大概是干什么用的，来源于哪个包组等信息</span><br><span class="line">install        包安装命令</span><br><span class="line">list           列出包名，一般会结合grep来搜索包，如yum list all | grep -i zabbix</span><br><span class="line">provides       搜索给定的内容是谁提供的，可用来搜索来源于个包，如CentOS 7上mysql被mariadb替代，搜索Mysql提供者时就能找出包mariadb</span><br><span class="line">reinstall      重新安装包</span><br><span class="line">repolist       列出可用的仓库列表</span><br><span class="line">search         给定字符串搜索相关包，并给出相关包较为详细的信息</span><br><span class="line">update         更新包</span><br><span class="line"> </span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line">  -R [minutes], --randomwait=[minutes]：最多等待时间</span><br><span class="line">  -q, --quiet           安静模式</span><br><span class="line">  -v, --verbose         详细模式</span><br><span class="line">  -y, --assumeyes       对所有问题回答yes</span><br><span class="line">  --assumeno            对所有问题回答no</span><br><span class="line">  --enablerepo=[repo]   启用一个或多个仓库，可用通配符通配仓库ID</span><br><span class="line">  --disablerepo=[repo]  禁用一个或多个仓库，可用通配符通配仓库ID</span><br><span class="line">  -x [package], --exclude=[package]  通配要排除的包</span><br><span class="line">  --nogpgcheck          禁用gpgcheck</span><br><span class="line">  --color=COLOR         带颜色</span><br><span class="line">  --downloadonly        仅下载包，不安装或升级。默认下载在yum的缓存目录中，默认为/var/cache/yum/$basearch/$releasever</span><br><span class="line">  --downloaddir=DLDIR   指定下载目录</span><br></pre></td></tr></table></figure>
<h4 id="制作rpm-包"><a href="#制作rpm-包" class="headerlink" title="制作rpm 包"></a>制作rpm 包</h4><p><strong>安装rpmbuild</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$yum install rpmbuild</span><br><span class="line">$yum install rpmdevtools </span><br><span class="line">$rpmdev-setuptree</span><br><span class="line"></span><br><span class="line">此时rpmbuild已经安装好了，可以查看一下</span><br><span class="line"></span><br><span class="line">rpmbuild --showrc | grep topdir</span><br></pre></td></tr></table></figure></p>
<p>进入rpmbuild 目录文件夹如下：<br><img src="/2020/09/22/rpm包制作流程/rpm1.png" alt="avatar"></p>
<p>各个文件夹的用途：<br><img src="/2020/09/22/rpm包制作流程/rpm2.png" alt="avatar"></p>
<p><strong>整理源码</strong></p>
<p>rpmbuild安装完成以后我门就需要将我们的源码放到 SOURCE 文件夹下。我门的源码可能是一个tar.gz 的包、也可能是几个文件。</p>
<p>tar.gz源码包的名字格式应该为 helloword-1.0.0.tar.gz (其实就是名字-版本号.tar.gz)</p>
<p><strong>编写spec文件</strong></p>
<p>在SPECS文件夹下新建 xxx.spec 打包脚本，其实也就是把我门的源码编译打包成rpm 的一个过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  xxx.spec </span><br><span class="line"></span><br><span class="line">Name:           hellorpm           #名字为源码tar.gz 包的名字 </span><br><span class="line">Version:        1.0.0             #版本号，一定要与tar.gz包的一致哦 </span><br><span class="line">Release:        1%&#123;?dist&#125;         #释出号，也就是第几次制作rpm </span><br><span class="line">Summary:       helloword   #软件包简介，最好不要超过50字符 </span><br><span class="line"></span><br><span class="line">License:        GPL                   #许可，GPL还是BSD等  </span><br><span class="line">URL:            #可以写一个网址 </span><br><span class="line">Packager:       abel </span><br><span class="line">Source0:        %&#123;name&#125;-%&#123;version&#125;.tar.gz   </span><br><span class="line">#定义用到的source，也就是你的源码</span><br><span class="line"></span><br><span class="line">BuildRoot:      %_topdir/BUILDROOT         </span><br><span class="line">#这个是软件make install 的测试安装目录.</span><br><span class="line"></span><br><span class="line">BuildRequires:  gcc,make                           #制作过程中用到的软件包 </span><br><span class="line">Requires:       python-apscheduler &gt;= 2.1.2-1.el7,python-daemon &gt;= 1.6-1.el7  #软件运行依赖的软件包，也可以指定最低版本如 bash &gt;= 1.1.1 </span><br><span class="line">%description                #描述，随便写                 </span><br><span class="line">%prep                          ＃打包开始                    </span><br><span class="line">%setup -q                      #这个作用静默模式解压并cd                               </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%build              #编译制作阶段，主要目的就是编译，如果不用编译就为空 </span><br><span class="line">./configure \                                     </span><br><span class="line"> %&#123;?_smp_mflags&#125;          #make后面的意思是：如果就多处理器的话make时并行编译 </span><br><span class="line"></span><br><span class="line">%install                        #安装阶段                        </span><br><span class="line">rm -rf %&#123;buildroot&#125;             #先删除原来的安装的，如果你不是第一次安装的话 </span><br><span class="line"> cp -rp %_topdir/BUILD/%&#123;name&#125;-%&#123;version&#125;/*  $RPM_BUILD_ROOT </span><br><span class="line">#将需要需要打包的文件从BUILD 文件夹中拷贝到BUILDROOT文件夹下。</span><br><span class="line"></span><br><span class="line">#下面的几步pre、post、preun、postun 没必要可以不写 </span><br><span class="line">%pre        #rpm安装前制行的脚本 </span><br><span class="line"></span><br><span class="line">%post       #安装后执行的脚本 </span><br><span class="line"></span><br><span class="line">%preun      #卸载前执行的脚本 </span><br><span class="line"></span><br><span class="line">%postun     #卸载后执行的脚本 </span><br><span class="line"></span><br><span class="line">%clean #清理段,删除buildroot </span><br><span class="line">rm -rf %&#123;buildroot&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%files  #rpm要包含的文件 </span><br><span class="line">%defattr (-,root,root,-)   #设定默认权限，如果下面没有指定权限，则继承默认 </span><br><span class="line">/etc/hello/word/helloword.c           #将你需要打包的文件或目录写下来</span><br><span class="line"></span><br><span class="line">###  7.chagelog section  改变日志段 </span><br><span class="line">%changelog</span><br></pre></td></tr></table></figure>
<p>注意：<br>以上阶段如果没有操作的话，为空，但是不能有空行，例如build阶段为空应写为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%build              </span><br><span class="line">%install  </span><br><span class="line">xxxxxxxx   </span><br><span class="line"></span><br><span class="line">错误示例：</span><br><span class="line">%build   </span><br><span class="line"></span><br><span class="line">%install  </span><br><span class="line">xxxxxxxx</span><br></pre></td></tr></table></figure>
<p>rpm包制作阶段<br><img src="/2020/09/22/rpm包制作流程/rpm3.png" alt="avatar"></p>
<p><strong>打包</strong></p>
<p>spec 文件编写好以后就可以进行打包了。<br>在SPECS文件夹下执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpmbuild -bb xxx.spec</span><br></pre></td></tr></table></figure>
<p>如果出错了可以通过 不同的命令来看是在打包的那一步出了问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpmbuild  </span><br><span class="line">-ba 既生成src.rpm又生成二进制rpm </span><br><span class="line">-bs 只生成src的rpm </span><br><span class="line">-bb 只生二进制的rpm </span><br><span class="line">-bp 执行到pre </span><br><span class="line">-bc 执行到 build段 </span><br><span class="line">-bi 执行install段 </span><br><span class="line">-bl 检测有文件没包含</span><br></pre></td></tr></table></figure>
<h4 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h4><ol>
<li><a href="https://blog.csdn.net/u012373815/article/details/73257754" target="_blank" rel="noopener">https://blog.csdn.net/u012373815/article/details/73257754</a></li>
<li><a href="https://www.cnblogs.com/f-ck-need-u/p/7049750.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7049750.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot参数校验</title>
    <url>/2020/07/31/springboot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>因为网络传输的不可靠性，以及前端数据控制的可篡改性，后端的参数校验是必须的，应用程序必须通过某种手段来确保输入进来的数据从语义上来讲是正确的。</p>
<h2 id="2-数据校验的痛点"><a href="#2-数据校验的痛点" class="headerlink" title="2. 数据校验的痛点"></a>2. 数据校验的痛点</h2><p>为了保证数据语义的正确，我们需要进行大量的判断来处理验证逻辑。而且项目的分层也会造成一些重复的校验，产生大量与业务无关的代码。不利于代码的维护，增加了开发人员的工作量。</p>
<h2 id="3-JSR-303-校验规范及其实现"><a href="#3-JSR-303-校验规范及其实现" class="headerlink" title="3. JSR 303 校验规范及其实现"></a>3. JSR 303 校验规范及其实现</h2><p>为了解决上面的痛点，将验证逻辑与相应的领域模型进行绑定是十分有必要的。为此产生了JSR 303 – Bean Validation 规范。Hibernate Validator 是JSR-303的参考实现，它提供了JSR 303规范中所有的约束（constraint）的实现，同时也增加了一些扩展。</p>
<blockquote>
<p>Hibernate Validator 提供的常用约束注解</p>
</blockquote>
<table>
<thead>
<tr>
<th>约束注解</th>
<th>详细信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Null</td>
<td>被注释的元素必须为 null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>被注释的元素必须不为 null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>被注释的元素必须为 true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>被注释的元素必须为 false</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@Size(max, min)</td>
<td>被注释的元素的大小必须在指定的范围内</td>
</tr>
<tr>
<td>@Digits (integer, fraction)</td>
<td>被注释的元素必须是一个数字，其值必须在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>被注释的元素必须是一个过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>被注释的元素必须是一个将来的日期</td>
</tr>
<tr>
<td>@Pattern(value)</td>
<td>被注释的元素必须符合指定的正则表达式</td>
</tr>
<tr>
<td>@Email</td>
<td>被注释的元素必须是电子邮箱地址</td>
</tr>
<tr>
<td>@Length</td>
<td>被注释的字符串的大小必须在指定的范围内</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>被注释的字符串的必须非空</td>
</tr>
<tr>
<td>@Range</td>
<td>被注释的元素必须在合适的范围内</td>
</tr>
</tbody>
</table>
<h2 id="4-验证注解的使用"><a href="#4-验证注解的使用" class="headerlink" title="4. 验证注解的使用"></a>4. 验证注解的使用</h2><p>在Spring Boot开发中使用Hibernate Validator是非常容易的，引入下面的starter就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>一种可以实现接口来定制Validator，一种是使用约束注解。胖哥觉得注解可以满足绝大部分的需求，所以建议使用注解来进行数据校验。而且注解更加灵活，控制的粒度也更加细。接下来我们来学习如何使用注解进行数据校验。</p>
<blockquote>
<p>4.1 约束注解的基本使用</p>
</blockquote>
<p>我们对需要校验的方法入参进行注解约束标记，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    @NotBlank(message = &quot;姓名必须填&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @NotNull(message = &quot;年龄必须填写&quot;)</span><br><span class="line">    @Range(min = 1,max =50, message = &quot;年龄取值范围1-50&quot;)</span><br><span class="line">    private Integer age;</span><br><span class="line">    @NotEmpty(message = &quot;成绩必填&quot;)</span><br><span class="line">    private List&lt;Double&gt; scores;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>POST 请求</strong></p>
<p>然后定义一个POST请求的Spring MVC接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/student&quot;)</span><br><span class="line">public class StudentController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/add&quot;)</span><br><span class="line">    public Rest&lt;?&gt; addStudent(@Valid @RequestBody Student student) &#123;</span><br><span class="line">        return RestBody.okData(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过对addStudent方法入参添加@Valid来启用参数校验。当使用下面数据进行请求将会抛出MethodArgumentNotValidException异常，提示age范围超出1-50。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /student/add HTTP/1.1</span><br><span class="line">Host: localhost:8888</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;felord.cn&quot;,</span><br><span class="line">    &quot;age&quot;: 77,</span><br><span class="line">    &quot;scores&quot;: [</span><br><span class="line">        55</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GET 请求</strong></p>
<p>如法炮制，我们定义一个GET请求的接口：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/get&quot;)</span><br><span class="line">public Rest&lt;?&gt; getStudent(@Valid Student student) &#123;</span><br><span class="line">    return RestBody.okData(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用下面的请求可以正确对学生分数scores进行了校验，但是抛出的并不是MethodArgumentNotValidException异常，而是BindException异常。这和使用@RequestBody注解有关系，这对我们后面的统一处理非常十分重要。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /student/get?name=felord.cn&amp;age=12 HTTP/1.1</span><br><span class="line">Host: localhost:8888</span><br></pre></td></tr></table></figure>
<p><strong>自定义注解</strong></p>
<p>可能有些同学注意到上面的年龄我进行了这样的标记：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@NotNull(message = &quot;年龄必须填写&quot;)</span><br><span class="line">@Range(min = 1,max =50, message = &quot;年龄取值范围1-50&quot;)</span><br><span class="line">private Integer age;</span><br></pre></td></tr></table></figure>
<p>这是因为@Range不会去校验为空的情况，它只处理非空的时候是否符合范围约束。所以要用多个注解来约束。如果我们某些场景需要重复的捆绑多个注解来使用时，可以使用自定义注解将它们封装起来组合使用，下面这个注解就是将@NotNull和@Range进行了组合，你可以仿一个出来用用看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.hibernate.validator.constraints.Range;</span><br><span class="line"></span><br><span class="line">import javax.validation.Constraint;</span><br><span class="line">import javax.validation.Payload;</span><br><span class="line">import javax.validation.ReportAsSingleViolation;</span><br><span class="line">import javax.validation.constraints.NotNull;</span><br><span class="line">import javax.validation.constraintvalidation.SupportedValidationTarget;</span><br><span class="line">import javax.validation.constraintvalidation.ValidationTarget;</span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author a</span><br><span class="line"> * @since 17:31</span><br><span class="line"> **/</span><br><span class="line">@Constraint(</span><br><span class="line">        validatedBy = &#123;&#125;</span><br><span class="line">)</span><br><span class="line">@SupportedValidationTarget(&#123;ValidationTarget.ANNOTATED_ELEMENT&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.FIELD,</span><br><span class="line">        ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR,</span><br><span class="line">        ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line">@NotNull</span><br><span class="line">@Range(min = 1, max = 50)</span><br><span class="line">@Documented</span><br><span class="line">@ReportAsSingleViolation</span><br><span class="line">public @interface Age &#123;</span><br><span class="line">    // message 必须有</span><br><span class="line">    String message() default &quot;年龄必须填写，且范围为 1-50 &quot;;</span><br><span class="line"></span><br><span class="line">    // 可选</span><br><span class="line">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 可选</span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种情况，我们在后台定义了枚举值来进行状态的流转，也是需要校验的，比如我们定义了颜色枚举：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Colors &#123;</span><br><span class="line">    RED, YELLOW, BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们希望入参不能超出Colors的范围[“RED”, “YELLOW”, “BLUE”]，这就需要实现ConstraintValidator<a extends annotation, t>接口来定义一个颜色约束了，其中泛型A为自定义的约束注解，泛型T为入参的类型，这里使用字符串,然后我们的实现如下：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ColorConstraintValidator implements ConstraintValidator&lt;Color, String&gt; &#123;</span><br><span class="line">    private static final Set&lt;String&gt; COLOR_CONSTRAINTS = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void initialize(Color constraintAnnotation) &#123;</span><br><span class="line">        Colors[] value = constraintAnnotation.value();</span><br><span class="line">        List&lt;String&gt; list = Arrays.stream(value)</span><br><span class="line">                .map(Enum::name)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        COLOR_CONSTRAINTS.addAll(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isValid(String value, ConstraintValidatorContext context) &#123;</span><br><span class="line">        return COLOR_CONSTRAINTS.contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后声明对应的约束注解Color，需要在元注解@Constraint中指明使用上面定义好的处理类ColorConstraintValidator进行校验。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Constraint(validatedBy = ColorConstraintValidator.class)</span><br><span class="line">@Documented</span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.FIELD,</span><br><span class="line">        ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR,</span><br><span class="line">        ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Color &#123;</span><br><span class="line">    // 错误提示信息</span><br><span class="line">    String message() default &quot;颜色不符合规格&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 约束的类型</span><br><span class="line">    Colors[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来试一下，先对参数进行约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Param &#123;</span><br><span class="line">    @Color(&#123;Colors.BLUE,Colors.YELLOW&#125;)</span><br><span class="line">   private String color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口跟上面几个一样，调用下面的接口将抛出BindException异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /student/color?color=CAY HTTP/1.1</span><br><span class="line">Host: localhost:8888</span><br></pre></td></tr></table></figure>
<p>当我们把参数color赋值为BLUE或者YELLOW后，能够成功得到响应。</p>
<blockquote>
<p>4.2 常见问题</p>
</blockquote>
<p>在实际使用起来我们会遇到一些问题，这里总结了一些常见的问题和处理方式。</p>
<p><strong>检验基础类型不生效的问题</strong></p>
<p>上面为了校验颜色我们声明了一个Param对象来包装唯一的字符串参数color，为什么直接使用下面的方式定义呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/color&quot;)</span><br><span class="line">public Rest&lt;?&gt; color(@Valid @Color(&#123;Colors.BLUE,Colors.YELLOW&#125;) String color) &#123;</span><br><span class="line">    return RestBody.okData(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用路径变量：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/rest/&#123;color&#125;&quot;)</span><br><span class="line">public Rest&lt;?&gt; rest(@Valid @Color(&#123;Colors.BLUE, Colors.YELLOW&#125;) @PathVariable String color) &#123;</span><br><span class="line">    return RestBody.okData(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面两种方式是不会生效的。不信你可以试一试，起码在Spring Boot 2.3.1.RELEASE是不会直接生效的。</p>
<p>使以上两种生效的方法是在类上添加@Validated注解。注意一定要添加到方法所在的类上才行。这时候会抛出ConstraintViolationException异常。</p>
<p><strong>集合类型参数中的元素不生效的问题</strong></p>
<p>就像下面的写法，方法的参数为集合时，如何检验元素的约束呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/batchadd&quot;)</span><br><span class="line">public Rest&lt;?&gt; batchAddStudent(@Valid @RequestBody List&lt;Student&gt; student) &#123;</span><br><span class="line">    return RestBody.okData(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是在类上添加@Validated注解。注意一定要添加到方法所在的类上才行。这时候会抛出ConstraintViolationException异常。</p>
<p><strong>嵌套校验不生效</strong></p>
<p>嵌套的结构如何校验呢？打个比方，如果我们在学生类Student中添加了其所属的学校信息School并希望对School的属性进行校验。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    @NotBlank(message = &quot;姓名必须填&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @Age</span><br><span class="line">    private Integer age;</span><br><span class="line">    @NotEmpty(message = &quot;成绩必填&quot;)</span><br><span class="line">    private List&lt;Double&gt; scores;</span><br><span class="line">    @NotNull(message = &quot;学校不能为空&quot;)</span><br><span class="line">    private School school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class School &#123;</span><br><span class="line">    @NotBlank(message = &quot;学校名称不能为空&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @Min(value = 0,message =&quot;校龄大于0&quot; )</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 GET请求时正常校验了School的属性，但是POST请求却无法对School的属性进行校验。这时我们只需要在该属性上加上@Valid注解即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    @NotBlank(message = &quot;姓名必须填&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @Age</span><br><span class="line">    private Integer age;</span><br><span class="line">    @NotEmpty(message = &quot;成绩必填&quot;)</span><br><span class="line">    private List&lt;Double&gt; scores;</span><br><span class="line">    @Valid</span><br><span class="line">    @NotNull(message = &quot;学校不能为空&quot;)</span><br><span class="line">    private School school;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每加一层嵌套都需要加一层@Valid注解。通常在校验对象属性时，@NotNull、@NotEmpty和@Valid配合才能起到校验效果。</p>
</blockquote>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ol>
<li>https://mp.weixin.qq.com/s/wjNO9u8QgHN2XRNj4R8McQ</li>
</ol>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>strconv包学习整理(golang)</title>
    <url>/2019/04/01/strconv%E5%8C%85%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86(golang)/</url>
    <content><![CDATA[<h3 id="atob-go"><a href="#atob-go" class="headerlink" title="atob.go"></a>atob.go</h3><p>// 将布尔值转换为字符串 true 或 false<br>func FormatBool(b bool) string</p>
<p>// 将字符串转换为布尔值<br>// 它接受真值：1, t, T, TRUE, true, True<br>// 它接受假值：0, f, F, FALSE, false, False<br>// 其它任何值都返回一个错误。<br>func ParseBool(str string) (bool, error)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ParseBool returns the boolean value represented by the string.</span><br><span class="line">// It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.</span><br><span class="line">// Any other value returns an error.</span><br><span class="line">func ParseBool(str string) (bool, error) &#123;</span><br><span class="line">	switch str &#123;</span><br><span class="line">	case &quot;1&quot;, &quot;t&quot;, &quot;T&quot;, &quot;true&quot;, &quot;TRUE&quot;, &quot;True&quot;:</span><br><span class="line">		return true, nil</span><br><span class="line">	case &quot;0&quot;, &quot;f&quot;, &quot;F&quot;, &quot;false&quot;, &quot;FALSE&quot;, &quot;False&quot;:</span><br><span class="line">		return false, nil</span><br><span class="line">	&#125;</span><br><span class="line">	return false, syntaxError(&quot;ParseBool&quot;, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// FormatBool returns &quot;true&quot; or &quot;false&quot; according to the value of b.</span><br><span class="line">func FormatBool(b bool) string &#123;</span><br><span class="line">	if b &#123;</span><br><span class="line">		return &quot;true&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	return &quot;false&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AppendBool appends &quot;true&quot; or &quot;false&quot;, according to the value of b,</span><br><span class="line">// to dst and returns the extended buffer.</span><br><span class="line">func AppendBool(dst []byte, b bool) []byte &#123;</span><br><span class="line">	if b &#123;</span><br><span class="line">		return append(dst, &quot;true&quot;...)</span><br><span class="line">	&#125;</span><br><span class="line">	return append(dst, &quot;false&quot;...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="atof-go-amp-amp-ftoa-go"><a href="#atof-go-amp-amp-ftoa-go" class="headerlink" title="atof.go &amp;&amp; ftoa.go"></a>atof.go &amp;&amp; ftoa.go</h3><p>// FormatFloat 将浮点数 f 转换为字符串形式<br>// f：要转换的浮点数<br>// fmt：格式标记（b、e、E、f、g、G）<br>// prec：精度（数字部分的长度，不包括指数部分）<br>// bitSize：指定浮点类型（32:float32、64:float64），结果会据此进行舍入。<br>//<br>// 格式标记：<br>// ‘b’ (-ddddp±ddd，二进制指数)<br>// ‘e’ (-d.dddde±dd，十进制指数)<br>// ‘E’ (-d.ddddE±dd，十进制指数)<br>// ‘f’ (-ddd.dddd，没有指数)<br>// ‘g’ (‘e’:大指数，’f’:其它情况)<br>// ‘G’ (‘E’:大指数，’f’:其它情况)<br>//<br>// 如果格式标记为 ‘e’，’E’和’f’，则 prec 表示小数点后的数字位数<br>// 如果格式标记为 ‘g’，’G’，则 prec 表示总的数字位数（整数部分+小数部分）<br>// 参考格式化输入输出中的旗标和精度说明<br>func FormatFloat(f float64, fmt byte, prec, bitSize int) string</p>
<p>// 将字符串解析为浮点数，使用 IEEE754 规范进行舍入。<br>// bigSize 取值有 32 和 64 两种，表示转换结果的精度。<br>// 如果有语法错误，则 err.Error = ErrSyntax<br>// 如果结果超出范围，则返回 ±Inf，err.Error = ErrRange<br>func ParseFloat(s string, bitSize int) (float64, error)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ParseFloat converts the string s to a floating-point number</span><br><span class="line">// with the precision specified by bitSize: 32 for float32, or 64 for float64.</span><br><span class="line">// When bitSize=32, the result still has type float64, but it will be</span><br><span class="line">// convertible to float32 without changing its value.</span><br><span class="line">//</span><br><span class="line">// If s is well-formed and near a valid floating point number,</span><br><span class="line">// ParseFloat returns the nearest floating point number rounded</span><br><span class="line">// using IEEE754 unbiased rounding.</span><br><span class="line">//</span><br><span class="line">// The errors that ParseFloat returns have concrete type *NumError</span><br><span class="line">// and include err.Num = s.</span><br><span class="line">//</span><br><span class="line">// If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.</span><br><span class="line">//</span><br><span class="line">// If s is syntactically well-formed but is more than 1/2 ULP</span><br><span class="line">// away from the largest floating point number of the given size,</span><br><span class="line">// ParseFloat returns f = ±Inf, err.Err = ErrRange.</span><br><span class="line">func ParseFloat(s string, bitSize int) (float64, error) &#123;</span><br><span class="line">	if bitSize == 32 &#123;</span><br><span class="line">		f, err := atof32(s)</span><br><span class="line">		return float64(f), err</span><br><span class="line">	&#125;</span><br><span class="line">	return atof64(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// FormatFloat converts the floating-point number f to a string,</span><br><span class="line">// according to the format fmt and precision prec. It rounds the</span><br><span class="line">// result assuming that the original was obtained from a floating-point</span><br><span class="line">// value of bitSize bits (32 for float32, 64 for float64).</span><br><span class="line">//</span><br><span class="line">// The format fmt is one of</span><br><span class="line">// &apos;b&apos; (-ddddp±ddd, a binary exponent),</span><br><span class="line">// &apos;e&apos; (-d.dddde±dd, a decimal exponent),</span><br><span class="line">// &apos;E&apos; (-d.ddddE±dd, a decimal exponent),</span><br><span class="line">// &apos;f&apos; (-ddd.dddd, no exponent),</span><br><span class="line">// &apos;g&apos; (&apos;e&apos; for large exponents, &apos;f&apos; otherwise), or</span><br><span class="line">// &apos;G&apos; (&apos;E&apos; for large exponents, &apos;f&apos; otherwise).</span><br><span class="line">//</span><br><span class="line">// The precision prec controls the number of digits (excluding the exponent)</span><br><span class="line">// printed by the &apos;e&apos;, &apos;E&apos;, &apos;f&apos;, &apos;g&apos;, and &apos;G&apos; formats.</span><br><span class="line">// For &apos;e&apos;, &apos;E&apos;, and &apos;f&apos; it is the number of digits after the decimal point.</span><br><span class="line">// For &apos;g&apos; and &apos;G&apos; it is the maximum number of significant digits (trailing</span><br><span class="line">// zeros are removed).</span><br><span class="line">// The special precision -1 uses the smallest number of digits</span><br><span class="line">// necessary such that ParseFloat will return f exactly.</span><br><span class="line">func FormatFloat(f float64, fmt byte, prec, bitSize int) string &#123;</span><br><span class="line">	return string(genericFtoa(make([]byte, 0, max(prec+4, 24)), f, fmt, prec, bitSize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AppendFloat appends the string form of the floating-point number f,</span><br><span class="line">// as generated by FormatFloat, to dst and returns the extended buffer.</span><br><span class="line">func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte &#123;</span><br><span class="line">	return genericFtoa(dst, f, fmt, prec, bitSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="atoi-go-amp-amp-itoa-go"><a href="#atoi-go-amp-amp-itoa-go" class="headerlink" title="atoi.go &amp;&amp; itoa.go"></a>atoi.go &amp;&amp; itoa.go</h3><p>// ErrRange 表示值超出范围<br>var ErrRange = errors.New(“value out of range”)</p>
<p>// ErrSyntax 表示语法不正确<br>var ErrSyntax = errors.New(“invalid syntax”)</p>
<p>// 将整数转换为字符串形式。base 表示转换进制，取值在 2 到 36 之间。<br>// 结果中大于 10 的数字用小写字母 a - z 表示。<br>func FormatInt(i int64, base int) string<br>func FormatUint(i uint64, base int) string</p>
<p>// 将字符串解析为整数，ParseInt 支持正负号，ParseUint 不支持正负号。<br>// base 表示进位制（2 到 36），如果 base 为 0，则根据字符串前缀判断，<br>// 前缀 0x 表示 16 进制，前缀 0 表示 8 进制，否则是 10 进制。<br>// bitSize 表示结果的位宽（包括符号位），0 表示最大位宽。<br>func ParseInt(s string, base int, bitSize int) (i int64, err error)<br>func ParseUint(s string, base int, bitSize int) (uint64, error)</p>
<p>// 将整数转换为十进制字符串形式（即：FormatInt(i, 10) 的简写）<br>func Itoa(i int) string</p>
<p>// 将字符串转换为十进制整数，即：ParseInt(s, 10, 0) 的简写）<br>func Atoi(s string) (int, error)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ErrRange indicates that a value is out of range for the target type.</span><br><span class="line">var ErrRange = errors.New(&quot;value out of range&quot;)</span><br><span class="line"></span><br><span class="line">// ErrSyntax indicates that a value does not have the right syntax for the target type.</span><br><span class="line">var ErrSyntax = errors.New(&quot;invalid syntax&quot;)</span><br><span class="line">// Atoi returns the result of ParseInt(s, 10, 0) converted to type int.</span><br><span class="line">func Atoi(s string) (int, error) &#123;</span><br><span class="line">	const fnAtoi = &quot;Atoi&quot;</span><br><span class="line"></span><br><span class="line">	sLen := len(s)</span><br><span class="line">	if intSize == 32 &amp;&amp; (0 &lt; sLen &amp;&amp; sLen &lt; 10) ||</span><br><span class="line">		intSize == 64 &amp;&amp; (0 &lt; sLen &amp;&amp; sLen &lt; 19) &#123;</span><br><span class="line">		// Fast path for small integers that fit int type.</span><br><span class="line">		s0 := s</span><br><span class="line">		if s[0] == &apos;-&apos; || s[0] == &apos;+&apos; &#123;</span><br><span class="line">			s = s[1:]</span><br><span class="line">			if len(s) &lt; 1 &#123;</span><br><span class="line">				return 0, &amp;NumError&#123;fnAtoi, s0, ErrSyntax&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n := 0</span><br><span class="line">		for _, ch := range []byte(s) &#123;</span><br><span class="line">			ch -= &apos;0&apos;</span><br><span class="line">			if ch &gt; 9 &#123;</span><br><span class="line">				return 0, &amp;NumError&#123;fnAtoi, s0, ErrSyntax&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			n = n*10 + int(ch)</span><br><span class="line">		&#125;</span><br><span class="line">		if s0[0] == &apos;-&apos; &#123;</span><br><span class="line">			n = -n</span><br><span class="line">		&#125;</span><br><span class="line">		return n, nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Slow path for invalid or big integers.</span><br><span class="line">	i64, err := ParseInt(s, 10, 0)</span><br><span class="line">	if nerr, ok := err.(*NumError); ok &#123;</span><br><span class="line">		nerr.Func = fnAtoi</span><br><span class="line">	&#125;</span><br><span class="line">	return int(i64), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// FormatInt returns the string representation of i in the given base,</span><br><span class="line">// for 2 &lt;= base &lt;= 36. The result uses the lower-case letters &apos;a&apos; to &apos;z&apos;</span><br><span class="line">// for digit values &gt;= 10.</span><br><span class="line">func FormatInt(i int64, base int) string &#123;</span><br><span class="line">	if fastSmalls &amp;&amp; 0 &lt;= i &amp;&amp; i &lt; nSmalls &amp;&amp; base == 10 &#123;</span><br><span class="line">		return small(int(i))</span><br><span class="line">	&#125;</span><br><span class="line">	_, s := formatBits(nil, uint64(i), base, i &lt; 0, false)</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Itoa is shorthand for FormatInt(int64(i), 10).</span><br><span class="line">func Itoa(i int) string &#123;</span><br><span class="line">	return FormatInt(int64(i), 10)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AppendInt appends the string form of the integer i,</span><br><span class="line">// as generated by FormatInt, to dst and returns the extended buffer.</span><br><span class="line">func AppendInt(dst []byte, i int64, base int) []byte &#123;</span><br><span class="line">	if fastSmalls &amp;&amp; 0 &lt;= i &amp;&amp; i &lt; nSmalls &amp;&amp; base == 10 &#123;</span><br><span class="line">		return append(dst, small(int(i))...)</span><br><span class="line">	&#125;</span><br><span class="line">	dst, _ = formatBits(dst, uint64(i), base, i &lt; 0, true)</span><br><span class="line">	return dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>// 判断字符串是否可以不被修改的表示为一个单行的反引号字符串。<br>// 字符串中不能含有控制字符（除了 \t）和“反引号”字符，否则返回 false<br>func CanBackquote(s string) bool</p>
<p>// 判断 r 是否为可打印字符<br>// 可否打印并不是你想象的那样，比如空格可以打印，而\t则不能打印<br>func IsPrint(r rune) bool</p>
<p>// 判断 r 是否为 Unicode 定义的图形字符。<br>func IsGraphic(r rune) bool</p>
<p>// 将 s 转换为双引号字符串<br>func Quote(s string) string</p>
<p>// 功能同上，非 ASCII 字符和不可打印字符会被转义<br>func QuoteToASCII(s string) string</p>
<p>// 功能同上，非图形字符会被转义<br>func QuoteToGraphic(s string) string</p>
<p>// 将 r 转换为单引号字符<br>func QuoteRune(r rune) string</p>
<p>// 功能同上，非 ASCII 字符和不可打印字符会被转义<br>func QuoteRuneToASCII(r rune) string</p>
<p>// 功能同上，非图形字符会被转义<br>func QuoteRuneToGraphic(r rune) string</p>
]]></content>
  </entry>
  <entry>
    <title>systemd小结</title>
    <url>/2021/03/12/systemd%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>历史上，Linux 的启动一直采用init进程。下面的命令用来启动服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo /etc/init.d/apache2 start</span><br><span class="line"># 或者</span><br><span class="line">$ service apache2 start</span><br></pre></td></tr></table></figure>
<p>这种方法有两个缺点。</p>
<p>一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</p>
<p>二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p>
<h3 id="Systemd-概述"><a href="#Systemd-概述" class="headerlink" title="Systemd 概述"></a>Systemd 概述</h3><p>使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p>
<p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反”keep simple, keep stupid”的Unix 哲学。</p>
<p><img src="/2021/03/12/systemd小结/systemd1.png" alt="avatar"></p>
<h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p>systemctl是 Systemd 的主命令，用于管理系统。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 重启系统</span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"># 关闭系统，切断电源</span><br><span class="line">$ sudo systemctl poweroff</span><br><span class="line"></span><br><span class="line"># CPU停止工作</span><br><span class="line">$ sudo systemctl halt</span><br><span class="line"></span><br><span class="line"># 暂停系统</span><br><span class="line">$ sudo systemctl suspend</span><br><span class="line"></span><br><span class="line"># 让系统进入冬眠状态</span><br><span class="line">$ sudo systemctl hibernate</span><br><span class="line"></span><br><span class="line"># 让系统进入交互式休眠状态</span><br><span class="line">$ sudo systemctl hybrid-sleep</span><br><span class="line"></span><br><span class="line"># 启动进入救援状态（单用户状态）</span><br><span class="line">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure>
<p>systemd-analyze命令用于查看启动耗时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 查看启动耗时</span><br><span class="line">$ systemd-analyze                                                                                       </span><br><span class="line"></span><br><span class="line"># 查看每个服务的启动耗时</span><br><span class="line">$ systemd-analyze blame</span><br><span class="line"></span><br><span class="line"># 显示瀑布状的启动过程流</span><br><span class="line">$ systemd-analyze critical-chain</span><br><span class="line"></span><br><span class="line"># 显示指定服务的启动流</span><br><span class="line">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure>
<p>hostnamectl命令用于查看当前主机的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示当前主机的信息</span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"># 设置主机名。</span><br><span class="line">$ sudo hostnamectl set-hostname rhel7</span><br></pre></td></tr></table></figure>
<p>localectl命令用于查看本地化设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看本地化设置</span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line"># 设置本地化参数。</span><br><span class="line">$ sudo localectl set-locale LANG=en_GB.utf8</span><br><span class="line">$ sudo localectl set-keymap en_GB</span><br></pre></td></tr></table></figure>
<p>timedatectl命令用于查看当前时区设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看当前时区设置</span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line"># 显示所有可用的时区</span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line"># 设置当前时区</span><br><span class="line">$ sudo timedatectl set-timezone America/New_York</span><br><span class="line">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class="line">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure>
<p>loginctl命令用于查看当前登录的用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出当前session</span><br><span class="line">$ loginctl list-sessions</span><br><span class="line"></span><br><span class="line"># 列出当前登录用户</span><br><span class="line">$ loginctl list-users</span><br><span class="line"></span><br><span class="line"># 列出显示指定用户的信息</span><br><span class="line">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure>
<h3 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h3><p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Service unit：系统服务</span><br><span class="line">Target unit：多个 Unit 构成的一个组</span><br><span class="line">Device Unit：硬件设备</span><br><span class="line">Mount Unit：文件系统的挂载点</span><br><span class="line">Automount Unit：自动挂载点</span><br><span class="line">Path Unit：文件或路径</span><br><span class="line">Scope Unit：不是由 Systemd 启动的外部进程</span><br><span class="line">Slice Unit：进程组</span><br><span class="line">Snapshot Unit：Systemd 快照，可以切回某个快照</span><br><span class="line">Socket Unit：进程间通信的 socket</span><br><span class="line">Swap Unit：swap 文件</span><br><span class="line">Timer Unit：定时器</span><br></pre></td></tr></table></figure>
<p>systemctl list-units命令可以查看当前系统的所有 Unit 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出正在运行的 Unit</span><br><span class="line">$ systemctl list-units</span><br><span class="line"></span><br><span class="line"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span><br><span class="line">$ systemctl list-units --all</span><br><span class="line"></span><br><span class="line"># 列出所有没有运行的 Unit</span><br><span class="line">$ systemctl list-units --all --state=inactive</span><br><span class="line"></span><br><span class="line"># 列出所有加载失败的 Unit</span><br><span class="line">$ systemctl list-units --failed</span><br><span class="line"></span><br><span class="line"># 列出所有正在运行的、类型为 service 的 Unit</span><br><span class="line">$ systemctl list-units --type=service</span><br></pre></td></tr></table></figure>
<p>systemctl status命令用于查看系统状态和单个 Unit 的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示系统状态</span><br><span class="line">$ systemctl status</span><br><span class="line"></span><br><span class="line"># 显示单个 Unit 的状态</span><br><span class="line">$ sysystemctl status bluetooth.service</span><br><span class="line"></span><br><span class="line"># 显示远程主机的某个 Unit 的状态</span><br><span class="line">$ systemctl -H root@rhel7.example.com status httpd.service</span><br></pre></td></tr></table></figure>
<p>除了status命令，systemctl还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示某个 Unit 是否正在运行</span><br><span class="line">$ systemctl is-active application.service</span><br><span class="line"></span><br><span class="line"># 显示某个 Unit 是否处于启动失败状态</span><br><span class="line">$ systemctl is-failed application.service</span><br><span class="line"></span><br><span class="line"># 显示某个 Unit 服务是否建立了启动链接</span><br><span class="line">$ systemctl is-enabled application.service</span><br></pre></td></tr></table></figure>
<p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 立即启动一个服务</span><br><span class="line">$ sudo systemctl start apache.service</span><br><span class="line"></span><br><span class="line"># 立即停止一个服务</span><br><span class="line">$ sudo systemctl stop apache.service</span><br><span class="line"></span><br><span class="line"># 重启一个服务</span><br><span class="line">$ sudo systemctl restart apache.service</span><br><span class="line"></span><br><span class="line"># 杀死一个服务的所有子进程</span><br><span class="line">$ sudo systemctl kill apache.service</span><br><span class="line"></span><br><span class="line"># 重新加载一个服务的配置文件</span><br><span class="line">$ sudo systemctl reload apache.service</span><br><span class="line"></span><br><span class="line"># 重载所有修改过的配置文件</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 显示某个 Unit 的所有底层参数</span><br><span class="line">$ systemctl show httpd.service</span><br><span class="line"></span><br><span class="line"># 显示某个 Unit 的指定属性的值</span><br><span class="line">$ systemctl show -p CPUShares httpd.service</span><br><span class="line"></span><br><span class="line"># 设置某个 Unit 的指定属性</span><br><span class="line">$ sudo systemctl set-property httpd.service CPUShares=500</span><br></pre></td></tr></table></figure>
<p>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p>
<p>systemctl list-dependencies命令列出一个 Unit 的所有依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl list-dependencies nginx.service</span><br></pre></td></tr></table></figure>
<p>上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用–all参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl list-dependencies --all nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="Unit-的配置文件"><a href="#Unit-的配置文件" class="headerlink" title="Unit 的配置文件"></a>Unit 的配置文件</h3><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p>
<p>Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p>
<p>systemctl enable命令用于在上面两个目录之间，建立符号链接关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl enable clamd@scan.service</span><br><span class="line"># 等同于</span><br><span class="line">$ sudo ln -s &apos;/usr/lib/systemd/system/clamd@scan.service&apos; &apos;/etc/systemd/system/multi-user.target.wants/clamd@scan.service&apos;</span><br></pre></td></tr></table></figure>
<p>如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。</p>
<p>与之对应的，systemctl disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl disable clamd@scan.service</span><br></pre></td></tr></table></figure>
<p>配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。</p>
<p>systemctl list-unit-files命令用于列出所有配置文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有配置文件</span><br><span class="line">$ systemctl list-unit-files</span><br><span class="line"></span><br><span class="line"># 列出指定类型的配置文件</span><br><span class="line">$ systemctl list-unit-files --type=service</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enabled：已建立启动链接</span><br><span class="line">disabled：没建立启动链接</span><br><span class="line">static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖</span><br><span class="line">masked：该配置文件被禁止建立启动链接</span><br></pre></td></tr></table></figure>
<p><strong>配置文件的格式</strong></p>
<p>[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description：简短描述</span><br><span class="line">Documentation：文档地址</span><br><span class="line">Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</span><br><span class="line">Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</span><br><span class="line">BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</span><br><span class="line">Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</span><br><span class="line">After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</span><br><span class="line">Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行</span><br><span class="line">Condition...：当前 Unit 运行必须满足的条件，否则不会运行</span><br><span class="line">Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败</span><br></pre></td></tr></table></figure>
<p>[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中</span><br><span class="line">RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中</span><br><span class="line">Alias：当前 Unit 可用于启动的别名</span><br><span class="line">Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</span><br></pre></td></tr></table></figure>
<p>[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Type：定义启动时的进程行为。它有以下几种值。</span><br><span class="line">Type=simple：默认值，执行ExecStart指定的命令，启动主进程</span><br><span class="line">Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</span><br><span class="line">Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</span><br><span class="line">Type=dbus：当前服务通过D-Bus启动</span><br><span class="line">Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</span><br><span class="line">Type=idle：若有其他任务执行完毕，当前服务才会运行</span><br><span class="line">ExecStart：启动当前服务的命令</span><br><span class="line">ExecStartPre：启动当前服务之前执行的命令</span><br><span class="line">ExecStartPost：启动当前服务之后执行的命令</span><br><span class="line">ExecReload：重启当前服务时执行的命令</span><br><span class="line">ExecStop：停止当前服务时执行的命令</span><br><span class="line">ExecStopPost：停止当其服务之后执行的命令</span><br><span class="line">RestartSec：自动重启当前服务间隔的秒数</span><br><span class="line">Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</span><br><span class="line">TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数</span><br><span class="line">Environment：指定环境变量</span><br></pre></td></tr></table></figure>
<h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p>
<p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</p>
<p>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看当前系统的所有 Target</span><br><span class="line">$ systemctl list-unit-files --type=target</span><br><span class="line"></span><br><span class="line"># 查看一个 Target 包含的所有 Unit</span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"># 查看启动时的默认 Target</span><br><span class="line">$ systemctl get-default</span><br><span class="line"></span><br><span class="line"># 设置启动时的默认 Target</span><br><span class="line">$ sudo systemctl set-default multi-user.target</span><br><span class="line"></span><br><span class="line"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span><br><span class="line"># systemctl isolate 命令改变这种行为，</span><br><span class="line"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span><br><span class="line">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure>
<p>它与init进程的主要差别如下。</p>
<p>（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</p>
<p>（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</p>
<p>（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。</p>
<h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span><br><span class="line">$ sudo journalctl</span><br><span class="line"></span><br><span class="line"># 查看内核日志（不显示应用日志）</span><br><span class="line">$ sudo journalctl -k</span><br><span class="line"></span><br><span class="line"># 查看系统本次启动的日志</span><br><span class="line">$ sudo journalctl -b</span><br><span class="line">$ sudo journalctl -b -0</span><br><span class="line"></span><br><span class="line"># 查看上一次启动的日志（需更改设置）</span><br><span class="line">$ sudo journalctl -b -1</span><br><span class="line"></span><br><span class="line"># 查看指定时间的日志</span><br><span class="line">$ sudo journalctl --since=&quot;2012-10-30 18:17:16&quot;</span><br><span class="line">$ sudo journalctl --since &quot;20 min ago&quot;</span><br><span class="line">$ sudo journalctl --since yesterday</span><br><span class="line">$ sudo journalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;</span><br><span class="line">$ sudo journalctl --since 09:00 --until &quot;1 hour ago&quot;</span><br><span class="line"></span><br><span class="line"># 显示尾部的最新10行日志</span><br><span class="line">$ sudo journalctl -n</span><br><span class="line"></span><br><span class="line"># 显示尾部指定行数的日志</span><br><span class="line">$ sudo journalctl -n 20</span><br><span class="line"></span><br><span class="line"># 实时滚动显示最新日志</span><br><span class="line">$ sudo journalctl -f</span><br><span class="line"></span><br><span class="line"># 查看指定服务的日志</span><br><span class="line">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class="line"></span><br><span class="line"># 查看指定进程的日志</span><br><span class="line">$ sudo journalctl _PID=1</span><br><span class="line"></span><br><span class="line"># 查看某个路径的脚本的日志</span><br><span class="line">$ sudo journalctl /usr/bin/bash</span><br><span class="line"></span><br><span class="line"># 查看指定用户的日志</span><br><span class="line">$ sudo journalctl _UID=33 --since today</span><br><span class="line"></span><br><span class="line"># 查看某个 Unit 的日志</span><br><span class="line">$ sudo journalctl -u nginx.service</span><br><span class="line">$ sudo journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"># 实时滚动显示某个 Unit 的最新日志</span><br><span class="line">$ sudo journalctl -u nginx.service -f</span><br><span class="line"></span><br><span class="line"># 合并显示多个 Unit 的日志</span><br><span class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class="line"></span><br><span class="line"># 查看指定优先级（及其以上级别）的日志，共有8级</span><br><span class="line"># 0: emerg</span><br><span class="line"># 1: alert</span><br><span class="line"># 2: crit</span><br><span class="line"># 3: err</span><br><span class="line"># 4: warning</span><br><span class="line"># 5: notice</span><br><span class="line"># 6: info</span><br><span class="line"># 7: debug</span><br><span class="line">$ sudo journalctl -p err -b</span><br><span class="line"></span><br><span class="line"># 日志默认分页输出，--no-pager 改为正常的标准输出</span><br><span class="line">$ sudo journalctl --no-pager</span><br><span class="line"></span><br><span class="line"># 以 JSON 格式（单行）输出</span><br><span class="line">$ sudo journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"># 以 JSON 格式（多行）输出，可读性更好</span><br><span class="line">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class="line"> -o json-pretty</span><br><span class="line"></span><br><span class="line"># 显示日志占据的硬盘空间</span><br><span class="line">$ sudo journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"># 指定日志文件占据的最大空间</span><br><span class="line">$ sudo journalctl --vacuum-size=1G</span><br><span class="line"></span><br><span class="line"># 指定日志文件保存多久</span><br><span class="line">$ sudo journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat系统架构及实现</title>
    <url>/2019/10/02/tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>1.Tomcat 要实现 2 个核心功能:</p>
<ul>
<li>处理 Socket 连接，负责网络字节流与 Request 和 Response 对象的转化。</li>
<li>加载和管理 Servlet，以及具体处理 Request 请求。</li>
</ul>
<p>因此 Tomcat 设计了两个核心组件连接器(Connector)和容器(Container)来分别做 这两件事情。连接器负责对外交流，容器负责内部处理。</p>
<p>2.Tomcat 支持的 I/O 模型有:</p>
<ul>
<li>NIO:非阻塞 I/O，采用 Java NIO 类库实现。</li>
<li>NIO2:异步 I/O，采用 JDK 7 最新的 NIO2 类库实现。</li>
<li>APR:采用 Apache 可移植运行库实现，是 C/C++ 编写的本地库。</li>
</ul>
<p>3.Tomcat 支持的应用层协议有:</p>
<ul>
<li>HTTP/1.1:这是大部分 Web 应用采用的访问协议。 </li>
<li>AJP:用于和 Web 服务器集成(如 Apache)。 </li>
<li>HTTP/2:HTTP 2.0 大幅度的提升了 Web 性能。</li>
</ul>
<p>Tomcat 为了实现支持多种 I/O 模型和应用层协议，一个容器可能对接多个连接器，就好比 一个房间有多个门。但是单独的连接器或者容器都不能对外提供服务，需要把它们组装起来 才能工作，组装后这个整体叫作 Service 组件。<br><img src="/2019/10/02/tomcat系统架构及实现/tomcat1.png" alt="avatar"><br>从图上你可以看到，最顶层是 Server，这里的 Server 指的就是一个 Tomcat 实例。一个 Server 中有一个或者多个 Service，一个 Service 中有多个连接器和一个容器。连接器与容 器之间通过标准的 ServletRequest 和 ServletResponse 通信。</p>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>1.主要功能</p>
<ol>
<li>连接器功能</li>
<li>监听网络端口。</li>
<li>接受网络连接请求。</li>
<li>读取请求网络字节流。</li>
<li>根据具体应用层协议(HTTP/AJP)解析字节流，生成统一的 Tomcat Request 对象。 将 Tomcat Request 对象转成标准的 ServletRequest。</li>
<li>调用 Servlet 容器，得到 ServletResponse。</li>
<li>将 ServletResponse 转成 Tomcat Response 对象。</li>
<li>将 Tomcat Response 转成网络字节流。 </li>
<li>将响应字节流写回给浏览器。</li>
</ol>
<p>通过分析连接器的详细功能列表，我们发现连接器需要完成 3 个高内聚的功能:</p>
<ul>
<li>网络通信。</li>
<li>应用层协议解析。</li>
<li>Tomcat Request/Response 与 ServletRequest/ServletResponse 的转化。</li>
</ul>
<p>因此 Tomcat 的设计者设计了 3 个组件来实现这 3 个功能，分别是 EndPoint、Processor 和 Adapter。EndPoint 负责提供字节流给 Processor，Processor 负责 提供 Tomcat Request 对象给 Adapter，Adapter 负责提供 ServletRequest 对象给容器。其中 Endpoint 和 Processor 放在一起抽象成了 ProtocolHandler 组件，它们的关系如下图所示。<br><img src="/2019/10/02/tomcat系统架构及实现/tomcat2.png" alt="avatar"></p>
<p>2.ProtocolHandler 组件<br>连接器用 ProtocolHandler 来处理网络连接和应用层协议，包含了 2 个 重要部件:EndPoint 和 Processor。EndPoint 是通信端点，即通信监听的接口，是具体的 Socket 接收和发送处理器，是对传输层的抽象，因此 EndPoint 是用来实现 TCP/IP 协议的。如果说 EndPoint 是用来实现 TCP/IP 协议的，那么 Processor 用来实现 HTTP 协议， Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat Request 和Response对象，并通过 Adapter 将其提交到容器处理，Processor 是对应用层协议的抽象。<br>EndPoint 是一个接口，对应的抽象实现类是 AbstractEndpoint，而 AbstractEndpoint 的具体子类，比如在 NioEndpoint 和 Nio2Endpoint 中，有两个重要的子组件: Acceptor 和 SocketProcessor。其中 Acceptor 用于监听 Socket 连接请求。SocketProcessor 用于处理接收到的 Socket 请求，它实现 Runnable 接口，在 Run 方法里调用协议处理组件 Processor 进行处理。为 了提高处理能力，SocketProcessor 被提交到线程池来执行。而这个线程池叫作执行器 (Executor)。Processor 是一个接口，定义了请求的处理等方法。它的抽象实现类 AbstractProcessor 对一些协议共有的属性进行封装，没有对方法进行实现。具体的实现有 AJPProcessor、 HTTP11Processor 等，这些具体实现类实现了特定协议的解析方法和请求处理方式。<br><img src="/2019/10/02/tomcat系统架构及实现/tomcat3.png" alt="avatar"><br>从图中我们看到，EndPoint 接收到 Socket 连接后，生成一个 SocketProcessor 任务提交 到线程池去处理，SocketProcessor 的 Run 方法会调用 Processor 组件去解析应用层协 议，Processor 通过解析生成 Request 对象后，会调用 Adapter 的 Service 方法。</p>
<p>3.Adapter 组件<br>Tomcat 定义了自己 的 Request 类来“存放”这些请求信息。ProtocolHandler 接口负责解析请求并生成 Tomcat Request 类。但是这个 Request 对象不是标准的 ServletRequest，也就意味着， 不能用 Tomcat Request 作为参数来调用容器。Tomcat 设计者的解决方案是引入 CoyoteAdapter，这是适配器模式的经典运用，连接器调用 CoyoteAdapter 的 Sevice 方法，传入的是 Tomcat Request 对象，CoyoteAdapter 负责将 Tomcat Request 转成 ServletRequest，再调用容器的 Service 方法。</p>
<h4 id="多层容器"><a href="#多层容器" class="headerlink" title="多层容器"></a>多层容器</h4><p>1.容器的层次结构<br><img src="/2019/10/02/tomcat系统架构及实现/tomcat4.png" alt="avatar"><br>Context 表示一个 Web 应用程序;Wrapper 表示一个 Servlet，一个 Web 应用程序中可 能会有多个 Servlet;Host 代表的是一个虚拟主机，或者说一个站点，可以给 Tomcat 配 置多个虚拟主机地址，而一个虚拟主机下可以部署多个 Web 应用程序;Engine 表示引 擎，用来管理多个虚拟站点，一个 Service 最多只能有一个 Engine。<br>Tomcat 就是用组合模式来管理 这些容器的。具体实现方法是，所有容器组件都实现了 Container 接口，因此组合模式可 以使得用户对单容器对象和组合容器对象的使用具有一致性。这里单容器对象指的是最底层 的 Wrapper，组合容器对象指的是上面的 Context、Host 或者 Engine。Container 接口 定义如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Container extends Lifecycle &#123;</span><br><span class="line">    public void setName(String name);</span><br><span class="line">    public Container getParent();</span><br><span class="line">    public void setParent(Container container);</span><br><span class="line">    public void addChild(Container child);</span><br><span class="line">    public void removeChild(Container child);</span><br><span class="line"> 	public Container findChild(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.请求定位 Servlet 的过程</p>
<p>Tomcat 是用Mapper组件来完成这个任务的。Mapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是:Mapper 件里保存了Web 应用的配置信息，其实就是容器组件与访问路径的映射关系， 比如Host容器里配置的域名、Context容器里的Web应用路径，以及Wrapper容器里Servlet 映射的路径，你可以想象这些配置信息就是一个多层次的Map。<br>首先，根据协议和端口号选定Service和Engine。Tomcat的每个连接器都监听不同的端口，比如Tomcat默认的HTTP连接器监听8080端口、默认的AJP连接器监听8009 端口。上面例子中的 URL 访问的是 8080 端 口，因此这个请求会被 HTTP 连接器接收，而一个连接器是属于一个 Service 组件的，这样 Service组件就确定了。我们还知道一个Service组件里除了有多个连接器，还有一个容器组件，具体来说就是一个Engine容器，因此Service确定了也就意味着 Engine也确定了。然后根据域名选定Host。之后根据URL路径找到Context组件。最后根据URL路径找到Wrapper(Servlet)。Context确定后，Mapper再根据 web.xml中配置的Servlet映射路径来找到具体的Wrapper和Servlet。<br>需要注意的是，并不是说只有Servlet才会去处理请求，实际上这个查找路径上的父子容器都会对请求做一些处理。连接器中的Adapter会调用容器的Service 方法来执行 Servlet，最先拿到请求的是Engine容器，Engine 容器对请求做一些处理后，会把请求传给自己子容器 Host继续处理，依次类推，最后这个请求会传给 Wrapper容器，Wrapper会调用最终的Servlet 来处理。<br>那么这个调用过程具体是怎么实现的呢?答案是使用Pipeline-Valve管道。Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者 继续处理。Valve表示一个处理点，比如权限认证和记录日志。如果你还不太理解的话，可以来看看Valve和Pipeline接口中的关键方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Valve &#123;</span><br><span class="line"> public Valve getNext();</span><br><span class="line"> public void setNext(Valve valve);</span><br><span class="line"> public void invoke(Request request, Response response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于Valve是一个处理点，因此invoke方法就是来处理请求的。注意到Valve中有getNext和setNext方法，因此我们大概可以猜到有一个链表将Valve链起来了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Pipeline extends Contained &#123;</span><br><span class="line">	public void addValve(Valve valve);</span><br><span class="line">	public Valve getBasic();</span><br><span class="line">	public void setBasic(Valve valve);</span><br><span class="line">	public Valve getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个调用过程由连接器中的 Adapter 触发的，它会调用 Engine 的第一个 Valve:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connector.getService().getContainer().getPipeline().getFirst().invoke(request, response)</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/10/02/tomcat系统架构及实现/tomcat5.png" alt="avatar"></p>
<p>Valve是Tomcat的私有机制，与Tomcat的基础架构/API是紧耦合的。Servlet API是公有的标准，所有的Web容器包括Jetty都支持Filter机制。另一个重要的区别是 Valve 工作在 Web 容器级别，拦截所有应用的请求;而Servlet Filter工作在应用级别，只能拦截某个Web应用的所有请求。如果想做整个Web容器 的拦截器，必须通过 Valve 来实现。</p>
]]></content>
      <tags>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>uWSGI和Gunicorn的对比小结</title>
    <url>/2021/06/23/uWSGI%E5%92%8CGunicorn%E7%9A%84%E5%AF%B9%E6%AF%94%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>由于uWGSI使用的是GPL2开源协议，Gunicorn使用的是MIT协议，商业使用为了规避相关法律风险，业务上有打算把uWSGI替换成Gunicorn，小结下两种组件的使用及区别。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>相同点</strong></p>
<p>perfork是一种服务端编程模型, Nginx, Gunicorn, uWSGI都是这种模型的实现, 简单的说perfok就是master进程启动注册一堆信号处理函数, 创建listen socket fd, fork出多个worker子进程, 子进程执行accept循环处理请求(这里简化模型, 当然也可以用select, epoll多路复用), master进程只负责监控worker进程状态, 通过pipeline通信来控制worker进程.</p>
<p>perfork模型使用master进程来监控worker进程状态, 避免了我们使用supervisor来监控进程, 还支持多种信号来控制worker的数量, 使得CPU能充分得到利用, 多个worker进程监听同一端口, 可以配置reuse_port参数在worker进程间负载均衡.</p>
<p><strong>区别</strong></p>
<p>Gunicorn</p>
<p>Gunicorn是使用Python实现的WSGI服务器, 直接提供了http服务, 并且在woker上提供了多种选择, gevent, eventlet这些都支持, 在多worker最大化里用CPU的同时, 还可以使用协程来提供并发支撑, 对于网络IO密集的服务比较有利.</p>
<p>同时Gunicorn也很容易就改造成一个TCP的服务, 比如doge重写worker类, 在针对长连接的服务时, 最好开启reuse_port, 避免worker进程负载不均。</p>
<p>uWSGI</p>
<p>不同于Gunicorn, uWSGI是使用C写的, 它的socket fd创建, worker进程的启动都是使用C语言系统接口来实现的, 在worker进程处理循环中, 解析了http请求后, 使用python的C接口生成environ对象, 再把这个对象作为参数塞到暴露出来的WSGI application函数中调用. 而这一切都是在C程序中进行, 只是在处理请求的时候交给python虚拟机调用application. 完全使用C语言实现的好处是性能会好一些.</p>
<p>除了支持http协议, uWSGI还实现了uwsgi协议, 一般我们会在uWSGI服务器前面使用Nginx作为负载均衡, 如果使用http协议, 请求在转发到uWSGI前已经在Nginx这里解析了一遍, 转发到uWSGI又会重新解析一遍. uWSGI为了追求性能, 设计了uwsgi协议, 在Nginx解析完以后直接把解析好的结果通过uwsgi协议转发到uWSGI服务器, uWSGI拿到请求按格式生成environ对象, 不需要重复解析请求. 如果用Nginx配合uWSGI, 最好使用uwsgi协议来转发请求.</p>
<p>除了是一个WSGI服务器, uWSGI还是一个开发框架, 它提供了缓存, 队列, rpc等等功能, 在github找找就会发现有人用它的缓存写了一个Django cache backend, 用它的队列实现异步任务这些东西, 但是用了这些东西技术栈也就跟uWSGI绑定在一起, 所以一般也只是把uWSGI当作WSGI服务器来用。</p>
<h4 id="测试对比"><a href="#测试对比" class="headerlink" title="测试对比"></a>测试对比</h4><p>组里其他同学测试简单测试如下：</p>
<p><img src="/2021/06/23/uWSGI和Gunicorn的对比小结/uwsgi.png" alt="avatar"></p>
<p>与<a href="http://www.zh-noone.cn/2019/11/gunicorn-uwsgi%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/" target="_blank" rel="noopener">http://www.zh-noone.cn/2019/11/gunicorn-uwsgi%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</a> 文章中测试结果大体一致。其中该文章中总结使用方式如下：</p>
<p><strong>gunicorn小结</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">werkzeug:RPS:681.30/sec</span><br><span class="line"></span><br><span class="line">sync:RPS:615.97/sec</span><br><span class="line"></span><br><span class="line">gevent:RPS:1030.56/sec</span><br><span class="line"></span><br><span class="line">eventlet(preload模式):RPS:616.65/sec</span><br><span class="line"></span><br><span class="line">eventlet(非preload模式):1048.65/sec</span><br></pre></td></tr></table></figure>
<p><strong>uwsgi小结</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打印日志:RPS:1605.11/sec</span><br><span class="line"></span><br><span class="line">不打印日志(preload模式):RPS:1868.42/sec</span><br><span class="line"></span><br><span class="line">不打印日志(非preload模式):RPS:1433.42/sec</span><br><span class="line"></span><br><span class="line">gunicorn+nginx+eventlet:RPS:1030.56/sec</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunicorn 最好使用eventlet(非preload模式)</span><br><span class="line"></span><br><span class="line">uwsgi+nginx 最好使用不打印日志(preload模式)</span><br><span class="line"></span><br><span class="line">gunicorn与uwsgi比较最好使用uwsgi</span><br></pre></td></tr></table></figure>
<h4 id="Gunicorn简介"><a href="#Gunicorn简介" class="headerlink" title="Gunicorn简介"></a>Gunicorn简介</h4><p>Gunicorn，是一个针对Python的、在Unix系统上运行的、用来解析HTTP请求的网关服务。它的特点是：能和大多数的Python web框架兼容；使用简单；轻量级的资源消耗；高性能。</p>
<p><strong>Sync Workers（同步workers）</strong></p>
<p><img src="/2021/06/23/uWSGI和Gunicorn的对比小结/gun1.png" alt="avatar"></p>
<p>默认的、最简单的worker模式，是同步模式。</p>
<p>每个worker进程，一次只处理一个请求；如果此时又有其他请求被分配到这个worker进程，那只好被阻塞了，要先等第一个请求完成 。并且，一个请求一个进程，并发时，显然很占CPU和内存。</p>
<p>因此，只适合在访问量不大、CPU密集而非I/O密集的情形。</p>
<p>不过也不是没有好处；好处是，即使一个worker进程crash了，也只会影响一个请求。</p>
<p><strong>Async Workers（异步workers）</strong></p>
<p><img src="/2021/06/23/uWSGI和Gunicorn的对比小结/gun2.png" alt="avatar"></p>
<p>有Gevent和Eventlet两种，都是基于Greenlet实现的。</p>
<p>用了异步worker，就能同时处理不止一个请求，就不会出现上面同步worker那样，一个请求就把后续请求都block阻塞住的情况了。</p>
<p>Gevent是一个Python网络函数库，它通过Greenlet协程+libev快速事件循环，实现了异步模型。有了Gevent，切换Greenlet时就不再需要手动切换，而是当一个Greenlet遇到I/O时，Gevent能自动切换Greenlet，保证总有Greenlet在运行，而无需等待I/O。</p>
<p>异步worker是怎样实现并发，使得一个worker就能同时处理很多请求的呢？</p>
<p>以Gevent为例，每个请求的连接是一个Greenlet协程。Gevent虽然只有一个线程、同时只能处理一个请求，但是在这个请求的异步事件没准备好、进入IO等待时，能主动yield让出控制权、而不是阻塞其他请求的协程，而是先让其他协程执行，当自己的IO准备好时，事件循环会将它从yield让出控制权的地方，继续恢复执行。</p>
<p>这样，Gevent就能在不同请求间不断切换，从而实现并发，以充分利用CPU、减少IO等待。并且，因为切换的Greenlet是“微线程”，它操作的维度是函数，而不是线程/进程，所以来回切换的开销，就没有那么大。</p>
<p>就我个人理解，同步worker和Gevent异步worker，这两种worker类型是最常用的。一般来说，我们的web app多半属于外部IO密集型（总要访问db、访问第三方服务等等），所以用Gunicorn的Gevent异步worker，就非常合理。</p>
<p>而如果你的web app是CPU密集型，或者你希望请求之间不要互相影响，那么可以选择Gunicorn的同步worker。</p>
<p><strong>Tornado Workers</strong></p>
<p>用来配合Tornado使用。</p>
<p>Tornado是一个Python框架和网络库，可以提供异步IO非阻塞型模型，来处理长延时请求。</p>
<p><img src="/2021/06/23/uWSGI和Gunicorn的对比小结/gun3.png" alt="avatar"></p>
<p><strong>AsyncIO Workers</strong></p>
<p>分成gthread和gaiohttp两种模式。</p>
<p>gaiohttp利用aiohttp库，在服务端和客户端执行异步IO操作。支持web socket。</p>
<p>gthread是一种全线程worker，worker与线程池保持连接，线程会等待接收请求，一个请求一个线程。在Gunicorn启动时，除了可配置worker进程数，还可以配每个进程里的thread线程数。</p>
<p><img src="/2021/06/23/uWSGI和Gunicorn的对比小结/gun4.png" alt="avatar"></p>
<h4 id="Gunicorn是怎样实现高并发的"><a href="#Gunicorn是怎样实现高并发的" class="headerlink" title="Gunicorn是怎样实现高并发的"></a>Gunicorn是怎样实现高并发的</h4><p>Gunicorn启动时，就把worker进程预先fork出来了。当多个请求到来的时候，会轮流复用这些worker进程，从而能提高服务器的并发负载能力。至于worker数的配置，一般推荐2<em>CPU数+1。这样推荐，背后的想法是，在任何时间，都有大概一半的worker是在做I/O，剩下一半才是需要CPU的。如果在开多进程的同时，也开多线程（也就是选择gthread类型的worker），那么，配置总的并发数（worker进程数</em>线程数），仍然建议2*CPU数+1。</p>
<p>flask+Gunicorn(gevent)高并发的解决方法探究如下：</p>
<p>方案一：使用gevent做协程，从而解决高并发的问题，通过Gunicorn(with gevent)的形式对app进行包装，从而来启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用gevent做异步（默认worker是同步的）    多进程+协程</span><br><span class="line">gunicorn -w 8 --bind 0.0.0.0:8000 -k &apos;gevent&apos; 运行文件名称:Flask程序实例名</span><br><span class="line"></span><br><span class="line"># 使用gunicorn命令启动flask项目 </span><br><span class="line"># -w 8 </span><br><span class="line">	8个进程</span><br><span class="line"># --bind 0.0.0.0:8000 </span><br><span class="line">	ip + 端口</span><br><span class="line"># -k &apos;gevent&apos;</span><br><span class="line">	协程</span><br></pre></td></tr></table></figure>
<p>方案二： 将运行的信息加载到配置文件中</p>
<p>使用gunicorn + gevent 开启高并发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 多进程</span><br><span class="line">import multiprocessing </span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;gunicorn+gevent 的配置文件&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 预加载资源</span><br><span class="line">preload_app = True</span><br><span class="line"># 绑定 ip + 端口</span><br><span class="line">bind = &quot;0.0.0.0:5000&quot;</span><br><span class="line"># 进程数 = cup数量 * 2 + 1</span><br><span class="line">workers = multiprocessing.cpu_count() * 2 + 1</span><br><span class="line"></span><br><span class="line"># 线程数 = cup数量 * 2 </span><br><span class="line">threads = multiprocessing.cpu_count() * 2</span><br><span class="line"></span><br><span class="line"># 等待队列最大长度,超过这个长度的链接将被拒绝连接</span><br><span class="line">backlog = 2048</span><br><span class="line"></span><br><span class="line"># 工作模式--协程</span><br><span class="line">worker_class = &quot;gevent&quot;</span><br><span class="line"></span><br><span class="line"># 最大客户客户端并发数量,对使用线程和协程的worker的工作有影响</span><br><span class="line"># 服务器配置设置的值  1200：中小型项目  上万并发： 中大型</span><br><span class="line"># 服务器硬件：宽带+数据库+内存</span><br><span class="line"># 服务器的架构：集群 主从</span><br><span class="line">worker_connections = 1200</span><br><span class="line"></span><br><span class="line"># 进程名称</span><br><span class="line">proc_name = &apos;gunicorn.pid&apos;</span><br><span class="line"># 进程pid记录文件</span><br><span class="line">pidfile = &apos;app_run.log&apos;</span><br><span class="line"># 日志等级</span><br><span class="line">loglevel = &apos;debug&apos;</span><br><span class="line"># 日志文件名</span><br><span class="line">logfile = &apos;debug.log&apos;</span><br><span class="line"># 访问记录</span><br><span class="line">accesslog = &apos;access.log&apos;</span><br><span class="line"># 访问记录格式</span><br><span class="line">access_log_format = &apos;%(h)s %(t)s %(U)s %(q)s&apos;</span><br></pre></td></tr></table></figure>
<p>执行 ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunicorn -c gunicorn_config.py flask_server:app</span><br></pre></td></tr></table></figure></p>
<p><strong>协程 第三方封装库</strong></p>
<p>gevent = greenlet + python.monkey（底层使用 libevent 时间复杂度： O(N * logN)）</p>
<p>meinheld = greenlet + picoev (时间复杂度： O(N) )</p>
<p>eventlet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">meinheld和gevent都能实现异步，但是测评中meinheld比gevent的性能好很多，不过因为meinheld支持的比较少，一般都是配合gunicorn使用的。下面分析一下meinheld和gevent性能差距主要原因，分别使用的是picoev和lievent。</span><br><span class="line"></span><br><span class="line"># libevent</span><br><span class="line">主要实现：使用堆（优先队列）作为timer事件的算法（nlogn）,IO和信号的实现均使用了双向队列（用链表实现）。</span><br><span class="line">时间复杂度： O(N * logN)</span><br><span class="line"></span><br><span class="line"># picoev</span><br><span class="line">picoev主要优化有两点。 </span><br><span class="line">1. 主要是考虑是fd（file descriptors）在unix中是用比较小的正整数表示的，那么把fd的相关信息，全部存储在一个array中，这样使得查找快速，在操作socket状态时会更加的快。 </span><br><span class="line"></span><br><span class="line">2. 第二点是对于timer事件的算法优化，通过环形缓冲区(128)和bit vector实现查看部分源码可以看出，主要实现是每个时间点对应的是缓冲区的一个位置，每个缓存区使用bit vector 表示fd的数值，相当于一种hash映射所以时间复杂度为(o(n))，n为那个缓存区所存的fd数量。</span><br><span class="line"></span><br><span class="line">时间复杂度： O(N)</span><br><span class="line"></span><br><span class="line">性能： picoev &gt; libevent</span><br></pre></td></tr></table></figure>
<h4 id="Gunicorn源码概览"><a href="#Gunicorn源码概览" class="headerlink" title="Gunicorn源码概览"></a>Gunicorn源码概览</h4><p>gunicorn源码的入口文件为<strong>main</strong>.py<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from gunicorn.app.wsgiapp import run</span><br><span class="line">run()</span><br></pre></td></tr></table></figure></p>
<p>在初始化加载相关配置文件后，调用 Arbiter(self).run()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def run(self):</span><br><span class="line">    &quot;Main master loop.&quot;</span><br><span class="line">    self.start()</span><br><span class="line">    util._setproctitle(&quot;master [%s]&quot; % self.proc_name)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        self.manage_workers()</span><br><span class="line"></span><br><span class="line">        while True:</span><br><span class="line">            self.maybe_promote_master()</span><br><span class="line"></span><br><span class="line">            sig = self.SIG_QUEUE.pop(0) if self.SIG_QUEUE else None</span><br><span class="line">            if sig is None:</span><br><span class="line">                self.sleep()</span><br><span class="line">                self.murder_workers()</span><br><span class="line">                self.manage_workers()</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">            if sig not in self.SIG_NAMES:</span><br><span class="line">                self.log.info(&quot;Ignoring unknown signal: %s&quot;, sig)</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">            signame = self.SIG_NAMES.get(sig)</span><br><span class="line">            handler = getattr(self, &quot;handle_%s&quot; % signame, None)</span><br><span class="line">            if not handler:</span><br><span class="line">                self.log.error(&quot;Unhandled signal: %s&quot;, signame)</span><br><span class="line">                continue</span><br><span class="line">            self.log.info(&quot;Handling signal: %s&quot;, signame)</span><br><span class="line">            handler()</span><br><span class="line">            self.wakeup()</span><br><span class="line">    except (StopIteration, KeyboardInterrupt):</span><br><span class="line">        self.halt()</span><br><span class="line">    except HaltServer as inst:</span><br><span class="line">        self.halt(reason=inst.reason, exit_status=inst.exit_status)</span><br><span class="line">    except SystemExit:</span><br><span class="line">        raise</span><br><span class="line">    except Exception:</span><br><span class="line">        self.log.info(&quot;Unhandled exception in main loop&quot;,</span><br><span class="line">                      exc_info=True)</span><br><span class="line">        self.stop(False)</span><br><span class="line">        if self.pidfile is not None:</span><br><span class="line">            self.pidfile.unlink()</span><br><span class="line">        sys.exit(-1)</span><br></pre></td></tr></table></figure>
<p>其中self.start()会根据配置文件加载相关运行信息，包括worker工作方式。在manage_workers代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def manage_workers(self):</span><br><span class="line">    &quot;&quot;&quot;\</span><br><span class="line">    Maintain the number of workers by spawning or killing</span><br><span class="line">    as required.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if len(self.WORKERS) &lt; self.num_workers:</span><br><span class="line">        self.spawn_workers()</span><br><span class="line"></span><br><span class="line">    workers = self.WORKERS.items()</span><br><span class="line">    workers = sorted(workers, key=lambda w: w[1].age)</span><br><span class="line">    while len(workers) &gt; self.num_workers:</span><br><span class="line">        (pid, _) = workers.pop(0)</span><br><span class="line">        self.kill_worker(pid, signal.SIGTERM)</span><br><span class="line"></span><br><span class="line">    active_worker_count = len(workers)</span><br><span class="line">    if self._last_logged_active_worker_count != active_worker_count:</span><br><span class="line">        self._last_logged_active_worker_count = active_worker_count</span><br><span class="line">        self.log.debug(&quot;&#123;0&#125; workers&quot;.format(active_worker_count),</span><br><span class="line">                       extra=&#123;&quot;metric&quot;: &quot;gunicorn.workers&quot;,</span><br><span class="line">                              &quot;value&quot;: active_worker_count,</span><br><span class="line">                              &quot;mtype&quot;: &quot;gauge&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>在spawn_worker中有初始化进程代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def spawn_worker(self):</span><br><span class="line">       self.worker_age += 1</span><br><span class="line">       worker = self.worker_class(self.worker_age, self.pid, self.LISTENERS,</span><br><span class="line">                                  self.app, self.timeout / 2.0,</span><br><span class="line">                                  self.cfg, self.log)</span><br><span class="line">       self.cfg.pre_fork(self, worker)</span><br><span class="line">       pid = os.fork()</span><br><span class="line">       if pid != 0:</span><br><span class="line">           worker.pid = pid</span><br><span class="line">           self.WORKERS[pid] = worker</span><br><span class="line">           return pid</span><br><span class="line"></span><br><span class="line">       # Do not inherit the temporary files of other workers</span><br><span class="line">       for sibling in self.WORKERS.values():</span><br><span class="line">           sibling.tmp.close()</span><br><span class="line"></span><br><span class="line">       # Process Child</span><br><span class="line">       worker.pid = os.getpid()</span><br><span class="line">       try:</span><br><span class="line">           util._setproctitle(&quot;worker [%s]&quot; % self.proc_name)</span><br><span class="line">           self.log.info(&quot;Booting worker with pid: %s&quot;, worker.pid)</span><br><span class="line">           self.cfg.post_fork(self, worker)</span><br><span class="line">           worker.init_process()</span><br><span class="line">           sys.exit(0)</span><br><span class="line">       except SystemExit:</span><br><span class="line">           raise</span><br><span class="line">       except AppImportError as e:</span><br><span class="line">           self.log.debug(&quot;Exception while loading the application&quot;,</span><br><span class="line">                          exc_info=True)</span><br><span class="line">           print(&quot;%s&quot; % e, file=sys.stderr)</span><br><span class="line">           sys.stderr.flush()</span><br><span class="line">           sys.exit(self.APP_LOAD_ERROR)</span><br><span class="line">       except Exception:</span><br><span class="line">           self.log.exception(&quot;Exception in worker process&quot;)</span><br><span class="line">           if not worker.booted:</span><br><span class="line">               sys.exit(self.WORKER_BOOT_ERROR)</span><br><span class="line">           sys.exit(-1)</span><br><span class="line">       finally:</span><br><span class="line">           self.log.info(&quot;Worker exiting (pid: %s)&quot;, worker.pid)</span><br><span class="line">           try:</span><br><span class="line">               worker.tmp.close()</span><br><span class="line">               self.cfg.worker_exit(self, worker)</span><br><span class="line">           except Exception:</span><br><span class="line">               self.log.warning(&quot;Exception during worker exit:\n%s&quot;,</span><br><span class="line">                                traceback.format_exc())</span><br></pre></td></tr></table></figure>
<p>在init_process中就能够选择不同类型的worker了。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://pypi.org/project/gunicorn/" target="_blank" rel="noopener">https://pypi.org/project/gunicorn/</a></li>
<li><a href="https://www.cnblogs.com/xuegqcto/p/10411943.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuegqcto/p/10411943.html</a></li>
<li><a href="http://www.zh-noone.cn/2019/11/gunicorn-uwsgi%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/" target="_blank" rel="noopener">http://www.zh-noone.cn/2019/11/gunicorn-uwsgi%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</a></li>
<li><a href="https://blog.csdn.net/dadajuan_plus/article/details/106571287" target="_blank" rel="noopener">https://blog.csdn.net/dadajuan_plus/article/details/106571287</a></li>
<li><a href="https://blog.csdn.net/weixin_46072106/article/details/109708788" target="_blank" rel="noopener">https://blog.csdn.net/weixin_46072106/article/details/109708788</a></li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性hash算法</title>
    <url>/2019/08/11/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="简单hash算法在缓存中常见问题"><a href="#简单hash算法在缓存中常见问题" class="headerlink" title="简单hash算法在缓存中常见问题"></a>简单hash算法在缓存中常见问题</h4><ol>
<li>当缓存服务器数量发生变化时，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）。</li>
<li>当缓存服务器数量发生变化时，几乎所有缓存的位置都会发生改变，怎样才能尽量减少受影响的缓存呢？</li>
</ol>
<h4 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h4><p>一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：<br><img src="/2019/08/11/一致性hash算法/hash.png" alt="avatar"><br>整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p>
<p>下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：<br><img src="/2019/08/11/一致性hash算法/hash2.png" alt="avatar"><br>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！<br>例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：<br><img src="/2019/08/11/一致性hash算法/hash3.png" alt="avatar"><br>根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p>
<h4 id="一致性hash算法的容错性和可扩展性"><a href="#一致性hash算法的容错性和可扩展性" class="headerlink" title="一致性hash算法的容错性和可扩展性"></a>一致性hash算法的容错性和可扩展性</h4><p>现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示：<br><img src="/2019/08/11/一致性hash算法/hash4.png" alt="avatar"><br>下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：<br><img src="/2019/08/11/一致性hash算法/hash5.png" alt="avatar"><br>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p>
<p>综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
<h4 id="Hash环的数据倾斜问题"><a href="#Hash环的数据倾斜问题" class="headerlink" title="Hash环的数据倾斜问题"></a>Hash环的数据倾斜问题</h4><p>一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下：</p>
<p>此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。<br><img src="/2019/08/11/一致性hash算法/hash6.png" alt="avatar"><br>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：<br><img src="/2019/08/11/一致性hash算法/hash7.png" alt="avatar"><br>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>
<h4 id="一致性hash算法java实现"><a href="#一致性hash算法java实现" class="headerlink" title="一致性hash算法java实现"></a>一致性hash算法java实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不带虚拟节点</span><br><span class="line">package com.learn.hash;</span><br><span class="line"></span><br><span class="line">import java.util.SortedMap;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class ConsistentHashingWithoutVirtualNode &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //待添加入Hash环的服务器列表</span><br><span class="line">    private static String[] servers = &#123;&quot;192.168.0.0:111&quot;, &quot;192.168.0.1:111&quot;,</span><br><span class="line">            &quot;192.168.0.2:111&quot;, &quot;192.168.0.3:111&quot;, &quot;192.168.0.4:111&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    //key表示服务器的hash值，value表示服务器</span><br><span class="line">    private static SortedMap&lt;Integer, String&gt; sortedMap = new TreeMap&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line">    //程序初始化，将所有的服务器放入sortedMap中</span><br><span class="line">    static &#123;</span><br><span class="line">        for (int i = 0; i &lt; servers.length; i++) &#123;</span><br><span class="line">            int hash = getHash(servers[i]);</span><br><span class="line">            System.out.println(&quot;[&quot; + servers[i] + &quot;]加入集合中, 其Hash值为&quot; + hash);</span><br><span class="line">            sortedMap.put(hash, servers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String getServer(String key) &#123;</span><br><span class="line">        //得到该key的hash值</span><br><span class="line">        int hash = getHash(key);</span><br><span class="line">        //得到大于该Hash值的所有Map</span><br><span class="line">        SortedMap&lt;Integer, String&gt; subMap = sortedMap.tailMap(hash);</span><br><span class="line">        if (subMap.isEmpty()) &#123;</span><br><span class="line">            //如果没有比该key的hash值大的，则从第一个node开始</span><br><span class="line">            Integer i = sortedMap.firstKey();</span><br><span class="line">            //返回对应的服务器</span><br><span class="line">            return sortedMap.get(i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">            Integer i = subMap.firstKey();</span><br><span class="line">            //返回对应的服务器</span><br><span class="line">            return subMap.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别</span><br><span class="line">    private static int getHash(String str) &#123;</span><br><span class="line">        final int p = 16777619;</span><br><span class="line">        int hash = (int) 2166136261L;</span><br><span class="line">        for (int i = 0; i &lt; str.length(); i++)</span><br><span class="line">            hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">        hash += hash &lt;&lt; 13;</span><br><span class="line">        hash ^= hash &gt;&gt; 7;</span><br><span class="line">        hash += hash &lt;&lt; 3;</span><br><span class="line">        hash ^= hash &gt;&gt; 17;</span><br><span class="line">        hash += hash &lt;&lt; 5;</span><br><span class="line"></span><br><span class="line">        // 如果算出来的值为负数则取其绝对值</span><br><span class="line">        if (hash &lt; 0)</span><br><span class="line">            hash = Math.abs(hash);</span><br><span class="line">        return hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] keys = &#123;&quot;太阳&quot;, &quot;月亮&quot;, &quot;星星&quot;&#125;;</span><br><span class="line">        for (int i = 0; i &lt; keys.length; i++)</span><br><span class="line">            System.out.println(&quot;[&quot; + keys[i] + &quot;]的hash值为&quot; + getHash(keys[i])</span><br><span class="line">                    + &quot;, 被路由到结点[&quot; + getServer(keys[i]) + &quot;]&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">带虚拟节点</span><br><span class="line">package com.learn.hash;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.SortedMap;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class ConsistentHashingWithVirtualNode &#123;</span><br><span class="line"></span><br><span class="line">    //待添加入Hash环的服务器列表</span><br><span class="line">    private static String[] servers = &#123;&quot;192.168.0.0:111&quot;, &quot;192.168.0.1:111&quot;, &quot;192.168.0.2:111&quot;,</span><br><span class="line">            &quot;192.168.0.3:111&quot;, &quot;192.168.0.4:111&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    //真实结点列表,考虑到服务器上线、下线的场景，即添加、删除的场景会比较频繁，这里使用LinkedList会更好</span><br><span class="line">    private static List&lt;String&gt; realNodes = new LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    //虚拟节点，key表示虚拟节点的hash值，value表示虚拟节点的名称</span><br><span class="line">    private static SortedMap&lt;Integer, String&gt; virtualNodes = new TreeMap&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line">    //虚拟节点的数目，这里写死，为了演示需要，一个真实结点对应5个虚拟节点</span><br><span class="line">    private static final int VIRTUAL_NODES = 5;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        //先把原始的服务器添加到真实结点列表中</span><br><span class="line">        for(int i=0; i&lt;servers.length; i++)</span><br><span class="line">            realNodes.add(servers[i]);</span><br><span class="line"></span><br><span class="line">        //再添加虚拟节点，遍历LinkedList使用foreach循环效率会比较高</span><br><span class="line">        for (String str : realNodes)&#123;</span><br><span class="line">            for(int i=0; i&lt;VIRTUAL_NODES; i++)&#123;</span><br><span class="line">                String virtualNodeName = str + &quot;&amp;&amp;VN&quot; + String.valueOf(i);</span><br><span class="line">                int hash = getHash(virtualNodeName);</span><br><span class="line">                System.out.println(&quot;虚拟节点[&quot; + virtualNodeName + &quot;]被添加, hash值为&quot; + hash);</span><br><span class="line">                virtualNodes.put(hash, virtualNodeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //得到应当路由到的结点</span><br><span class="line">    private static String getServer(String key)&#123;</span><br><span class="line">        //得到该key的hash值</span><br><span class="line">        int hash = getHash(key);</span><br><span class="line">        // 得到大于该Hash值的所有Map</span><br><span class="line">        SortedMap&lt;Integer, String&gt; subMap = virtualNodes.tailMap(hash);</span><br><span class="line">        String virtualNode;</span><br><span class="line">        if(subMap.isEmpty())&#123;</span><br><span class="line">            //如果没有比该key的hash值大的，则从第一个node开始</span><br><span class="line">            Integer i = virtualNodes.firstKey();</span><br><span class="line">            //返回对应的服务器</span><br><span class="line">            virtualNode = virtualNodes.get(i);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">            Integer i = subMap.firstKey();</span><br><span class="line">            //返回对应的服务器</span><br><span class="line">            virtualNode = subMap.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        //virtualNode虚拟节点名称要截取一下</span><br><span class="line">        if(virtualNode != null)&#123;</span><br><span class="line">            return virtualNode.substring(0, virtualNode.indexOf(&quot;&amp;&amp;&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别</span><br><span class="line">    private static int getHash(String str)&#123;</span><br><span class="line">        final int p = 16777619;</span><br><span class="line">        int hash = (int)2166136261L;</span><br><span class="line">        for (int i = 0; i &lt; str.length(); i++)</span><br><span class="line">            hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">        hash += hash &lt;&lt; 13;</span><br><span class="line">        hash ^= hash &gt;&gt; 7;</span><br><span class="line">        hash += hash &lt;&lt; 3;</span><br><span class="line">        hash ^= hash &gt;&gt; 17;</span><br><span class="line">        hash += hash &lt;&lt; 5;</span><br><span class="line"></span><br><span class="line">        // 如果算出来的值为负数则取其绝对值</span><br><span class="line">        if (hash &lt; 0)</span><br><span class="line">            hash = Math.abs(hash);</span><br><span class="line">        return hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String[] keys = &#123;&quot;太阳&quot;, &quot;月亮&quot;, &quot;星星&quot;&#125;;</span><br><span class="line">        for(int i=0; i&lt;keys.length; i++)</span><br><span class="line">            System.out.println(&quot;[&quot; + keys[i] + &quot;]的hash值为&quot; +</span><br><span class="line">                    getHash(keys[i]) + &quot;, 被路由到结点[&quot; + getServer(keys[i]) + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一致性hash算法解决了分布式环境下机器增加或者减少时，简单的取模运算无法获取较高命中率的问题。通过虚拟节点的使用，一致性hash算法可以均匀分担机器的负载，使得这一算法更具现实的意义。正因如此，一致性hash算法被广泛应用于分布式系统中。</p>
]]></content>
  </entry>
  <entry>
    <title>分布式一致性协议</title>
    <url>/2021/10/27/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h4 id="数据的一致性"><a href="#数据的一致性" class="headerlink" title="数据的一致性"></a>数据的一致性</h4><p><strong>定义</strong></p>
<ul>
<li>一些分布式系统通过复制数据来提高系统的可靠性和容错性，并且将数据的不同副本存放在不同的机器</li>
<li>在数据有多份副本的情况下，如果网络、服务器或者软件出现故障，会导致部分副本写入成功，部分副本写入失败。这就造成各个副本之间的数据不一致，数据内容冲突。</li>
</ul>
<p><strong>模型</strong></p>
<ul>
<li>强一致性</li>
</ul>
<p>要求无论更新操作时在那一个副本之行，之后所有的读操作都要获得最新的数据。</p>
<ul>
<li>弱一致性</li>
</ul>
<p>用户读到某一操作对系统特定数据的更新需要一段时间，我们称之为“不一致窗口”。</p>
<ul>
<li>最终一致性</li>
</ul>
<p>是弱一致的一种特例，保证用户最终能够读取到某操作对系统特定数据的更新；</p>
<p>从客户端来讲，有可能暂时获取不到最新的数据，但是最终还是可以访问最新的。</p>
<p>从服务来讲，数据存储并复制到分布整个系统超过半数的节点，以保证数据最终一致性。</p>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>最终一致性根据更新数据后各进程访问到数据的时间和方式的不同，又可以区分为：</p>
<p><strong>因果一致性</strong></p>
<p>如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将返回更新后的值，且一次写入将保证取代前一次写入。与进程A无因果关系的进程C的访问遵守一般的最终一致性规则。</p>
<p><strong>“读己之所写（read-your-writes）”一致性</strong></p>
<p>当进程A自己更新一个数据项之后，它总是访问到更新过的值，绝不会看到旧值。这是因果一致性模型的一个特例。</p>
<p><strong>会话（Session）一致性</strong></p>
<p>这是上一个模型的实用版本，它把访问存储系统的进程放到会话的上下文中。只要会话还存在，系统就保证“读己之所写”一致性。如果由于某些失败情形令会话终止，就要建立新的会话，而且系统的保证不会延续到新的会话。</p>
<p><strong>单调（Monotonic）读一致性</strong></p>
<p>如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值。</p>
<p><strong>单调写一致性</strong></p>
<p>系统保证来自同一个进程的写操作顺序执行。要是系统不能保证这种程度的一致性，就非常难以编程了。</p>
<h4 id="最终一致性解决方案"><a href="#最终一致性解决方案" class="headerlink" title="最终一致性解决方案"></a>最终一致性解决方案</h4><p>可以选择分布式事务框架方案，目前主流的分布式事务框架大致可分为3类实现 :</p>
<ul>
<li><p>基于XA协议的两阶段提交(2PC)方案</p>
</li>
<li><p>基于支付宝最早提出的TCC(Try、Confirm、Cancel)方案</p>
</li>
<li><p>基于ebay最早提出的消息队列异步确保方案</p>
</li>
</ul>
<p>此外还有较轻的解决方案，业务系统可以根据自身需要，选择通过幂等/重试、状态机、恢复日志、异步校验等技术来确保最终一致性。</p>
<p><strong>分布式事务框架</strong></p>
<p>最终一致性由分布式事务框架保证，业务程序员对框架细节完全透明。</p>
<p>劣势</p>
<ul>
<li>由于分阶段提交协议本身的脆弱性，主流分阶段提交协议如2PC，3PC, TCC都无法完全确保最终一致性，要采用异步校验的手段兜底。</li>
<li>分阶段提交协议带来的高延迟，多次协议通信RTT带来的时间损耗。</li>
<li>基于消息队列异步确保的分布式事务框架实现，需要考虑消息可靠性和业务侵入问题。</li>
</ul>
<p>优势</p>
<ul>
<li>分布式事务被框架封装成切面，业务开发只需关心纯业务。</li>
<li>分布式事务的代码开发量大大减少。</li>
</ul>
<p><strong>重试</strong></p>
<p>重试机制可以使分布式不一致数据自动恢复，前提是重试接口要提供幂等保证。重试机制是达成分布式最终一致性的重要手段。例如，超时重传是TCP协议保证数据可靠性的一个重要机制，核心思想其实就是重试。</p>
<p>同步重试 : 在上次请求失败或超时，程序再次发起同步调用请求。后端程序不推荐同步重试，其一因为同步等待占用系统线程资源，其二因为重试引起的流量放大，可能导致系统雪崩。</p>
<p>异步重试 : 通过异步系统(消息队列或调度中间件)对失败或超时请求再次发起调用。推荐这种方式的重试，重试的时间间隔可以设置为根据重试次数指数增长，超过重试阈值仍未成功，可以报警通知并由人工订正。</p>
<p><strong>幂等</strong></p>
<p>用通俗的话来说就是 : 相同的操作执行多次 和 执行一次产生的效果是一样的。有的操作是天然幂等的，如查询、删除操作。有的操作是人为使其幂等，例如TCP的超时重传操作就是幂等的，无论客户端将一个seq字节传送多少次，服务端窗口只会用一次该字节。</p>
<p><strong>状态机</strong></p>
<p>状态机是表示实体的状态根据条件转移的数学模型。通过状态机模型，系统可以判断当前不一致状态，以及如何校正不一致状态到一致状态。这样说可能比较抽象，我们拿发微信群红包的例子来说明。当你点开发红包按钮，输入总金额、红包个数、标题，点击支付成功后。</p>
<p><strong>恢复日志</strong></p>
<p>恢复日志是程序现场的记录，也是业务数据恢复的重要依据。恢复日志log要求全局唯一的requestId来标示请求(实际的业务场景可采用不会重复有含义的业务id)，出现异常，可以根据requestId维度redo和undo业务操作，恢复日志具体可分为三部分 :</p>
<ol>
<li><p>requestId请求开始时，记录REQUEST START requestId</p>
</li>
<li><p>本地修改时，记录全部的（requestId，x，originalValue, destValue）四元组，x代表操作对象，修改前x的值为originalValue，本次修改的目的操作值为destValue</p>
</li>
<li><p>requestId结束时，记录REQUEST End requestId</p>
</li>
</ol>
<p>恢复日志是系统从不一致的状态恢复到一致状态的重要数据，丢失恢复日志，意味着不一致可能无法恢复。为什么是可能，因为有时可以通过状态机对不一致的状态进行恢复。</p>
<p><strong>异步校验</strong></p>
<p>通过异步校验，可以发现分布式系统中的异常状态，并通过恢复日志进行脚本批量恢复或者人工处理恢复，根据校验的粒度有 :</p>
<p>根据业务实体id校验，使用消息队列，将需要校验业务id投递给校验系统，进行异步校验。</p>
<p>根据时间维度批量校验，使用异步调度框架，根据时间粒度批量获取进行异步校验。</p>
<h4 id="Paxos（Lamport）："><a href="#Paxos（Lamport）：" class="headerlink" title="Paxos（Lamport）："></a>Paxos（Lamport）：</h4><p>分布式系统中的节点通信存在两种模型：共享内存（Shared memory）和消息传递（Messages passing）。</p>
<p>基于消息传递通信模型的分布式系统，不可避免的会发生以下错误：进程可能会慢、被杀死或者重启，消息可能会延迟、丢失、重复，在基础Paxos场景中，先不考虑可能出现消息篡改即拜占庭错误的情况。</p>
<p>Paxos算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。</p>
<p>主要有三类节点：</p>
<p>提议者（Proposer）：提议一个值；</p>
<p>接受者（Acceptor）：对每个提议进行投票；</p>
<p>告知者（Learner）：被告知投票的结果，不参与投票过程。</p>
<p><img src="/2021/10/27/分布式一致性协议/paxos1.png" alt="avatar"></p>
<p>过程：</p>
<p>规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。</p>
<p>下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送提议请求。</p>
<p><img src="/2021/10/27/分布式一致性协议/paxos2.png" alt="avatar"></p>
<p>当 Acceptor 接收到一个提议请求，包含的提议为 [n1, v1]，并且之前还未接收过提议请求，那么发送一个提议响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。</p>
<p>如下图，Acceptor X 在收到 [n=2, v=8] 的提议请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的提议响应，并且设置当前接收到的提议为 [n=2, v=8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。</p>
<p><img src="/2021/10/27/分布式一致性协议/paxos3.png" alt="avatar"></p>
<p>如果 Acceptor 接受到一个提议请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送提议响应，该提议响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。</p>
<p>如下图，Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的提议请求，由于之前已经接收过 [n=4, v=5] 的提议，并且 n &gt; 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的提议请求，因为之前接收到的提议为 [n=2, v=8]，并且 2 &lt;= 4，因此就发送 [n=2, v=8] 的提议响应，设置当前接收到的提议为 [n=4, v=5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。</p>
<p><img src="/2021/10/27/分布式一致性协议/paxos4.png" alt="avatar"></p>
<p>当一个 Proposer 接收到超过一半 Acceptor 的提议响应时，就可以发送接受请求。</p>
<p>Proposer A 接受到两个提议响应之后，就发送 [n=2, v=8] 接受请求。该接受请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。</p>
<p>Proposer B 过后也收到了两个提议响应，因此也开始发送接受请求。需要注意的是，接受请求的 v 需要取它收到的最大 v 值，也就是 8。因此它发送 [n=4, v=8] 的接受请求。</p>
<p><img src="/2021/10/27/分布式一致性协议/paxos5.png" alt="avatar"></p>
<p> Acceptor 接收到接受请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送通知给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。</p>
<p><img src="/2021/10/27/分布式一致性协议/paxos6.png" alt="avatar"></p>
<h4 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h4><p>Raft算法适用于一个管理日志一致性的协议，相比于Paxos协议，Raft更易于理解和实现。</p>
<p>Raft将一致性算法分为了几个部分，包括领导选取(Leader Selection),日志复制(log replication)，安全(safe)</p>
<p>分布式存储系统通过维护多个副本来提高系统的可用性，难点在于分布式存储系统的核心问题，维护多个副本的一致性。</p>
<p>Raft协议基于复制状态机：</p>
<ul>
<li>一组server从相同的初始状态起，按相同的顺序执行相同的命令，最终会达到一致的状态。</li>
<li>一组server记录相同的操作日志，并以相同的顺序应用到状态机。</li>
</ul>
<p>Raft有一个明确的使用场景，管理复制日志的一致性。每台机器保存一份日志，日志来源于客户端的请求，包含一系列的命令，状态机会按顺序执行这些命令。</p>
<p><strong>节点类型</strong></p>
<p>引入主节点，通过竞选。</p>
<p>节点类型：Follower、Candidate 和 Leader</p>
<p>Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>
<p>选主流程：</p>
<p>① 下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</p>
<p><img src="/2021/10/27/分布式一致性协议/raft.png" alt="avatar"></p>
<p>② 此时 A 发送投票请求给其它所有节点。</p>
<p><img src="/2021/10/27/分布式一致性协议/raft2.png" alt="avatar"></p>
<p>③ 其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</p>
<p><img src="/2021/10/27/分布式一致性协议/raft3.png" alt="avatar"></p>
<p>④ 之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</p>
<p><img src="/2021/10/27/分布式一致性协议/raft4.png" alt="avatar"></p>
<p>日志复制过程：</p>
<p>一旦leader被选举成功，就可以对客户端提供服务了。客户端提交每一条命令都会被按顺序记录到leader的日志中，每一条命令都包含term编号和顺序索引，然后向其他节点并行发送AppendEntries RPC用以复制命令(如果命令丢失会不断重发)，当复制成功也就是大多数节点成功复制后，leader就会提交命令，即执行该命令并且将执行结果返回客户端，raft保证已经提交的命令最终也会被其他节点成功执行。leader会保存有当前已经提交的最高日志编号。顺序性确保了相同日志索引处的命令是相同的，而且之前的命令也是相同的。当发送AppendEntries RPC时，会包含leader上一条刚处理过的命令，接收节点如果发现上一条命令不匹配，就会拒绝执行。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://toutiao.io/posts/u97o5l/preview" target="_blank" rel="noopener">https://toutiao.io/posts/u97o5l/preview</a></li>
<li><a href="https://www.cnblogs.com/zhang-qc/p/8688258.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhang-qc/p/8688258.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/91288179" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91288179</a></li>
</ol>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务与mq</title>
    <url>/2021/06/04/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%8Emq/</url>
    <content><![CDATA[<h4 id="传统事务"><a href="#传统事务" class="headerlink" title="传统事务"></a>传统事务</h4><p>一个严格意义的事务实现，应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p>
<p>原子性，是指一个事务操作不可分割，要么成功，要么失败，不能有一半成功一半失败的情况。</p>
<p>一致性，是指这些数据在事务执行完成这个时间点之前，读到的一定是更新前的数据，之后读到的一定是更新后的数据，不应该存在一个时刻，让用户读到更新过程中的数据。</p>
<p>隔离性，是指一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对正在进行的其他事务是隔离的，并发执行的各个事务之间不能互相干扰，这个有点儿像我们打网游中的副本，我们在副本中打的怪和掉的装备，与其他副本没有任何关联也不会互相影响。</p>
<p>持久性，是指一个事务一旦完成提交，后续的其他操作和故障都不会对事务的结果产生任何影响。</p>
<h4 id="分布式事务？"><a href="#分布式事务？" class="headerlink" title="分布式事务？"></a>分布式事务？</h4><p>分布式事务就是要在分布式系统中的实现事务。在分布式系统中，在保证可用性和不严重牺牲性能的前提下，光是要实现数据的一致性就已经非常困难了，所以出现了很多“残血版”的一致性，比如顺序一致性、最终一致性等等。</p>
<p>显然实现严格的分布式事务是更加不可能完成的任务。所以，目前大家所说的分布式事务，更多情况下，是在分布式系统中事务的不完整实现。在不同的应用场景中，有不同的实现，目的都是通过一些妥协来解决实际问题。</p>
<p>在实际应用中，比较常见的分布式事务实现有2PC（Two-phase Commit，也叫二阶段提交）、TCC(Try-Confirm-Cancel)和事务消息。每一种实现都有其特定的使用场景，也有各自的问题，都不是完美的解决方案。</p>
<p>事务消息适用的场景主要是那些需要异步更新数据，并且对数据实时性要求不太高的场景。比如我们在开始时提到的那个例子，在创建订单后，如果出现短暂的几秒，购物车里的商品没有被及时清空，也不是完全不可接受的，只要最终购物车的数据和订单数据保持一致就可以了。</p>
<h4 id="消息队列是如何实现分布式事务的？"><a href="#消息队列是如何实现分布式事务的？" class="headerlink" title="消息队列是如何实现分布式事务的？"></a>消息队列是如何实现分布式事务的？</h4><p>事务消息需要消息队列提供相应的功能才能实现，Kafka和RocketMQ都提供了事务相关功能。</p>
<p>回到订单和购物车这个例子，我们一起来看下如何用消息队列来实现分布式事务。</p>
<p><img src="/2021/06/04/分布式事务与mq/mq1.png" alt="avatar"></p>
<p>首先，订单系统在消息队列上开启一个事务。然后订单系统给消息服务器发送一个“半消息”，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。</p>
<p>半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。然后根据本地事务的执行结果决定提交或者回滚事务消息。如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。这样就基本实现了“要么都成功，要么都失败”的一致性要求。</p>
<p>如果你足够细心，可能已经发现了，这个实现过程中，有一个问题是没有解决的。如果在第四步提交事务消息时失败了怎么办？对于这个问题，Kafka和RocketMQ给出了2种不同的解决方案。</p>
<p>Kafka的解决方案比较简单粗暴，直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿。RocketMQ则给出了另外一种解决方案。</p>
<h4 id="Kafka的事务和Exactly-Once可以解决什么问题？"><a href="#Kafka的事务和Exactly-Once可以解决什么问题？" class="headerlink" title="Kafka的事务和Exactly Once可以解决什么问题？"></a>Kafka的事务和Exactly Once可以解决什么问题？</h4><p>RocketMQ中的事务，它解决的问题是，确保执行本地事务和发消息这两个操作，要么都成功，要么都失败。并且，RocketMQ增加了一个事务反查的机制，来尽量提高事务执行的成功率和数据一致性。</p>
<p>而Kafka中的事务，它解决的问题是，确保在一个事务中发送的多条消息，要么都成功，要么都失败。注意，这里面的多条消息不一定要在同一个主题和分区中，可以是发往多个主题和分区的消息。当然，你可以在Kafka的事务执行过程中，加入本地事务，来实现和RocketMQ中事务类似的效果，但是Kafka是没有事务反查机制的。</p>
<p>Kafka的这种事务机制，单独来使用的场景不多。更多的情况下被用来配合Kafka的幂等机制来实现Kafka 的Exactly Once语义。我在之前的课程中也强调过，这里面的Exactly Once，和我们通常理解的消息队列的服务水平中的Exactly Once是不一样的。</p>
<p>我们通常理解消息队列的服务水平中的Exactly Once，它指的是，消息从生产者发送到Broker，然后消费者再从Broker拉取消息，然后进行消费。这个过程中，确保每一条消息恰好传输一次，不重不丢。我们之前说过，包括Kafka在内的几个常见的开源消息队列，都只能做到At Least Once，也就是至少一次，保证消息不丢，但有可能会重复。做不到Exactly Once。</p>
<p>那Kafka中的Exactly Once又是解决的什么问题呢？它解决的是，在流计算中，用Kafka作为数据源，并且将计算结果保存到Kafka这种场景下，数据从Kafka的某个主题中消费，在计算集群中计算，再把计算结果保存在Kafka的其他主题中。这样的过程中，保证每条消息都被恰好计算一次，确保计算结果正确。</p>
<h4 id="Kafka的事务是如何实现的？"><a href="#Kafka的事务是如何实现的？" class="headerlink" title="Kafka的事务是如何实现的？"></a>Kafka的事务是如何实现的？</h4><p>那Kafka的事务又是怎么实现的呢？它的实现原理和RocketMQ的事务是差不多的，都是基于两阶段提交来实现的，但是实现的过程更加复杂。</p>
<p>首先说一下，参与Kafka事务的几个角色，或者说是模块。为了解决分布式事务问题，Kafka引入了事务协调者这个角色，负责在服务端协调整个事务。这个协调者并不是一个独立的进程，而是Broker进程的一部分，协调者和分区一样通过选举来保证自身的可用性。</p>
<p>和RocketMQ类似，Kafka集群中也有一个特殊的用于记录事务日志的主题，这个事务日志主题的实现和普通的主题是一样的，里面记录的数据就是类似于“开启事务”“提交事务”这样的事务日志。日志主题同样也包含了很多的分区。在Kafka集群中，可以存在多个协调者，每个协调者负责管理和使用事务日志中的几个分区。这样设计，其实就是为了能并行执行多个事务，提升性能。</p>
<p><img src="/2021/06/04/分布式事务与mq/mq2.png" alt="avatar"></p>
<p>首先，当我们开启事务的时候，生产者会给协调者发一个请求来开启事务，协调者在事务日志中记录下事务ID。</p>
<p>然后，生产者在发送消息之前，还要给协调者发送请求，告知发送的消息属于哪个主题和分区，这个信息也会被协调者记录在事务日志中。接下来，生产者就可以像发送普通消息一样来发送事务消息，这里和RocketMQ不同的是，RocketMQ选择把未提交的事务消息保存在特殊的队列中，而Kafka在处理未提交的事务消息时，和普通消息是一样的，直接发给Broker，保存在这些消息对应的分区中，Kafka会在客户端的消费者中，暂时过滤未提交的事务消息。</p>
<p>消息发送完成后，生产者给协调者发送提交或回滚事务的请求，由协调者来开始两阶段提交，完成事务。第一阶段，协调者把事务的状态设置为“预提交”，并写入事务日志。到这里，实际上事务已经成功了，无论接下来发生什么情况，事务最终都会被提交。</p>
<p>之后便开始第二阶段，协调者在事务相关的所有分区中，都会写一条“事务结束”的特殊消息，当Kafka的消费者，也就是客户端，读到这个事务结束的特殊消息之后，它就可以把之前暂时过滤的那些未提交的事务消息，放行给业务代码进行消费了。最后，协调者记录最后一条事务日志，标识这个事务已经结束了。</p>
<p><img src="/2021/06/04/分布式事务与mq/mq3.png" alt="avatar"></p>
<p>总结一下Kafka这个两阶段的流程，准备阶段，生产者发消息给协调者开启事务，然后消息发送到每个分区上。提交阶段，生产者发消息给协调者提交事务，协调者给每个分区发一条“事务结束”的消息，完成分布式事务提交。</p>
]]></content>
      <tags>
        <tag>mq</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>动手实现运行servlet</title>
    <url>/2019/09/22/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E8%BF%90%E8%A1%8Cservlet/</url>
    <content><![CDATA[<h4 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h4><p>Cookie 本质上就是一份存储在用户本地的文件，里面包含了每次请求中都需要传递的信息。Session可以理解为服务器端开辟的存储空间，里面保存了用户的状态， 用户信息以 Session 的形式存储在服务端。<br>服务器在创建Session的同时，会为该Session 生成唯一的Session ID，通过set-cookie放在http的响应头里，然后浏览器写到 cookie里，当浏览器再次发送请求的时候，会将这个Session ID带上，服务器接受到请 求之后就会依据 Session ID 找到相应的 Session，找到 Session 后，就可以在Session中 获取或者添加内容了。而这些内容只会保存在服务器中， 发到客户端的只有Session ID， 这样相对安全，也节省了网络流量，因为不需要在Cookie中存储大量用户信息。在 Java 中，是 Web 应用程序在调用 HttpServletRequest 的 getSession 方法时，由 Web 容器(比如 Tomcat)创建的.</p>
<h4 id="Servlet容器和Servlet规范"><a href="#Servlet容器和Servlet规范" class="headerlink" title="Servlet容器和Servlet规范"></a>Servlet容器和Servlet规范</h4><p>Servlet接口其实是Servlet容器跟具体业务类之间的接口<br> <img src="/2019/09/22/动手实现运行servlet/servlet.png" alt="avatar"><br>Servlet 接口定义了下面五个方法:<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Servlet &#123;</span><br><span class="line">	void init(ServletConfig config) throws ServletException;</span><br><span class="line"></span><br><span class="line">	ServletConfig getServletConfig();</span><br><span class="line"></span><br><span class="line">	void service(ServletRequest req, ServletResponse res)throws ServletException, IOExc 7</span><br><span class="line">	String getServletInfo();</span><br><span class="line"></span><br><span class="line">	void destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> Servlet 容器在加载 Servlet 类的时候会调用 init 方法，在卸载的时候会调用 destroy 方法。我们可能会在 init 方法里初始化一些资源，并在 destroy 方法里释放这些资源，比 如 Spring MVC 中的 DispatcherServlet，就是在 init 方法里创建了自己的 Spring 容器。<br> ServletConfig 的作用就是封装 Servlet 的初始化参 数。你可以在 web.xml 给 Servlet 配置参数，并在程序里通过 getServletConfig 方法拿到 这些参数。<br>Servlet 规范提供了 GenericServlet 抽象类，我们可以通过扩展它来实现 Servlet。虽然 Servlet 规 范并不在乎通信协议是什么，但是大多数的 Servlet 都是在 HTTP 环境中处理的，因此 Servet 规范还提供了 HttpServlet 来继承 GenericServlet，并且加入了 HTTP 特性。这样我们通过继承 HttpServlet 类来实现自己的 Servlet，只需要重写两个方法:doGet 和 doPost。<br>当客户请求某个资源时，HTTP 服务器会用一个 ServletRequest 对象把客户的请求信息封 装起来，然后调用 Servlet 容器的 service 方法，Servlet 容器拿到请求后，根据请求的 URL 和 Servlet 的映射关系，找到相应的 Servlet，如果 Servlet 还没有被加载，就用反射 机制创建这个 Servlet，并调用 Servlet 的 init 方法来完成初始化，接着调用 Servlet 的 service 方法来处理请求，把 ServletResponse 对象返回给 HTTP 服务器，HTTP 服务器会 把响应发送给客户端。同样我通过一张图来帮助你理解。<br><img src="/2019/09/22/动手实现运行servlet/servlet2.png" alt="avatar"><br>Servlet 规范提供了两种扩展机制:Filter和Listener。<br>Filter是过滤器，这个接口允许你对请求和响应做一些统一的定制化处理，比如你可以根据 请求的频率来限制访问，或者根据国家地区的不同来修 改响应内容。过滤器的工作原理是这 样的:Web 应用部署完成后，Servlet 容器需要实例化 Filter 并把 Filter 链接成一个 FilterChain。当请求进来时，获取第一个 Filter 并调用 doFilter 方法，doFilter 方法负责 调用这个 FilterChain 中的下一个 Filter。<br>Listener是监听器，这是另一种扩展机制。当 Web 应用在 Servlet 容器中运行时，Servlet 容器内部会不断的发生各种事件，如 Web 应用的启动和停止、用户请求到达等。 Servlet容器提供了一些默认的监听器来监听这些事件， 当事件发生时 ，Servlet 容器会负责调用监 听器的方法。当然，你可以定义自己的监听器去监听你感兴趣的事件，将监听器配置在 web.xml 中。比如 Spring 就实现了自己的监听器，来监听 ServletContext 的启动事件， 目的是当 Servlet 容器启动时，创建并初始化全局的 Spring 容器。</p>
<h4 id="servlet容器，web容器，spring容器，springmvc容器的区别"><a href="#servlet容器，web容器，spring容器，springmvc容器的区别" class="headerlink" title="servlet容器，web容器，spring容器，springmvc容器的区别"></a>servlet容器，web容器，spring容器，springmvc容器的区别</h4><p>web容器中有servlet容器，spring项目部署后存在spring容器和springmvc容器。其中spring控制service层和dao层的bean对象。springmvc容器控制controller层bean对象。servlet容器控制servlet对象。项目启动是，首先 servlet初始化，初始化过程中通过web.xml中spring的配置加载spring配置， 初始化spring容器和springmvc容器。待容器加载完成。servlet初始化完成，则完成启动。HTTP请求到达web容器后，会到达Servlet容器，容器通过分发器分发到具体的spring的Controller层。执行业务操作后返回结果。<br> <img src="/2019/09/22/动手实现运行servlet/servlet3.png" alt="avatar"></p>
<h4 id="Filter和Listener"><a href="#Filter和Listener" class="headerlink" title="Filter和Listener"></a>Filter和Listener</h4><p> Filter是过滤器，这个接口允许你对请求和响应做一些统一的定制化处理，比如你可以根据 请求的频率来限制访问，或者根据国家地区的不同来修改响应内容。过滤器的工作原理是这 样的:Web 应用部署完成后，Servlet 容器需要实例化 Filter 并把 Filter 链接成一个 FilterChain。当请求进来时，获取第一个 Filter 并调用 doFilter 方法，doFilter 方法负责 调用这个 FilterChain 中的下一个 Filter。<br> Listener是监听器，这是另一种扩展机制。当 Web 应用在 Servlet 容器中运行时，Servlet 容器内部会不断的发生各种事件，如 Web 应用的启动和停止、用户请求到达等。 Servlet容器提供了一些默认的监听器来监听这些事件，当事件发生时，Servlet 容器会负责调用监 听器的方法。当然，你可以定义自己的监听器去监听你感兴趣的事件，将监听器配置在 web.xml 中。比如 Spring 就实现了自己的监听器，来监听 ServletContext 的启动事件， 目的是当 Servlet 容器启动时，创建并初始化全局的 Spring 容器。<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filter.doFilter(); </span><br><span class="line">HandlerInterceptor.preHandle(); </span><br><span class="line">Controller </span><br><span class="line">HandlerInterceptor.postHandle(); </span><br><span class="line">DispatcherServlet 渲染视图 </span><br><span class="line">HandlerInterceptor.afterCompletion(); </span><br><span class="line">Filter.doFilter(); Servlet方法返回</span><br></pre></td></tr></table></figure></p>
<h4 id="通过tomcat部署servlet"><a href="#通过tomcat部署servlet" class="headerlink" title="通过tomcat部署servlet"></a>通过tomcat部署servlet</h4><p> 1.部署在tomcat中</p>
<ol>
<li>servlet代码 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">public class MyServlet extends HttpServlet&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void doGet(HttpServletRequest request,HttpServletResponse response)</span><br><span class="line">	throws ServletException,IOException&#123;</span><br><span class="line">	System.out.println(&quot;MyServlet 在处理 get()请求...&quot;);</span><br><span class="line">	PrintWriter out = response.getWriter();</span><br><span class="line">	response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">	out.println(&quot;&lt;strong&gt;My Servlet!&lt;/strong&gt;&lt;br&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void doPost(HttpServletRequest request,HttpServletResponse response)</span><br><span class="line">	throws ServletException,IOException&#123;</span><br><span class="line">	System.out.println(&quot;MyServlet 在处理 post()请求...&quot;);</span><br><span class="line">	PrintWriter out = response.getWriter();</span><br><span class="line">	response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">	out.println(&quot;&lt;strong&gt;My Servlet!&lt;/strong&gt;&lt;br&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>步骤2：代码编译<br>     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac -cp ./servlet-api.jar MyServlet.java</span><br></pre></td></tr></table></figure></p>
<p>步骤3.项目层级<br>     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyWebApp/WEB-INF/web.xml</span><br><span class="line">MyWebApp/WEB-INF/classes/MyServlet.class</span><br></pre></td></tr></table></figure></p>
<p>步骤四 web.xml<br>     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line"> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line"> xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee</span><br><span class="line"> http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line"> version=&quot;4.0&quot;</span><br><span class="line"> metadata-complete=&quot;true&quot;&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">      &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;</span><br><span class="line">       &lt;servlet-class&gt;MyServlet&lt;/servlet-class&gt;</span><br><span class="line">   &lt;/servlet&gt;</span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">     &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;</span><br><span class="line">     &lt;url-pattern&gt;/myservlet&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p>
<p>2.其他参考地址<a href="https://github.com/feifa168/mytomcat" target="_blank" rel="noopener">https://github.com/feifa168/mytomcat</a></p>
]]></content>
      <tags>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式理论简介</title>
    <url>/2019/09/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h4 id="问题的解读"><a href="#问题的解读" class="headerlink" title="问题的解读"></a>问题的解读</h4><p>对于上面三个例子，相信大家一定看出来了，我们的终端用户在使用不同的计算机产品时对于数据一致性的需求是不一样的：<br>1、有些系统，既要快速地响应用户，同时还要保证系统的数据对于任意客户端都是真实可靠的，就像火车站售票系统<br>2、有些系统，需要为用户保证绝对可靠的数据安全，虽然在数据一致性上存在延时，但最终务必保证严格的一致性，就像银行的转账系统<br>3、有些系统，虽然向用户展示了一些可以说是”错误”的数据，但是在整个系统使用过程中，一定会在某一个流程上对系统数据进行准确无误的检查，从而避免用户发生不必要的损失，就像网购系统</p>
<h4 id="分布一致性的提出"><a href="#分布一致性的提出" class="headerlink" title="分布一致性的提出"></a>分布一致性的提出</h4><p>在分布式系统中要解决的一个重要问题就是数据的复制。在我们的日常开发经验中，相信很多开发人员都遇 到过这样的问题：假设客户端C1将系统中的一个值K由V1更新为V2， 但客户端C2无法立即读取到K的最新值，需要在一段时间之后才能读取到。这很正常，因为数据库复制之间存在延时。<br>分布式系统对于数据的复制需求一般都来自于以下两个原因：<br>1、为了增加系统的可用性，以防止单点故障引起的系统不可用<br>2、提高系统的整体性能，通过负载均衡技术，能够让分布在不同地方的数据副本都能够为用户提供服务<br>数据复制在可用性和性能方面给分布式系统带来的巨大好处是不言而喻的，然而数据复制所带来的一致性挑战，也是每一个系统研发人员不得不面对的。<br>所谓分布一致性问题，是指在分布式环境中引入数据复制机制之后，不同数据节点之间 可能出现的，并无法依靠计算机应用程序自身解决的数据不一致的情况。简单讲，数据一 致性就是指在对一个副本数据进行更新的时候，必须确保也能够更新其他的副本，否则不同副本之间的数据将不一致。<br>那么如何解决这个问题？一种思路是”既然是由于延时动作引起的问题，那我可以将写入的动作阻塞，直到数据复制完成后，才完成写入动作”。没错，这似乎能解决问题， 而且 有一些系统的架构也确实直接使用了这个思路。但这个思路在解决一致性问题的同时，又带来了新的问题：写入的性能。如果你的应 用场景有非常多的写请求，那么使用这个思 路之后，后续的写请求都将会阻塞在前一个请求的写操作上，导致系统整体性能急剧下降。<br>总得来说，我们无法找到一种能够满足分布式系统所有系统属性的分布式一致性解决方案。因此，如何既保证数据的一致性，同时又不影响系统运行的性能，是每一个分布式系统都需要重点考虑和权衡的。于是，一致性级别由此诞生：<br>1、强一致性<br>这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大<br>2、弱一致性<br>这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态<br>3、最终一致性<br>最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型</p>
<h4 id="分布式环境的各种问题"><a href="#分布式环境的各种问题" class="headerlink" title="分布式环境的各种问题"></a>分布式环境的各种问题</h4><p>分布式系统体系结构从其出现之初就伴随着诸多的难题和挑战：<br>1、通信异常<br>从集中式向分布式演变的过程中，必然引入网络因素，由于网络本身的不可靠性，因此也引入了额外的问题。分布式系统需要在各个节点之间进行网络通信，因此每次网络通信 都会伴随着网络不可用的风险，网络光纤、路由器或是DNS等硬件设备或 是系统不可用都会导致最终分布式系统无法顺利完成一次网络通信。另外，即使分布式系统各个节点之 间的网络通信能够正常进行，其延时也会大于单机操作。通常我们认为现代计算机体系结构中，单机内存访问的延时在纳秒数量级（通常是10ns），而正常的一次网络通信的延迟在0.1~1ms左右（相当于内存访问延 时的105倍），如此巨大的延时差别，也会影响到消息的收发过程，因此消息丢失和消息延迟变得非常普遍<br>2、网络分区<br>当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够正常通信，而另一些节点则不能—-我们将这个现象称为网络分区。当网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本需要整个分布式系统才能完成的功能，包括对数据的事物处理，这就对分布式一致性提出了非常大的挑战<br>3、三态<br>上面两点，我们已经了解到在分布式环境下，网络可能会出现各式各样的问题，因此分布式系统的每一次请求与响应，存在特有的三态概念，即成功、失败、超时。在传统的单机系统中 ，应用程序在调用一个函数之后，能够得到一个非常明确的响应：成功或失败。而在分布式系统中，由于网络是不可靠的，虽然在绝大部分情况下，网络通信 也能够接受到成功或失败的响应，当时当网络出现异常的情况下，就可能会出现超时现象，通常有以下两种情况：<br>（1）由于网络原因，该请求并没有被成功地发送到接收方，而是在发送过程中就发生了消息丢失现象<br>（2）该请求成功地被接收方接收后，进行了处理，但是在将响应反馈给发送方的过程中，发生了消息丢失现象<br>当出现这样的超时现象时，网络通信的发起方是无法确定当前请求是否被成功处理的<br>4、节点故障<br>节点故障则是分布式环境下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或”僵死”现象，通常根据经验来说，每个节点都有可能出现故障，并且每天都在发生</p>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>随着分布式计算的发展，事物在分布式计算领域也得到了广泛的应用。在单机数据库中，我们很容易能够实现一套满足ACID特性的事物处理系统，但在分布式数据库中，数据分散在各台不同的机器上，如何对这些数据进行分布式的事物处理具有非常大的挑战。<br>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点上，通常一个分布式事务中会涉及对多个数据源或业务系统的操作。<br>可以设想一个最典型的分布式事务场景：一个跨银行的转账操作涉及调用两个异地的银行服务，其中一个是本地银行提供的取款服务， 另一个则是目标银行提供的存款服 务，这两个服务本身是无状态并且相互独立的，共同构成了一个完整的分布式事务。如果从本地银行取款成功，但是因为某种原因存款服务失败了，那么就必须回滚到取款之前的状态，否则用户可能会发现自己的钱不翼而飞了。<br>从这个例子可以看到，一个分布式事务可以看做是多个分布式的操作序列组成的，例如 上面例子的取款服务和存款服务， 通常可以把这一系列分布式的操作序列 称为子事务。 因此，分布式事务也可以被定义为一种嵌套型的事物，同时也就具有了 ACID事物特性。 但由于在分布式事务中，各个子事物的执行是分布式的 ，因此要实现一种能够保证ACID特性的分布式事物处理系统就显得格外复杂。</p>
<h4 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h4><p>一个经典的分布式系统理论。CAP理论告诉我们：一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中两项。<br>1、一致性<br>在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一直的状态。对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，却没有使得第二个节点上的数据得到相应的更新， 于是在对第二个节点的数据进行读取操作时，获取的依然是老数据（或称为脏数据），这就是典型的分布式数据不一致的情况。在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性<br>2、可用性<br>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里的重点是”有限时间内”和”返回结果”。”有限时间内”是指，对于用户的一个操作请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。  另外，”有限的时间内”是指系统设计之初就设计好的运行指标，通常不同系统之间有很大的不同，无论如何，对于用户请求，系统必须存在一个合理的响应时间，否则用户便会对系统感到失望。”返回结果”是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出队请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。<br>3、分区容错性<br>分区容错性约束了一个分布式系统具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络）中，由于一些特殊的原因导致这些子网络出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。<br>既然一个分布式系统无法同时满足一致性、可用性、分区容错性三个特点，所以我们就需要抛弃一样：<br><img src="/2019/09/12/分布式理论简介/cap.png" alt="avatar"><br>用一张表格说明一下：</p>
<table>
<thead>
<tr>
<th>选择</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CA</td>
<td>放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择 </td>
</tr>
<tr>
<td>AP</td>
<td>放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此 </td>
</tr>
<tr>
<td>CP</td>
<td>放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用  </td>
</tr>
</tbody>
</table>
<p>需要明确的一点是，对于一个分布式系统而言，分区容错性是一个最基本的要求。因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构师往往需要把精力花在如何根据业务 特点在C（一致性）和A（可用性）之间寻求平衡。</p>
<h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。 BASE理论是对CAP中一致性和 可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。接下来看一下BASE中的三要素：<br>1、基本可用<br>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性—-注意，这绝不等价于系统不可用。比如：<br>（1）响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒<br>（2）系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面<br>2、软状态<br>软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时<br>3、最终一致性<br>最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。<br>总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://www.cnblogs.com/szlbm/p/5588543.html" target="_blank" rel="noopener">https://www.cnblogs.com/szlbm/p/5588543.html</a></p>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>定制化ISO镜像</title>
    <url>/2021/02/05/%E5%AE%9A%E5%88%B6%E5%8C%96ISO%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h3 id="ISO镜像版本选择"><a href="#ISO镜像版本选择" class="headerlink" title="ISO镜像版本选择"></a>ISO镜像版本选择</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CentOS-7-x86_64-Minimal-1810.iso</span><br></pre></td></tr></table></figure>
<h3 id="制作工具安装"><a href="#制作工具安装" class="headerlink" title="制作工具安装"></a>制作工具安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install anaconda createrepo mkisofs rsync syslinux</span><br></pre></td></tr></table></figure>
<h3 id="挂载光盘，同步文件"><a href="#挂载光盘，同步文件" class="headerlink" title="挂载光盘，同步文件"></a>挂载光盘，同步文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/cdrom</span><br><span class="line"></span><br><span class="line">mount -o loop /tmp/CentOS-7-x86_64-Minimal-1708.iso /mnt/cdrom/</span><br><span class="line">&lt;&lt;&apos;COMMENT&apos;</span><br><span class="line">mount: /dev/loop0 is write-protected, mounting read-only</span><br><span class="line">COMMENT</span><br><span class="line"></span><br><span class="line"># 同步/mnt/cdrom/下的文件到/ISO/路径下，除了Packages和repodata文件夹</span><br><span class="line">/usr/bin/rsync -a /mnt/cdrom/ /ISO/</span><br><span class="line"></span><br><span class="line">ls /ISO/</span><br><span class="line">&lt;&lt;&apos;COMMENT&apos;</span><br><span class="line">CentOS_BuildTag  EFI  EULA  GPL  images  isolinux  LiveOS  RPM-GPG-KEY-CentOS-7  RPM-GPG-KEY-CentOS-Testing-7  TRANS.TBL</span><br><span class="line">COMMENT</span><br></pre></td></tr></table></figure>
<h3 id="制作ks-cfg文件"><a href="#制作ks-cfg文件" class="headerlink" title="制作ks.cfg文件"></a>制作ks.cfg文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /ISO/isolinux</span><br><span class="line"></span><br><span class="line">cat &gt; ks.cfg &lt;&lt;EOF</span><br><span class="line">#version= CentOS 7</span><br><span class="line">#platform=x86, AMD64, or Intel EM64T</span><br><span class="line"># Install OS instead of upgrade</span><br><span class="line">install</span><br><span class="line"># Keyboard layouts</span><br><span class="line">keyboard --vckeymap=us --xlayouts=&apos;us&apos;</span><br><span class="line"># Root password</span><br><span class="line">rootpw --iscrypted $1$Jg7P7.9/$TT.baSvBhZy/wOkSs9CDT/</span><br><span class="line"># (Required) Wrapper around the authconfig command CCE-14063-2 (row 80)</span><br><span class="line">authconfig --enableshadow --passalgo=sha512</span><br><span class="line"># System language</span><br><span class="line">lang en_US.UTF-8</span><br><span class="line"># Firewall configuration</span><br><span class="line">firewall --disabled</span><br><span class="line"># System authorization information</span><br><span class="line">auth  --useshadow  --passalgo=sha512</span><br><span class="line"># Use CDROM installation media</span><br><span class="line">cdrom</span><br><span class="line"># Use text mode install</span><br><span class="line">text</span><br><span class="line"># Run the Setup Agent on first boot</span><br><span class="line">firstboot --enable</span><br><span class="line">ignoredisk --only-use=sda</span><br><span class="line"># SELinux configuration</span><br><span class="line">selinux --disabled</span><br><span class="line"># Do not configure the X Window System</span><br><span class="line">skipx</span><br><span class="line"></span><br><span class="line"># Network information</span><br><span class="line">network  --bootproto=dhcp --device=ens160 --onboot=yes --ipv6=auto --activate</span><br><span class="line">network  --device=ens160 --hostname=localhost.localdomain</span><br><span class="line"># Reboot after installation</span><br><span class="line">reboot</span><br><span class="line"># System timezone</span><br><span class="line">timezone Asia/Shanghai --isUtc</span><br><span class="line"># System bootloader configuration</span><br><span class="line">bootloader --location=mbr --driveorder=sda --append=&quot;&quot;</span><br><span class="line"># Clear the Master Boot Record</span><br><span class="line">zerombr</span><br><span class="line"># Partition clearing information</span><br><span class="line">clearpart --all --initlabel</span><br><span class="line">autopart --type=lvm</span><br><span class="line"></span><br><span class="line">%packages</span><br><span class="line">@^minimal</span><br><span class="line">@core</span><br><span class="line">@customrpm</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure>
<h3 id="修改isolinux-cfg"><a href="#修改isolinux-cfg" class="headerlink" title="修改isolinux.cfg"></a>修改isolinux.cfg</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /ISO/isolinux</span><br><span class="line"></span><br><span class="line">chmod 644 isolinux.cfg</span><br><span class="line"></span><br><span class="line">sudo vi isolinux.cfg</span><br></pre></td></tr></table></figure>
<p>修改的部分内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">label linux</span><br><span class="line">  menu label ^Install CentOS 7</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img inst.stage2=hd:LABEL=CentOS7 inst.ks=cdrom:/isolinux/ks.cfg quiet</span><br></pre></td></tr></table></figure>
<blockquote>
<p>inst.ks为ks.cfg文件位置；<br>inst.stage2为安装介质位置，hd:LABEL为介质标签，例如CentOS7。这个和后续生成ISO镜像文件的命令genisoimage的参数-V有关。<br>modprobe.blacklist=nouveau; 禁用nouveau驱动安装，用于NVIDIA驱动的安装准备工作；<br>net.ifnames=0 biosdevname=0； 用于禁用centos7的”一致性网络设备命名法”.</p>
</blockquote>
<h3 id="制作comps-xml文件"><a href="#制作comps-xml文件" class="headerlink" title="制作comps.xml文件"></a>制作comps.xml文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp /mnt/cdrom/repodata/*-minimal-x86_64-comps.xml /ISO/comps.xml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE comps PUBLIC &quot;-//CentOS//DTD Comps info//EN&quot; &quot;comps.dtd&quot;&gt;</span><br><span class="line">&lt;comps&gt;</span><br><span class="line">  &lt;group&gt;</span><br><span class="line">    &lt;id&gt;core&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;Core&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;af&quot;&gt;Kern&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;am&quot;&gt;ማዕከላዊ ቦታ&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;ar&quot;&gt;اللبّ&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;as&quot;&gt;ভিত্তি&lt;/name&gt;</span><br><span class="line">    ....</span><br><span class="line">    &lt;name xml:lang=&quot;tr&quot;&gt;Çekirdek&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;uk&quot;&gt;Основа&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;ur&quot;&gt;مرکز&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;vi&quot;&gt;Lõi&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;zh_CN&quot;&gt;核心&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;zh_TW&quot;&gt;核心&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;zu&quot;&gt;Okuyikhona&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Smallest possible installation.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;as&quot;&gt;ন্যূনতম ইনস্টল।&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;bn&quot;&gt;ন্যূনতম ইনস্টলেশন।&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;bn_IN&quot;&gt;ন্যূনতম ইনস্টলেশন।&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;cs&quot;&gt;Nejmenší možná instalace.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;de&quot;&gt;Kleinstmögliche Installation.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;es&quot;&gt;La instalación más pequeña posible.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;fr&quot;&gt;Plus petite installation possible.&lt;/description&gt;</span><br><span class="line">    ....</span><br><span class="line">    &lt;description xml:lang=&quot;ru&quot;&gt;Минимально возможная установка&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;sv&quot;&gt;Minsta möjliga installation&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;ta&quot;&gt;மிகச் சிறிய செயல்படுத்தக்கூடிய நிறுவல்.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;te&quot;&gt;సాధ్యమగు అతిచిన్న సంస్థాపన.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;uk&quot;&gt;Мінімально можливе встановлення.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;zh_CN&quot;&gt;最小可能安装。&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;zh_TW&quot;&gt;最小型安裝。&lt;/description&gt;</span><br><span class="line">    &lt;default&gt;false&lt;/default&gt;</span><br><span class="line">    &lt;uservisible&gt;false&lt;/uservisible&gt;</span><br><span class="line">    &lt;packagelist&gt;</span><br><span class="line">      &lt;packagereq type=&quot;mandatory&quot;&gt;audit&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;mandatory&quot;&gt;basesystem&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;mandatory&quot;&gt;bash&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;mandatory&quot;&gt;biosdevname&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;mandatory&quot;&gt;irqbalance&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;mandatory&quot;&gt;kbd&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;mandatory&quot;&gt;kexec-tools&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;mandatory&quot;&gt;less&lt;/packagereq&gt;</span><br><span class="line">      ...</span><br><span class="line">      &lt;packagereq type=&quot;default&quot;&gt;rdma&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;optional&quot;&gt;dracut-config-generic&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;optional&quot;&gt;dracut-fips&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;optional&quot;&gt;dracut-fips-aesni&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;optional&quot;&gt;dracut-network&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;optional&quot;&gt;openssh-keycat&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;optional&quot;&gt;selinux-policy-mls&lt;/packagereq&gt;</span><br><span class="line">      &lt;packagereq type=&quot;optional&quot;&gt;tboot&lt;/packagereq&gt;</span><br><span class="line">    &lt;/packagelist&gt;</span><br><span class="line">  &lt;/group&gt;</span><br><span class="line">  &lt;group&gt;</span><br><span class="line">    &lt;id&gt;custom&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;custom&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;af&quot;&gt;custom&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;am&quot;&gt;custom&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;ar&quot;&gt;custom&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;as&quot;&gt;custom&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;bal&quot;&gt;custom&lt;/name&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;name xml:lang=&quot;vi&quot;&gt;custom&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;zh_CN&quot;&gt;custom&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;zh_TW&quot;&gt;custom&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;zu&quot;&gt;custom&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;installation custom sofeware.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;as&quot;&gt;installation custom sofeware.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;bn&quot;&gt;installation custom sofeware.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;bn_IN&quot;&gt;installation custom sofeware.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;cs&quot;&gt;installation custom sofeware.&lt;/description&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;description xml:lang=&quot;uk&quot;&gt;installation custom sofeware.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;zh_CN&quot;&gt;installation custom sofeware.&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;zh_TW&quot;&gt;installation custom sofeware.&lt;/description&gt;</span><br><span class="line">    &lt;default&gt;false&lt;/default&gt;</span><br><span class="line">    &lt;uservisible&gt;false&lt;/uservisible&gt;</span><br><span class="line">    &lt;packagelist&gt;</span><br><span class="line">      &lt;packagereq type=&quot;default&quot;&gt;redis50-5.0.6-1.el7.x86_64&lt;/packagereq&gt;</span><br><span class="line">    &lt;/packagelist&gt;</span><br><span class="line">  &lt;/group&gt;</span><br><span class="line">  &lt;environment&gt;</span><br><span class="line">    &lt;id&gt;minimal&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;Minimal Install&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;as&quot;&gt;নূন্যতম ইনস্টল&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;bn_IN&quot;&gt;ন্যূনতম ইনস্টল&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;cs&quot;&gt;Minimální instalace&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;de&quot;&gt;Minimale Installation&lt;/name&gt;</span><br><span class="line">    &lt;name xml:lang=&quot;es&quot;&gt;Instalación mínima&lt;/name&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;description xml:lang=&quot;zh_CN&quot;&gt;基本功能。&lt;/description&gt;</span><br><span class="line">    &lt;description xml:lang=&quot;zh_TW&quot;&gt;基本功能。&lt;/description&gt;</span><br><span class="line">    &lt;display_order&gt;5&lt;/display_order&gt;</span><br><span class="line">    &lt;grouplist&gt;</span><br><span class="line">      &lt;groupid&gt;core&lt;/groupid&gt;</span><br><span class="line">      &lt;groupid&gt;core&lt;/groupid&gt;</span><br><span class="line">      &lt;groupid&gt;custom&lt;/groupid&gt;</span><br><span class="line">    &lt;/grouplist&gt;</span><br><span class="line">  &lt;/environment&gt;</span><br><span class="line">&lt;/comps&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>comps文件以group来区分包，以environment来区分环境，例如centos的mini版本为minimal，其核心包为core。类似于其格式，可定制自己的rpm包，建立自己的group id和name，包含自己的language及描述，最重要的是packagelist，类型default为默认的，mandatory为强制的</p>
</blockquote>
<blockquote>
<p>将定制的rpm安装包放到/ISO/Packages/中。这里需要注意rpm包的依赖性，可以通过以下命令来获得依赖，例如以下需要perl安装rpm，然后同样添加到comps.xml中</p>
</blockquote>
<p>由comps.xml生成repodata包。注意当有新包加入，或者更新comps.xml文件，均需要重新生成repodata文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /ISO</span><br><span class="line"></span><br><span class="line">createrepo -g comps.xml .</span><br><span class="line">&lt;&lt;&apos;COMMENT&apos;</span><br><span class="line">Spawning worker 0 with 369 pkgs</span><br><span class="line">Workers Finished</span><br><span class="line">Saving Primary metadata</span><br><span class="line">Saving file lists metadata</span><br><span class="line">Saving other metadata</span><br><span class="line">Generating sqlite DBs</span><br><span class="line">Sqlite DBs complete</span><br><span class="line">COMMENT</span><br><span class="line"></span><br><span class="line">ls repodata/</span><br><span class="line">&lt;&lt;&apos;COMMENT&apos;</span><br><span class="line">2b873dfb5efcd23c4556c64f85f8752dea89a1b78ac2d81f5a3a2479a6364aed-primary.sqlite.bz2    ba731bbd51e5526bdf722d98e006d633bfd76ec48c283921f4dfd1eeb95c6478-filelists.xml.gz</span><br><span class="line">36f3b0cba95abd61f2f871ed31db124a1b9c7838e29cf992a59a093935ecf626-other.xml.gz          d36769d1a5c1b5480e99904a03b6d487f84d34c8075b5eb6b290e90802e3ea2a-comps.xml</span><br><span class="line">6d916600909af4ba73f09e2c5877a3fa8e2811d8bf8f43909e83c72c27af51f2-comps.xml.gz          e2987de1d65f29e23f8d4ac01f8544b1fe47596dd93928026f4ac4a766cfb018-primary.xml.gz</span><br><span class="line">6e0e0fec735b69e035c67f68ab629182c703ad1840b37dceefaba9e5093a7747-filelists.sqlite.bz2</span><br><span class="line">repomd.xml</span><br><span class="line">ac0924ead0d2101950c99e0670d1b74c8fea364a6bddca6415d04eb6102d0b08-other.sqlite.bz2</span><br><span class="line">COMMENT</span><br></pre></td></tr></table></figure>
<h3 id="制作ISO镜像"><a href="#制作ISO镜像" class="headerlink" title="制作ISO镜像"></a>制作ISO镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /ISO</span><br><span class="line"></span><br><span class="line"># 注意参数中的-V，和上面的isolinux.cfg文件有关</span><br><span class="line">genisoimage -joliet-long -V CentOS7 -o CentOS-7-custom.iso -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -R -J -v -cache-inodes -T -eltorito-alt-boot -e images/efiboot.img -no-emul-boot /ISO</span><br><span class="line"></span><br><span class="line">I: -input-charset not specified, using utf-8 (detected in locale settings)</span><br><span class="line">genisoimage 1.1.11 (Linux)</span><br><span class="line">Scanning /ISO</span><br><span class="line">Scanning /ISO/EFI</span><br><span class="line">Scanning /ISO/EFI/BOOT</span><br><span class="line">Scanning /ISO/EFI/BOOT/fonts</span><br><span class="line">Excluded: /ISO/EFI/BOOT/fonts/TRANS.TBL</span><br><span class="line">Excluded: /ISO/EFI/BOOT/TRANS.TBL</span><br><span class="line">Excluded: /ISO/EFI/TRANS.TBL</span><br><span class="line">Scanning /ISO/LiveOS</span><br><span class="line">Excluded: /ISO/LiveOS/TRANS.TBL</span><br><span class="line">Scanning /ISO/images</span><br><span class="line">Scanning /ISO/images/pxeboot</span><br><span class="line">Excluded: /ISO/images/pxeboot/TRANS.TBL</span><br><span class="line">Excluded: /ISO/images/TRANS.TBL</span><br><span class="line">Scanning /ISO/isolinux</span><br><span class="line">Excluded: /ISO/isolinux/TRANS.TBL</span><br><span class="line">Excluded by match: /ISO/isolinux/boot.cat</span><br><span class="line">Excluded: /ISO/TRANS.TBL</span><br><span class="line">Scanning /ISO/Packages</span><br><span class="line">Scanning /ISO/repodata</span><br><span class="line">Using RPM_G000.;1 for  /RPM-GPG-KEY-CentOS-Testing-7 (RPM-GPG-KEY-CentOS-7)</span><br><span class="line">Using PYTHO000.RPM;1 for  /ISO/Packages/python2-crypto-2.6.1-15.el7.x86_64.rpm (python2-cryptography-1.7.2-1.el7.x86_64.rpm)</span><br><span class="line">...</span><br><span class="line">Using HUNSP002.RPM;1 for  /ISO/Packages/hunspell-en-0.20121024-6.el7.noarch.rpm (hunspell-en-US-0.20121024-6.el7.noarch.rpm)</span><br><span class="line">Using LIBER000.RPM;1 for  /ISO/Packages/liberation-fonts-common-1.07.2-15.el7.noarch.rpm (liberation-sans-fonts-1.07.2-15.el7.noarch.rpm)</span><br><span class="line">Writing:   Initial Padblock                        Start Block 0</span><br><span class="line">Done with: Initial Padblock                        Block(s)    16</span><br><span class="line">Writing:   Primary Volume Descriptor               Start Block 16</span><br><span class="line">Done with: Primary Volume Descriptor               Block(s)    1</span><br><span class="line">Writing:   Eltorito Volume Descriptor              Start Block 17</span><br><span class="line">Size of boot image is 4 sectors -&gt; No emulation</span><br><span class="line">Done with: Eltorito Volume Descriptor              Block(s)    1</span><br><span class="line">Writing:   Joliet Volume Descriptor                Start Block 18</span><br><span class="line">Done with: Joliet Volume Descriptor                Block(s)    1</span><br><span class="line">Writing:   End Volume Descriptor                   Start Block 19</span><br><span class="line">Done with: End Volume Descriptor                   Block(s)    1</span><br><span class="line">Writing:   Version block                           Start Block 20</span><br><span class="line">Done with: Version block                           Block(s)    1</span><br><span class="line">Writing:   Path table                              Start Block 21</span><br><span class="line">Done with: Path table                              Block(s)    4</span><br><span class="line">Writing:   Joliet path table                       Start Block 25</span><br><span class="line">Done with: Joliet path table                       Block(s)    4</span><br><span class="line">Writing:   Directory tree                          Start Block 29</span><br><span class="line">Done with: Directory tree                          Block(s)    42</span><br><span class="line">Writing:   Joliet directory tree                   Start Block 71</span><br><span class="line">Done with: Joliet directory tree                   Block(s)    29</span><br><span class="line">Writing:   Directory tree cleanup                  Start Block 100</span><br><span class="line">Done with: Directory tree cleanup                  Block(s)    0</span><br><span class="line">Writing:   Extension record                        Start Block 100</span><br><span class="line">Done with: Extension record                        Block(s)    1</span><br><span class="line">Writing:   The File(s)                             Start Block 101</span><br><span class="line">  1.43% done, estimate finish Tue Nov 14 17:08:17 2017</span><br><span class="line">  2.87% done, estimate finish Tue Nov 14 17:08:17 2017</span><br><span class="line">  4.30% done, estimate finish Tue Nov 14 17:08:17 2017</span><br><span class="line"> ...</span><br><span class="line"> 95.89% done, estimate finish Tue Nov 14 17:08:18 2017</span><br><span class="line"> 97.33% done, estimate finish Tue Nov 14 17:08:18 2017</span><br><span class="line"> 98.76% done, estimate finish Tue Nov 14 17:08:18 2017</span><br><span class="line">Total translation table size: 106045</span><br><span class="line">Total rockridge attributes bytes: 46850</span><br><span class="line">Total directory bytes: 79872</span><br><span class="line">Path table size(bytes): 140</span><br><span class="line">Done with: The File(s)                             Block(s)    376656</span><br><span class="line">Writing:   Ending Padblock                         Start Block 376757</span><br><span class="line">Done with: Ending Padblock                         Block(s)    150</span><br><span class="line">Max brk space used 85000</span><br><span class="line">349350 extents written (736 MB</span><br></pre></td></tr></table></figure>
<h3 id="Hybird模式"><a href="#Hybird模式" class="headerlink" title="Hybird模式"></a>Hybird模式</h3><p>采用“hybird模式”（混合模式），操作系统可以直接刻录成物理光盘，也可以直接做成可引导的U盘。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isohybrid -v /ISO/CentOS-7-custom.iso</span><br></pre></td></tr></table></figure></p>
<h3 id="制作镜像MD5值"><a href="#制作镜像MD5值" class="headerlink" title="制作镜像MD5值"></a>制作镜像MD5值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implantisomd5 /ISO/CentOS-7-ChenjianOS.iso</span><br><span class="line"></span><br><span class="line">&lt;&lt;&apos;COMMENT&apos;</span><br><span class="line">Inserting md5sum into iso image...</span><br><span class="line">md5 = ed6233dc8bf6e59353a646e286b7a51f</span><br><span class="line">Inserting fragment md5sums into iso image...</span><br><span class="line">fragmd5 = 4c9fb671374f6b26bdaf49d5452ec7862f97e3899f9eac23a7e8f4f84d25</span><br><span class="line">frags = 20</span><br><span class="line">Setting supported flag to 0</span><br><span class="line">COMMENT</span><br></pre></td></tr></table></figure>
<h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><blockquote>
<p>iso安装系统不再叙述；</p>
</blockquote>
<blockquote>
<p>由于是text模式，则进入安装界面，会有一个类似图形安装界面的排版，里面可以选择。所有选择均为x的时候，表示正常无误;有!的话，则为错误。错误时需要查看日志，其中Alt+F1快捷键可以进入main界面，Alt+F2快捷键可以进入Shell界面等等。在Shell界面中，可以从/tmp/packaging.log中找到rpm包日志，可以从/tmp/anaconda.log中找到安装过程中的报错日志;可以从/run/install/repo路径下找到外部文件夹；</p>
</blockquote>
<blockquote>
<p>当选项均为x时，即表示正常无误，可以不进行操作，其自动进入下一步安装过程，直至安装成功，然后自动重启，显示登录界面。</p>
</blockquote>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.cnblogs.com/fantasyxo/p/14434035.html" target="_blank" rel="noopener">https://www.cnblogs.com/fantasyxo/p/14434035.html</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>持续交付总结一</title>
    <url>/2019/10/04/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E6%80%BB%E7%BB%93%E4%B8%80/</url>
    <content><![CDATA[<h4 id="持续交付的难点"><a href="#持续交付的难点" class="headerlink" title="持续交付的难点"></a>持续交付的难点</h4><ol>
<li>实施“持续交付”，将会影响整个的研发生命周期，会涉及到流程、团队、工具等多个方面。因为，实施“持续交付”需要组织从上到下的认可，需要有大勇气将一些可能属于黑箱操作的工作，公开出来给大家监督。所以这样的事情很难推进。</li>
<li>实施“持续交付”，对实施者和参与者的要求都很高，他们不仅需要了解开发，还要了解流程，了解测试，了解运维，甚至还需要有一定的架构知识和管理知识。</li>
<li>实施“持续交付”，大多数团队都希望能够快速见效，立竿见影。但是，“持续交付”的改进过程本身就是一个持续迭代的过程，需要多次循环才能体现效果。</li>
</ol>
<h4 id="持续交付的误区"><a href="#持续交付的误区" class="headerlink" title="持续交付的误区"></a>持续交付的误区</h4><ol>
<li>过度强调自动化。</li>
<li>过度强调流程化。</li>
<li>过度强调特殊化。</li>
</ol>
<h4 id="持续交付的价值"><a href="#持续交付的价值" class="headerlink" title="持续交付的价值"></a>持续交付的价值</h4><ol>
<li>从编码到构建再到测试的反复持续过程，就叫作“持续集成”。</li>
<li>在“持续集成”之后，获取外部对软件的反馈再通过“持续集成”进行优化的过程就叫作“持续交付”，它是“持续集成”的自然延续。</li>
<li>持续部署”就是将可交付产品，快速且安全地交付用户使用的一套方法和系统，它是“持续交付”的最后“一公里”。</li>
</ol>
<p>持续交付也通常以“发布流水线”的方式来解释，即研发团队从开发，到测试，再到部署，最终将产品交付给最终用户使用的过程。<br><img src="/2019/10/04/持续交付总结一/cd1.png" alt="avatar"><br>持续交付的价值不仅仅局限于简单地提高产品交付的效率，它还通过统一标准、规范流程、工具化、自动化等等方式，影响着整个研发生命周期。<br>持续交付最终的使命是打破一切影响研发的“阻碍墙”，为软件研发工作本身赋能。无论你是持续交付的老朋友还是新朋友，无论你在公司担任管理工作还是普通的研发人员，持续交付都会对你的工作产生积极的作用。</p>
<h4 id="影响持续集成的因素"><a href="#影响持续集成的因素" class="headerlink" title="影响持续集成的因素"></a>影响持续集成的因素</h4><ol>
<li>组织和文化因素</li>
</ol>
<ul>
<li>紧密配合，这是组织发展，部门合作的基础。</li>
<li>集思广益，这就需要组织内各个不同部门，或不同职能的角色，跳出自身的“舒适区”。</li>
<li>自我驱动，是理想中的完美组织形式。</li>
</ul>
<ol start="2">
<li>流程因素</li>
</ol>
<ul>
<li>耗时较长的流程。</li>
<li>完全人工类的流程。</li>
<li>信息报备类的流程。</li>
</ul>
<ol start="3">
<li>架构因素<br><strong>系统架构</strong><br>系统架构指系统的组成结构，它决定了系统的运行模式，层次结构，调用关系等。我们通常会遇到的系统架构包括：</li>
</ol>
<ul>
<li>单体架构，一个部署包，包含了应用所有功能；</li>
<li>SOA 架构，面向服务，通过服务间的接口和契约联系；</li>
<li>微服务架构，按业务领域划分为独立的服务单元，可独立部署，松耦合。<br><strong>部署架构</strong><br>部署架构指的是，系统在各种环境下的部署方法，验收标准，编排次序等的集合。它将直接影响你持续交付的“最后一公里”。</li>
<li>首先，你需要考虑，是否有统一的部署标准和方式。</li>
<li>其次，需要考虑发布的编排次序。</li>
<li>再次，是 markdown 与 markup 机制。</li>
<li>最后，是预热与自检。</li>
</ul>
<h4 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h4><p>目前，人们对 DevOps 的看法，可以大致概括为 DevOps 是一组技术，一个职能、一种文化，和一种组织架构四种。</p>
<ol>
<li>DevOps 的本质其实是一种鼓励协作的研发文化；</li>
<li>持续交付与 DevOps 所追求的最终目标是一致的，即快速向用户交付高质量的软件产品；</li>
<li>DevOps 的概念比持续交付更宽泛，是持续交付的继续延伸；</li>
<li>持续交付更专注于技术与实践，是 DevOps 的工具及技术实现。</li>
</ol>
<h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><ol>
<li>代码分支策略</li>
</ol>
<ul>
<li>主干开发（TBD）是一个源代码控制的分支模型，开发者在一个称为 “trunk” 的分支（Git 称 master） 中对代码进行协作，除了发布分支外没有其他开发分支。<br><img src="/2019/10/04/持续交付总结一/cd2.png" alt="avatar"></li>
<li>Git Flow<br><img src="/2019/10/04/持续交付总结一/cd3.png" alt="avatar"></li>
<li>GitHub Flow<br>在 GitHub Flow 中，master 分支中包含稳定的代码，它已经或即将被部署到生产环境。任何开发人员都不允许把未测试或未审查的代码直接提交到 master 分支。对代码的任何修改，包括 Bug 修复、热修复、新功能开发等都在单独的分支中进行。不管是一行代码的小改动，还是需要几个星期开发的新功能，都采用同样的方式来管理。<br><img src="/2019/10/04/持续交付总结一/cd4.png" alt="avatar"></li>
<li>GitLab Flow<br><img src="/2019/10/04/持续交付总结一/cd5.png" alt="avatar"><br>通过 Git Flow、GitHub Flow 和 GitLab Flow（3 个衍生类别） 这几个具体模型的介绍，我给你总结一下特性分支开发的优缺点。<br><img src="/2019/10/04/持续交付总结一/cd6.png" alt="avatar"></li>
<li>选出最适合的分支策略<br>总体归纳一下什么情况下应该选择什么样的分支策略<br><img src="/2019/10/04/持续交付总结一/cd7.png" alt="avatar"></li>
</ul>
<ol start="2">
<li>依赖管理</li>
</ol>
<ul>
<li>统一的命名规则，也可以说是坐标，在仓库中是唯一的，可以被准确定位到；</li>
<li>统一的中心仓库可以存储管理依赖和元数据；</li>
<li>统一的依赖配置描述文件；</li>
<li>本地使用的客户端可以解析上述的文件以及拉取所需的依赖。</li>
</ul>
<ol start="3">
<li>Maven最佳实践</li>
</ol>
<ul>
<li>生产环境尽量不使用 SNAPSHOT 或者是带有范围的依赖版本，可以减少上线后的不确定性，我们必须保证，测试环境的包和生产环境是一致的。</li>
<li>将 POM 分成多个层次的继承关系，这样做的好处是每一层都可以定义这一级别的依赖。</li>
<li>在父模块多使用 dependencyManagement来定义依赖，子模块在使用该依赖时，就可以不用指定依赖的版本，这样做可以使多个子模块的依赖版本高度统一，同时还能简化子模块配置。</li>
<li>对于一组依赖的控制，可以使用 BOM（Bill of Materials） 进行版本定义。一般情况下，框架部门有一个统一的 BOM 来管理公共组件的版本，当用户引用了该BOM后，在使用框架提供的组件时无需指定版本。即使使用了多个组件，也不会有版本冲突的问题，因为框架部门的专家们已经在BOM中为各个组件配置了经过测试的稳定版本。</li>
<li>对于版本相同的依赖使用 properties 定义，可以大大减少重复劳动，且易于改动。上面的 pom.xml 片段，就是使用了 properties 来定义两个一样的版本号的依赖。</li>
<li>不要在在线编译环境中使用 mvn install 命令，否则会埋下很多意想不到并且非常难以排查的坑：该命令会将同项目中编译产生的 jar 包缓存在编译系统本地，覆盖 mvn 仓库中真正应该被引用的 jar 包。</li>
<li>禁止变更了代码不改版本号就上传到中央仓库的行为。否则，会覆盖原有版本，使得一个版本出现二义性的问题。</li>
</ul>
<ol start="4">
<li>代码回滚<br><strong> 代码回滚定义 </strong><br>包回滚是指，线上运行的系统，从现在的版本回滚到以前稳定的老版本。<br>代码回滚是指，Git 分支的指针（游标），从指向当前有问题的版本改为指向一个该分支历史树上没问题的版本，而这个版本可以是曾经的 commit，也可以是新建的 commit。<br><strong> 回滚场景 </strong><br>第一种情况：开发人员独立使用的分支上，如果最近产生的 commit 都没有价值，应该废弃掉，此时就需要把代码回滚到以前的版本。<br>第二种情况：代码集成到团队的集成分支且尚未发布，但在后续测试中发现这部分代码有问题，且一时半会儿解决不掉，为了不把问题传递给下次的集成，此时就需要把有问题的代码从集成分支中回滚掉。<br>第三种情况：代码已经发布到线上，线上包回滚后发现是新上线的代码引起的问题，且需要一段时间修复，此时又有其他功能需要上线，那么主干分支必须把代码回滚到产品包 V0529 对应的 commit。<br><strong> 代码回滚必须遵循的原则 </strong><br>集成分支上的代码回滚坚决不用 reset –hard 的方式，原因如下：<br>集成分支上的 commit 都是项目阶段性的成果，即使最近的发布不需要某些 commit 的功能，但仍然需要保留这些 commit ，以备后续之需。<br>开发人员会基于集成分支上的 commit 拉取新分支，如果集成分支采用 reset 的方式清除了该 commit ，下次开发人员把新分支合并回集成分支时，又会把被清除的 commit 申请合入，很可能导致不需要的功能再次被引入到集成分支。<br><strong> 回滚场景及回滚策略 </strong><br><img src="/2019/10/04/持续交付总结一/cd8.png" alt="avatar"><br>第一，个人分支回滚<br><img src="/2019/10/04/持续交付总结一/cd9.png" alt="avatar"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout feature-x   </span><br><span class="line">$ git reset --hard  C3 的 HASH 值</span><br><span class="line">$ git push -f origin  feature-x</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>第二，集成分支上线前回滚<br><img src="/2019/10/04/持续交付总结一/cd10.png" alt="avatar"><br>假定走特性分支开发模式，上面的 commit 都是特性分支通过 merge request 合入 master 产生的 commit。<br>集成后，测试环境中发现 C4 和 C6 的功能有问题，不能上线，需马上回滚代码，以便 C5 的功能上线。<br>团队成员可以在 GitLab 上找到 C4 和 C6 合入 master 的合并请求，然后点击 revert 。如下图所示。<br><img src="/2019/10/04/持续交付总结一/cd11.png" alt="avatar"><br>回滚后 master 分支变成如图 5 所示，C4’是 revert C4 产生的 commit，C6’是 revert C6 产生的 commit。通过 revert 操作，C4 和 C6 变更的内容在 master 分支上就被清除掉了，而 C5 变更的内容还保留在 master 分支上。<br><img src="/2019/10/04/持续交付总结一/cd12.png" alt="avatar"><br>第三，集成分支上线后回滚<br><img src="/2019/10/04/持续交付总结一/cd13.png" alt="avatar"><br>C3 打包并上线，生成线上的版本 V0529，运行正确。之后 C6 也打包并上线，生成线上版本 V0530，运行一段时间后发现有问题。C4 和 C5 并没有单独打包上线，所以没有对应的线上版本。<br>项目组把产品包从 V0530 回滚到 V0529，经过定位，V0530 的代码有问题，但短时间不能修复，于是，项目组决定回滚代码。<br>C4 和 C5 没有单独上过线，因此从线上包的角度看，不能回滚到 C4 或 C5，应该回滚到 C3。<br>考虑到线上包可以回滚到曾发布过的任意一个正确的版本。为了适应线上包的这个特点，线上包回滚触发的代码回滚我们决定不用 一个个 revert C4、C5 和 C6 的方式，而是直接创建一个新的 commit，它的内容等于 C3 的内容。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch origin  </span><br><span class="line">$ git checkout master</span><br><span class="line">$ git reset --hard  V0529         # 把本地的 master 分支的指针回退到 V0529，此时暂存区 (index) 里就指向 V0529 里的内容了。</span><br><span class="line">$ git reset --soft  origin/master  # --soft 使得本地的 master 分支的指针重新回到 V0530，而暂存区 (index) 变成 V0529 的内容。</span><br><span class="line">$ git commit -m &quot;rollback to V0529&quot;  # 把暂存区里的内容提交，这样一来新生成的 commit 的内容和 V0529 相同。 </span><br><span class="line">$ git push origin  master        # 远端的 master 也被回滚。</span><br></pre></td></tr></table></figure></p>
<p>回滚后如下图所示。<br><img src="/2019/10/04/持续交付总结一/cd14.png" alt="avatar"><br>C3’的内容等于 C3，master 分支已清除 C4、C5 和 C6 的变更。<br>现在 master 又回到了正确的状态，其他功能可以继续上线。<br>如果要修复 C4、C5 和 C6 的问题，可以在开发分支上先 revert 掉 C3’ ，这样被清除的几个 commit 的内容又恢复了。</p>
]]></content>
      <tags>
        <tag>CI&amp;CD</tag>
      </tags>
  </entry>
  <entry>
    <title>持续交付总结二</title>
    <url>/2019/10/05/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E6%80%BB%E7%BB%93%E4%BA%8C/</url>
    <content><![CDATA[<h5 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h5><ol>
<li>互联网公司的环境会包括：开发环境、功能测试环境、验收测试环境、预发布环境和生产环境这 5 套。</li>
<li>测试环境的目的是要保证最终将交付的软件产品的质量，所以好用的测试环境，不能从规模、性能和作用的角度来评判，而应该是从它能否满足用户需求去保证软件质量的角度进行定义，于是得出：当一个环境可以满足其真正核心用户的需求时, 就是一个好用的测试环境。</li>
<li>测试环境的功能要求如下：</li>
</ol>
<ul>
<li>可得性，即在开发一个新项目时，能快速获取构建一个环境需要的机器，基础设施。最好的情况是，能随时可得，随时归还。</li>
<li>快速部署，即在搭建新环境时，能以最快的速度构建出一整套完整的环境。测试环境的部署很频繁，在代码提交后，能在很短的时间内构建代码，在环境上更新，就能更早开始测试。</li>
<li>独立性，即一个环境在使用过程中，可以不受其他项目测试人员的干扰。</li>
<li>稳定性，即不会因为下游服务，基础设施的异常，造成测试中断、等待。</li>
<li>高仿真，主要分为两个方面：“测试数据真实”，即能在测试环境构建出真实的测试用例；“环境真实”，即基础服务的架构和行为与线上环境保持一致，避免因为环境不一致造成测试结果不一致。</li>
</ul>
<ol start="4">
<li>成本和效率的问题</li>
</ol>
<ul>
<li>第一个关键点是抽象公共环境，而其中的公共服务基本都属于底层服务，相对比较稳定，这是解耦环境的重中之重。在公共环境的基础上，可以通过泳道的方式隔离相关测试应用，利用LB和SOA中间件对路由功能的支持，在一个大的公共集成测试环境中隔离出一个个独立的功能测试环境，那么增加的机器成本就仅与被并行的项目多少有关系了。</li>
<li>第二，避免产生多套公共环境。</li>
<li>第三，减轻配置的复杂度。</li>
</ul>
<ol start="5">
<li>环境配置的目标与标准<br>从面向的目标来看，环境配置大体上可以分为两大部分：<br>以环境中每台服务器为对象的运行时配置；<br>以一个环境为整体目标的独立环境配置。<br><strong> 环境一定要标准化 </strong><br>所谓标准化，就是为了在一定范围内获得最佳秩序，对实际的或潜在的问题制定共同、可重复使用的规则。</li>
</ol>
<ul>
<li>规定公司的主流语言栈；</li>
<li>统一服务器安装镜像；</li>
<li>提供默认的运行时配置模板；</li>
<li>统一基础软件的版本，以及更新方式；</li>
<li>在架构层面统一解决环境路由问题；</li>
<li>自动化环境产生过程。<br>在实施持续交付的同时，去推动形成以下几个方面的规范：</li>
<li>代码及依赖规范；</li>
<li>命名规范；</li>
<li>开发规范；</li>
<li>配置规范；</li>
<li>部署规范；</li>
<li>安全规范；</li>
<li>测试规范</li>
</ul>
<ol start="6">
<li>配置的相关内容<br>配置管理： 是通过技术或行政手段对软件产品及其开发过程和生命周期进行控制、规范的一系列措施。它的目标是记录软件产品的演化过程，确保软件开发者在软件生命周期的各个阶段都能得到精确的产品配置信息。<br>配置： 是指独立于程序之外，但又对程序产生作用的可配变量。也就是说，同一份代码在不同的配置下，会产生不同的运行结果。<br>从上面的定义中，你可以看到配置和配置管理有着本质上的不同：配置管理服务于软件研发过程，而配置则服务于程序本身。</li>
<li>常用的配置方法</li>
</ol>
<ul>
<li>构建时配置：方案看起来很简单，但它依赖于某个特定的构建工具，而且使用方法不统一；每次都要重新编译，浪费计算资源。</li>
<li>打包时配置： 构建时完全不清楚程序所要部署的环境，因此只完成最基本的默认配置；而发布时清晰地知晓环境信息，因此可根据环境信息，进行相关配置的替换。</li>
<li>运行时配置：修改后实时生效；支持灰度发布；能分环境、分集群管理配置；有完善的权限、审核机制。 </li>
<li>问题：先回滚配置还是先回滚代码就成了一个死循环的问题。最好的办法是保证配置与代码的兼容性，这有点类似于数据库的 schema 变更。一定要注意配置的回滚问题。因为，无论是回滚还是不回滚，它没有标准答案，这个复杂问题必须按当时情况作出相对应的处理。</li>
</ul>
<ol start="7">
<li>搭建测试环境的流程</li>
</ol>
<ul>
<li>可以使用虚拟机资源池，提升获取机器资源的速度；</li>
<li>合理打造并行的应用部署流水线，是进一步提升环境创建速度的方法；</li>
<li>利用配置等方式快速达到环境变更需求，可以再次有效地提升整个环境部署的效率。</li>
</ul>
<ol start="8">
<li>容器带来的改变<br><strong>重新定义交付标准</strong><br>容器技术统一了软件环境和软件代码，交付产物中既包括了软件环境，又包括了软件代码。也就是说，容器帮我们重新定义了交付标准。被重新定义后的交付，有如下特点：</li>
</ol>
<ul>
<li>第一，交付结果一致；</li>
<li>第二，交付自动化；</li>
<li>第三，交付个性化；</li>
<li>第四，交付版本控制；</li>
</ul>
<h5 id="构建集成"><a href="#构建集成" class="headerlink" title="构建集成"></a>构建集成</h5><ol>
<li>构建提速的方式</li>
</ol>
<ul>
<li>升级硬件资源，最直接和粗暴的提速方式；</li>
<li>搭建私有仓库，避免从外网下载依赖；</li>
<li>使用本地缓存，减少每次构建时依赖下载的消耗；</li>
<li>规范构建流程，通过异步方式解决旁支流程的执行；</li>
<li>善用构建工具，根据实际情况合理发挥的工具特性。</li>
</ul>
<ol start="2">
<li>构建检测的方式</li>
</ol>
<ul>
<li>Maven Enforcer 插件可以帮我们更好地完成编译检测；</li>
<li>可以使用内置的 Maven Enforcer 规则，覆盖常规检测；</li>
<li>可以使用自定义 Maven Enforcer 检查规则的方式，增加版本号规则等的检查；</li>
<li>Maven Enforcer 之外，你还可以自己丰富一些例如依赖版本检测这样的服务，以提高检测效果。</li>
<li><a href="https://maven.apache.org/enforcer/enforcer-rules/index.html" target="_blank" rel="noopener">https://maven.apache.org/enforcer/enforcer-rules/index.html</a> </li>
<li><a href="http://www.mojohaus.org/extra-enforcer-rules/" target="_blank" rel="noopener">http://www.mojohaus.org/extra-enforcer-rules/</a></li>
</ul>
<ol start="3">
<li>镜像的安全规则</li>
</ol>
<ul>
<li>基础镜像来自于 Docker 官方认证的，并做好签名检查；</li>
<li>不使用 root 启动应用进程；</li>
<li>不在镜像保存密码，Token 之类的敏感信息；</li>
<li>不使用 –privileged 参数标记使用特权容器；</li>
<li>安全的 Linux 内核、内核补丁。如 SELinux，AppArmor，GRSEC 等。</li>
</ul>
<h5 id="发布及监控"><a href="#发布及监控" class="headerlink" title="发布及监控"></a>发布及监控</h5><ol>
<li>发布的需求点：</li>
</ol>
<ul>
<li>易用：执行脚本就好，填入参数，一键执行。</li>
<li>快速：自动化肯定比手工快，并且有提升空间。比如，因为有版本的概念，我们可以跳过相同版本的部署，或是某些步骤。</li>
<li>稳定：因为这个程序逻辑比较简单，而且执行步骤并不多，没有交叉和并行，所以稳定性也没什么大的挑战。</li>
<li>容错性强：表现一般，脚本碰到异常状况只能停下来，但因为版本间是隔离的，不至于弄坏老的服务，通过人工介入仍能恢复。</li>
<li>回滚顺滑：因为每个版本都是完整的可执行产物，所以回滚可以视作使用旧版本重新做一次发布。甚至我们可以在目标机器上缓存旧版本产物，实现超快速回滚。</li>
</ul>
<ol start="2">
<li>几种常见的灰度方式</li>
</ol>
<ul>
<li>蓝绿发布，是先增加一套新的集群，发布新版本到这批新机器，并进行验证，新版本服务器并不接入外部流量。此时旧版本集群保持原有状态，发布和验证过程中老版本所在的服务器仍照常服务。验证通过后，流控处理把流量引入新服务器，待全部流量切换完成，等待一段时间没有异常的话，老版本服务器下线。<br>这种发布方法需要额外的服务器集群支持，对于负载高的核心应用机器需求可观，实现难度巨大且成本较高。<br>蓝绿发布的好处是所有服务都使用这种方式时，实际上创造了蓝绿两套环境，隔离性最好、最可控，回滚切换几乎没有成本。</li>
<li>滚动发布，是不添加新机器，从同样的集群服务器中挑选一批，停止上面的服务，并更新为新版本，进行验证，验证完毕后接入流量。重复此步骤，一批一批地更新集群内的所有机器，直到遍历完所有机器。<br>这种滚动更新的方法比蓝绿发布节省资源，但发布过程中同时会有两个版本对外提供服务，无论是对自身或是调用者都有较高的兼容性要求，需要团队间的合作妥协。但这类问题相对容易解决，实际中往往会通过功能开关等方式来解决。</li>
<li>金丝雀发布，从集群中挑选特定服务器或一小批符合要求的特征用户，对其进行版本更新及验证，随后逐步更新剩余服务器。这种方式，比较符合携程对灰度发布的预期，但可能需要精细的流控和数据的支持，同样有版本兼容的需求。</li>
</ul>
<ol start="3">
<li>不可变模型和三种模型<br>对任何的包、配置文件、软件应用和数据，都不做 CRUD（创建、替换、更新、删除）操作。<br><strong> 发散模型 </strong><br>是我们通常会碰到的基础设施的管理模型。在这个模型中，基础设施随着我们的想法而变化，也就是我们想更新什么就更新什么，最终就会形成一种发散的形态。<br><img src="/2019/10/05/持续交付总结二/2cd1.png" alt="avatar"><br><strong> 收敛模型 </strong><br>是 Puppet 和 Chef 遵循的设计原则。随着时间推移，目标和实际需求汇聚，达到一致。通过这个模型，我们有了可扩展的基础设施的基础和实现。<br><img src="/2019/10/05/持续交付总结二/2cd2.png" alt="avatar"><br><strong> 一致模型 </strong><br>指的是整个基础设施始终把每一天当成是与第一天相同的模型。根据我们之前的假设，达到这一目的的关键点就在于，有序地正确执行从真正的第一天开始的所有变更。<br><img src="/2019/10/05/持续交付总结二/2cd3.png" alt="avatar"></li>
<li>发布系统的设计理念</li>
</ol>
<ul>
<li>1 张页面展示发布信息，且仅有 1 张页面，展示发布当时的绝大多数信息、数据和内容，这个页面既要全面，又要精准。</li>
<li>2 个操作按钮简化使用，即页面上除了“回滚”按钮常在外，最多同时展示 2 个操作按钮。目的是要降低发布系统的使用难度，做到“谁开发，谁运行”。</li>
<li>3 种发布结果，即成功、失败和中断状态，目的是简单、明了地显示用户最关心的发布结果。</li>
<li>4 类操作选择，包括开始发布、停止发布、发布回退、发布重试，目的是使状态机清晰明了。</li>
<li>5 个发布步骤，即 markdown、download、install、verify 和 markup。这里需要注意到的是，verify 这步包含了预热，由于耗时往往比较长，一般采用异步的处理方式。</li>
<li>6 大页面主要内容，包括集群、实例、发布日志、发布历史、发布批次、发布操作，来统一、简洁而又详细呈现发布中和未发布时的各种信息。</li>
</ul>
<ol start="5">
<li>监控的几种分类</li>
</ol>
<ul>
<li>用户侧监控，可以通过打点收集，或者定期采集日志的方式进行数据收集；</li>
<li>网络监控，通过模拟手段或定期采样进行收集；</li>
<li>业务监控，需要定义正确的指标以及相匹配的采集技术，务必注意实时性；</li>
<li>应用监控，可以通过中间件打点采集，也可以通过日志联合分析进行数据采集；</li>
<li>系统监控，通常采用定期采样的方式收集数据。</li>
</ul>
]]></content>
      <tags>
        <tag>CI&amp;CD</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-Tree小结</title>
    <url>/2021/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Tree%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h4 id="树的基本操作"><a href="#树的基本操作" class="headerlink" title="树的基本操作"></a>树的基本操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode(object):</span><br><span class="line">    def __init__(self, value):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class OperationTree(object):</span><br><span class="line"></span><br><span class="line">    def query(self, root, data):</span><br><span class="line">        if root is None:</span><br><span class="line">            return None</span><br><span class="line">        if root.value == data:</span><br><span class="line">            return root</span><br><span class="line">        elif root.left:</span><br><span class="line">            return self.query(root.left, data)</span><br><span class="line">        elif root.right:</span><br><span class="line">            return self.query(root.right, data)</span><br><span class="line"></span><br><span class="line">    def pre_order(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return None</span><br><span class="line">        print(root.value, end=&quot; &quot;)</span><br><span class="line">        self.pre_order(root.left)</span><br><span class="line">        self.pre_order(root.right)</span><br><span class="line"></span><br><span class="line">    def in_order(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return None</span><br><span class="line">        self.in_order(root.left)</span><br><span class="line">        print(root.value, end=&quot; &quot;)</span><br><span class="line">        self.in_order(root.right)</span><br><span class="line"></span><br><span class="line">    def back_order(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return None</span><br><span class="line">        self.back_order(root.left)</span><br><span class="line">        self.back_order(root.right)</span><br><span class="line">        print(root.value, end=&quot; &quot;)</span><br></pre></td></tr></table></figure>
<h4 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树(BST)"></a>二叉查找树(BST)</h4><p>二叉查找树，Binary Search Tree，或者称为二叉搜索树。</p>
<p><strong>性质：</strong></p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ul>
<p>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(logn)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, value):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BinarySearchTree(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, root):</span><br><span class="line">        self.root = root</span><br><span class="line"></span><br><span class="line">    def depth(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return None</span><br><span class="line">        else:</span><br><span class="line">            return 1 + max(self.depth(root.left), self.depth(root.right))</span><br><span class="line"></span><br><span class="line">    def insert(self, root, value):</span><br><span class="line"></span><br><span class="line">        if root is None:</span><br><span class="line">            root = TreeNode(value)</span><br><span class="line">        elif root.value &gt; value:</span><br><span class="line">            root.left = self.insert(root.left, value)</span><br><span class="line">        elif root.value &lt; value:</span><br><span class="line">            root.right = self.insert(root.right, value)</span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def search1(self, root, value):</span><br><span class="line">        if root is None:</span><br><span class="line">            return None</span><br><span class="line">        if root.value == value:</span><br><span class="line">            return root</span><br><span class="line">        elif root.value &lt; value:</span><br><span class="line">            return self.search1(root.right, value)</span><br><span class="line">        elif root.value &gt; value:</span><br><span class="line">            return self.search1(root.left, value)</span><br><span class="line"></span><br><span class="line">    def search2(self, root, value):</span><br><span class="line">        while root is not None and root.value != value:</span><br><span class="line">            if root.value &gt; value:</span><br><span class="line">                root = root.left</span><br><span class="line">            elif root.value &lt; value:</span><br><span class="line">                root = root.right</span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def max_value1(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        if root.right is None:</span><br><span class="line">            return root.value</span><br><span class="line">        else:</span><br><span class="line">            return self.max_value1(root.right)</span><br><span class="line"></span><br><span class="line">    def max_value2(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        while root.right is not None:</span><br><span class="line">            root = root.right</span><br><span class="line">        return root.value</span><br><span class="line"></span><br><span class="line">    def min_value1(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        if root.left is None:</span><br><span class="line">            return root.value</span><br><span class="line">        else:</span><br><span class="line">            return self.min_value1(root.left)</span><br><span class="line"></span><br><span class="line">    def min_value2(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        while root.left is not None:</span><br><span class="line">            root = root.left</span><br><span class="line">        return root.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    a = TreeNode(15)</span><br><span class="line">    b = TreeNode(6)</span><br><span class="line">    c = TreeNode(18)</span><br><span class="line">    d = TreeNode(4)</span><br><span class="line">    e = TreeNode(8)</span><br><span class="line">    f = TreeNode(17)</span><br><span class="line">    g = TreeNode(20)</span><br><span class="line">    h = TreeNode(13)</span><br><span class="line">    i = TreeNode(9)</span><br><span class="line">    a.left = b</span><br><span class="line">    a.right = c</span><br><span class="line">    b.left = d</span><br><span class="line">    b.right = e</span><br><span class="line">    c.left = f</span><br><span class="line">    c.right = g</span><br><span class="line">    e.right = h</span><br><span class="line">    h.left = i</span><br><span class="line">    bst = BinarySearchTree(a)</span><br><span class="line">    print(bst.search1(a, 13).value)</span><br><span class="line">    print(bst.search2(a, 13))</span><br><span class="line">    print(bst.insert(a, 23))</span><br><span class="line">    print(bst.max_value1(a))</span><br><span class="line">    print(bst.max_value2(a))</span><br><span class="line">    print(bst.min_value1(a))</span><br><span class="line">    print(bst.min_value2(a))</span><br></pre></td></tr></table></figure>
<h4 id="平衡二叉树-AVL-：旋转耗时"><a href="#平衡二叉树-AVL-：旋转耗时" class="headerlink" title="平衡二叉树(AVL)：旋转耗时"></a>平衡二叉树(AVL)：旋转耗时</h4><p>在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>
<p>AVL树本质上还是一棵二叉搜索树，它的特点是：</p>
<ol>
<li>本身首先是一棵二叉搜索树。</li>
<li>带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。</li>
</ol>
<p>也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。</p>
<p><strong>旋转</strong></p>
<ul>
<li>单向右旋平衡处理LL：由于在<em>a的左子树根结点的左子树上插入结点，</em>a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行一次右旋转操作；</li>
<li>单向左旋平衡处理RR：由于在<em>a的右子树根结点的右子树上插入结点，</em>a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行一次左旋转操作；</li>
<li>双向旋转（先左后右）平衡处理LR：由于在<em>a的左子树根结点的右子树上插入结点，</em>a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行两次旋转（先左旋后右旋）操作。</li>
<li>双向旋转（先右后左）平衡处理RL：由于在<em>a的右子树根结点的左子树上插入结点，</em>a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行两次旋转（先右旋后左旋）操作。</li>
</ul>
<p><img src="/2021/04/22/数据结构-Tree小结/tree1.png" alt="avatar"></p>
<p>查找、插入和删除在平均和最坏情况下的时间复杂度都是O ( log ⁡ n ) {\displaystyle O(\log {n})}O(logn).</p>
<p>由于旋转的耗时，AVL树在删除数据时效率很低；在删除操作较多时，维护平衡所需的代价可能高于其带来的好处，因此AVL实际使用并不广泛。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, value):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line">        self.height = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AVLTree(object):</span><br><span class="line"></span><br><span class="line">    def get_height(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        return root.height</span><br><span class="line"></span><br><span class="line">    def get_balance(self, root):</span><br><span class="line"></span><br><span class="line">        if root is None:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        return self.get_height(root.left) - self.get_height(root.right)</span><br><span class="line"></span><br><span class="line">    def right_rotate(self, root):</span><br><span class="line"></span><br><span class="line">        new_root = root.left</span><br><span class="line">        new_right = new_root.right</span><br><span class="line"></span><br><span class="line">        new_root.right = root</span><br><span class="line">        root.left = new_right</span><br><span class="line"></span><br><span class="line">        root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))</span><br><span class="line">        new_root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))</span><br><span class="line"></span><br><span class="line">        return new_root</span><br><span class="line"></span><br><span class="line">    def left_rotate(self, root):</span><br><span class="line"></span><br><span class="line">        new_root = root.right</span><br><span class="line">        new_left = new_root.left</span><br><span class="line"></span><br><span class="line">        new_root.left = root</span><br><span class="line">        root.right = new_left</span><br><span class="line"></span><br><span class="line">        root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))</span><br><span class="line">        new_root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))</span><br><span class="line"></span><br><span class="line">        return new_root</span><br><span class="line"></span><br><span class="line">    def insert(self, root, value):</span><br><span class="line"></span><br><span class="line">        if root is None:</span><br><span class="line">            root = TreeNode(value)</span><br><span class="line"></span><br><span class="line">        if root.value &lt; value:</span><br><span class="line">            root.right = self.insert(root.right, value)</span><br><span class="line">        elif root.value &gt; value:</span><br><span class="line">            root.left = self.insert(root.left, value)</span><br><span class="line"></span><br><span class="line">        root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))</span><br><span class="line"></span><br><span class="line">        balance = self.get_balance(root)</span><br><span class="line"></span><br><span class="line">        if balance &gt; 1 and value &lt; root.left.value:</span><br><span class="line">            return self.right_rotate(root)</span><br><span class="line"></span><br><span class="line">        if balance &lt; -1 and value &gt; root.right.value:</span><br><span class="line">            return self.left_rotate(root)</span><br><span class="line"></span><br><span class="line">        if balance &gt; 1 and value &gt; root.left.value:</span><br><span class="line">            root.left = self.left_rotate(root.left)</span><br><span class="line">            return self.right_rotate(root)</span><br><span class="line"></span><br><span class="line">        if balance &lt; -1 and value &lt; root.right.value:</span><br><span class="line">            root.right = self.right_rotate(root.right)</span><br><span class="line">            return self.left_rotate(root)</span><br></pre></td></tr></table></figure>
<h4 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h4><p>2-3-4树是一种阶为4的B树。它是一种自平衡的数据结构，可以保证在O(lgn)的时间内完成查找、插入和删除操作。它主要满足以下性质：</p>
<p>（1）每个节点每个节点有1、2或3个key，分别称为2（孩子）节点，3（孩子）节点，4（孩子）节点。</p>
<p>（2）所有叶子节点到根节点的长度一致（也就是说叶子节点都在同一层）。</p>
<p>（3）每个节点的key从左到右保持了从小到大的顺序，两个key之间的子树中所有的</p>
<p>key一定大于它的父节点的左key，小于父节点的右key。   </p>
<h4 id="红黑树：树太高"><a href="#红黑树：树太高" class="headerlink" title="红黑树：树太高"></a>红黑树：树太高</h4><p>2-3-4树和红黑树是完全等价的，由于绝大多数编程语言直接实现2-3-4树会非常繁琐，所以一般是通过实现红黑树来实现替代2-3-4树，而红黑树本也同样保证在O(lgn)的时间内完成查找、插入和删除操作。</p>
<p>红黑树是每个节点都带有颜色属性的平衡二叉查找树 ，颜色为红色或黑色。除了二叉查找树一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p>
<ul>
<li>节点是要么红色或要么是黑色。</li>
<li>根一定是黑色节点。</li>
<li>每个叶子结点都带有两个空的黑色结点（称之为NIL节点，它又被称为黑哨兵）。</li>
<li>每个红色节点的两个子节点都是黑色（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点）。</li>
<li>从任一节点到它所能到达得叶子节点的所有简单路径都包含相同数目的黑色节点。</li>
</ul>
<p>这些性质保证了根节点到任意叶子节点的路径长度，最多相差一半（因为路径上的黑色节点相等，差别只是不能相邻的红色节点个数），所以红黑树是一个基本平衡的二叉搜索树，它没有AVL树那么绝对平衡，但是同样的关键字组成的红黑树相比AVL旋转操作要少，而且删除操作也比AVL树效率更高，实际应用效果也比AVL树更出众。当然红黑树的具体实现也复杂的多。</p>
<p><img src="/2021/04/22/数据结构-Tree小结/red_tree.png" alt="avatar"></p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>一个m阶的B树具有如下几个特征：B树中所有结点的孩子结点最大值称为B树的阶，通常用m表示。一个结点有k个孩子时，必有k-1个关键字才能将子树中所有关键字划分为k个子集。</p>
<ol>
<li>根结点至少有两个子女。</li>
<li>每个中间节点都包含k-1个元素和k个孩子，其中 ceil（m/2） ≤ k ≤ m</li>
<li>每一个叶子节点都包含k-1个元素，其中 ceil（m/2） ≤ k ≤ m</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域划分</li>
<li>每个结点的结构为：（n，A0，K1，A1，K2，A2，…  ，Kn，An）。其中，Ki(1≤i≤n)为关键字，且Ki&lt;Ki+1(1≤i≤n-1)。<br>Ai(0≤i≤n)为指向子树根结点的指针。且Ai所指子树所有结点中的关键字均小于Ki+1。<br>n为结点中关键字的个数，满足ceil(m/2)-1≤n≤m-1。</li>
</ol>
<p><strong>查询</strong></p>
<p><img src="/2021/04/22/数据结构-Tree小结/tree2.png" alt="avatar"></p>
<p>以上图为例：若查询的数值为５： </p>
<p>第一次磁盘IO：在内存中定位（与17、35比较），比17小，左子树；<br>第二次磁盘IO：在内存中定位（与８、12比较），比８小，左子树；<br>第三次磁盘IO：在内存中定位（与3、5比较），找到5，终止。 </p>
<p>整个过程中，我们可以看出：比较的次数并不比二叉查找树少，尤其适当某一节点中的数据很多时，但是磁盘IO的次数却是大大减少。比较是在内存中进行的，相比于磁盘IO的速度，比较的耗时几乎可以忽略。所以当树的高度足够低的话，就可以极大的提高效率。相比之下，节点中的元素多点也没关系，仅仅是多了几次内存交互而已，只要不超过磁盘页的大小即可。</p>
<p><strong>插入</strong></p>
<p>对高度为ｋ的m阶B树，新结点一般是插在叶子层。通过检索可以确定关键码应插入的结点位置。然后分两种情况讨论： </p>
<ol>
<li>若该结点中关键码个数小于m-1，则直接插入即可。 </li>
<li>若该结点中关键码个数等于m-1，则将引起结点的分裂。以中间关键码为界将结点一分为二，产生一个新结点，并把中间关键码插入到父结点(ｋ-1层)中 </li>
</ol>
<p>重复上述工作，最坏情况一直分裂到根结点，建立一个新的根结点，整个B树增加一层。</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树是对B树的一种变形，与B树的差异在于：</p>
<p>一个m阶的B+树具有如下几个特征：</p>
<ol>
<li>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</li>
<li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</li>
</ol>
<p><img src="/2021/04/22/数据结构-Tree小结/tree3.png" alt="avatar"></p>
<p><strong>插入</strong></p>
<p>B+树的插入与B树的插入过程类似。不同的是B+树在叶结点上进行，如果叶结点中的关键码个数超过m，就必须分裂成关键码数目大致相同的两个结点，并保证上层结点中有这两个结点的最大关键码。</p>
<p><strong>删除</strong></p>
<p>B+树中的关键码在叶结点层删除后，其在上层的复本可以保留，作为一个”分解关键码”存在，如果因为删除而造成结点中关键码数小于ceil(m/2)，其处理过程与B-树的处理一样。在此，我就不多做介绍了。</p>
<p>B+树相比B树的优势： </p>
<ol>
<li>单一节点存储更多的元素，使得查询的IO次数更少； </li>
<li>所有查询都要查找到叶子节点，查询性能稳定； </li>
<li>所有叶子节点形成有序链表，便于范围查询。</li>
</ol>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol>
<li><a href="https://www.cnblogs.com/lliuye/p/9118591.html" target="_blank" rel="noopener">https://www.cnblogs.com/lliuye/p/9118591.html</a></li>
<li><a href="https://blog.csdn.net/qq_34364995/article/details/80787193" target="_blank" rel="noopener">https://blog.csdn.net/qq_34364995/article/details/80787193</a></li>
<li><a href="https://www.jb51.net/article/166572.htm" target="_blank" rel="noopener">https://www.jb51.net/article/166572.htm</a></li>
<li><a href="https://blog.csdn.net/rosefun96/article/details/108686365?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">https://blog.csdn.net/rosefun96/article/details/108686365?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242</a></li>
<li><a href="https://blog.csdn.net/dongcai1905/article/details/101890478" target="_blank" rel="noopener">https://blog.csdn.net/dongcai1905/article/details/101890478</a></li>
<li><a href="https://blog.csdn.net/u010853261/article/details/78217823" target="_blank" rel="noopener">https://blog.csdn.net/u010853261/article/details/78217823</a></li>
<li><a href="https://blog.csdn.net/liangjiubujiu/article/details/84023736" target="_blank" rel="noopener">https://blog.csdn.net/liangjiubujiu/article/details/84023736</a></li>
</ol>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈UML中常用的几种图</title>
    <url>/2020/02/27/%E6%B5%85%E8%B0%88UML%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9B%BE/</url>
    <content><![CDATA[<h4 id="UML简介"><a href="#UML简介" class="headerlink" title="UML简介"></a>UML简介</h4><p>统一建模语言（Unified Modeling Language，UML）又称标准建模语言，是始于1997年的一个OMG标准，它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持，包括由需求分析到规格，到构造和配置。‘UML感兴趣的可以阅读UML 1规 范，包含了UML 的所有知识内容。</p>
<h4 id="UML常见图分类"><a href="#UML常见图分类" class="headerlink" title="UML常见图分类"></a>UML常见图分类</h4><p>UML从考虑系统的不同角度出发，定义了用况图、类图、对象图、包图、状态图、活动图、序列图、通信图、构件图、部署图等10种图。<br>分类：<br>面向对象动态建模，用于建立行为的实体间行为交互的四种图：状态图(Stage Diagram)，序列图(Sequence Diagram)，协作图(Communication Diagram)，活动图(Activity Diagram) 。<br>“序列图”与“协作图”表述的是相似的消息，“活动图”是“状态图”的一种。</p>
<ul>
<li>静态结构图Static Structure Diagram<br>类图Class Diagram<br>对象图Object Diagram<br>用况图Use Case Diagram</li>
<li>交互图Interaction Diagram<br>顺序图Sequence Diagram<br>协作图Collaboration Diagram<br>状态图State chart Diagrams<br>活动图Activity Diagrams</li>
<li>实现图Implementation Diagrams<br>构件图Component Diagram<br>部署图Deployment Diagram</li>
</ul>
<h4 id="用框图（用例）"><a href="#用框图（用例）" class="headerlink" title="用框图（用例）"></a>用框图（用例）</h4><p>用例图，展现了一组用例、参与者（actor）以及它们之间的关系。<br>用例图从用户角度描述系统的静态使用情况，用于建立需求模型。(用于需求分析)</p>
<p>参与者（Actor）<br>　　在系统外部与系统直接交互的人或事物。需要注意以下两点：<br>　　1）参与者是角色而不是具体的人（可以是外部系统），它代表了参与者在与系统打交道的过程中所扮演的角色。所以在系统的实际运作中，一个实际用户可能对应系统的多个参与者。不同的用户也可以只对应于一个参与者，从而代表同一参与者的不同实例。<br>　　2）参与者作为外部用户（而不是内部）与系统发生交互作用，是它的主要特征。<br>在UML中，参与者使用如图所示的一个小人表示：<br>用例（Use Case）用况<br>   系统外部可见的一个系统功能单元。系统的功能由系统单元所提供，并通过一系列系统单元与一个或多个参与者之间交换的消息所表达。用椭圆表示，椭圆中的文字简述系统的功能;<br>关系（Relationship）<br>　　常见关系类型有关联、泛化、包含和扩展。<br>　　以上各关系在uml图中的表示方式，如下表所示：<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml1.png" alt="avatar"></p>
<ol>
<li>关联(Association)<br>　 表示参与者与用例之间的通信，任何一方都可发送或接受消息。<br>　【箭头指向】：指向消息接收方<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml2.png" alt="avatar"></li>
<li>泛化(Inheritance)<br>　　就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。<br>【箭头指向】：指向父用例<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml3.png" alt="avatar"></li>
<li>包含(Include)<br> 包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤。<br>　　【箭头指向】：指向分解出来的功能用例<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml4.png" alt="avatar"></li>
<li>扩展(Extend)<br>　　扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。<br>　　【箭头指向】：指向基础用例<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml5.png" alt="avatar"><br>包含(include)、扩展(extend)、泛化(Inheritance) 的区别：<br>　　条件性：泛化中的子用例和include中的被包含的用例会无条件发生，而extend中的延伸用例的发生是有条件的；<br>　　直接性：泛化中的子用例和extend中的延伸用例为参与者提供直接服务，而include中被包含的用例为参与者提供间接服务。<br>　　对extend（扩展）而言，延伸用例并不包含基础用例的内容，基础用例也不包含延伸用例的内容。<br>　　对Inheritance（泛化）而言，子用例包含基础用例的所有内容及其和其他用例或参与者之间的关系；</li>
</ol>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)</p>
<ol>
<li>泛化（Generalization）<br>【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。<br>【箭头指向】：带三角箭头的实线，箭头指向父类<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml6.png" alt="avatar"></li>
<li>实现（Realization）<br>【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.<br>【箭头指向】：带三角箭头的虚线，箭头指向接口<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml7.png" alt="avatar"></li>
<li>关联（Association)<br>【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。<br>【代码体现】：成员变量<br>【箭头及指向】：带普通箭头的实心线，指向被拥有者<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml8.png" alt="avatar"></li>
<li>聚合（Aggregation）<br>【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。<br>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<br>【代码体现】：成员变量<br>【箭头及指向】：带空心菱形的实心线，菱形指向整体<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml9.png" alt="avatar"></li>
<li>组合(Composition)<br>【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。<br>【代码体现】：成员变量<br>【箭头及指向】：带实心菱形的实线，菱形指向整体</li>
<li>依赖(Dependency)<br>【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.<br>【代码表现】：局部变量、方法的参数或者对静态方法的调用<br>【箭头及指向】：带箭头的虚线，指向被使用者<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml10.png" alt="avatar"></li>
</ol>
<p>各种关系的强弱顺序：<br>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖<br>下面这张UML图，比较形象地展示了各种类图关系：<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml11.png" alt="avatar"></p>
<h4 id="时序图-顺序图"><a href="#时序图-顺序图" class="headerlink" title="时序图(顺序图)"></a>时序图(顺序图)</h4><ol>
<li><p>时序图是以时间为序的表示方法，主要用来描述对象之间的时间顺序。将交互关系表示为二维图的。纵轴为时间，横轴为在协作中各个独立的对象。对象存在时用一条虚线表示，当对象的过程处于激活状态是，生命线是一个双道线。消息用从一个对象的生命线到另一个对象生命线的箭头表示。箭头以时间顺序在图中从上到下排列。如下图：<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml12.png" alt="avatar"></p>
</li>
<li><p>四个元素（对象，生命线，消息，激活）<br>（1）对象<br>对象的概念就不多说了，就是类的实例化，在系统中随便都可以找到一个对象，因为我们使用的是基于OO编程的VB。<br>（2）生命线<br>表示对象的存在存在多久的时间<br>（3）消息<br>对象之间的单路通信，人有人的语言，机器有机器的语言，人和机器都是靠消息传递信息和指令的。<br>消息的类型大致有：同步与异步，返回、阻止和超时。<br>（4）激活<br>表示这个时间，对象实现操作。时序图是将交互关系表示为二维图的。纵轴为时间，横轴为在协作中各个独立的对象。对象存在时用一条虚线表示，当对象的过程处于激活状态，生命线是一个双道线。消息用从一个对象的生命线到另一个对象生命线的箭头表示。箭头以时间顺序在图中从上到下排列。</p>
</li>
</ol>
<h4 id="协作图（Collaboration-Diagram-communication-Diagram）-通信图"><a href="#协作图（Collaboration-Diagram-communication-Diagram）-通信图" class="headerlink" title="协作图（Collaboration Diagram/communication Diagram）/通信图"></a>协作图（Collaboration Diagram/communication Diagram）/通信图</h4><p>协作图(Collaboration Diagram /Communication Diagram，也叫合作图)是一种交互图（interaction diagram），强调的是发送和接收消息的对象之间的组织结构。一个协作图显示了一系列的对象和在这些对象之间的联系以及对象间发送和接收的消息。对象通常是命名或匿名的类的实例，也可以代表其他事物的实例，例如协作、组件和节点。使用协作图来说明系统的动态情况。<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml13.png" alt="avatar"></p>
<h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><p>1.概述：<br>状态图（Statechart Diagram）主要用于描述一个特定的对象的所有可能状态以及由于各种事件的发生而引起的状态之间的转换。<br>2.构成要素：<br>状态图由状态、转移和事件组成。联合使用状态和转移可以更好地建模它们，有时需要包含决策点和同步条来显示更高层次的细节信息。<br>2.1状态（States）：<br>在对象的生命周期中满足某些条件、执行某些活动或等待某些事件的一个条件或状况。所有的对象都有状态，状态是对象执行了一系列活动的结果，当某个事件发生后，对象的状态将发生变化。<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml14.png" alt="avatar"><br>状态图中可以包含0个多个开始状态，也可以包含多个结束状态。模型不必同时具有开始和结束状态，因为模型可以总是运行，从不停止。<br>2.2转移（Transitions）：<br>两个状态之间的一种关系，表示对象将在第一个状态中执行一定的动作并在某个特定事件发生或某个特定条件满足时进入第二个状态。<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml15.png" alt="avatar"><br>2.3事件：<br>使状态发生变化的某时刻发生的动作或活动，用来指示是什么触发了转移从而导致状态发生了改变。事件通常在从一个状态到另一个状态的转移路径上直接指定。<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml16.png" alt="avatar"><br>2.4判断：<br>判断点通过对事件判断分组转移到各自方向，提高了状态图的可视性。<br><img src="/2020/02/27/浅谈UML中常用的几种图/uml17.png" alt="avatar"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2020/02/27/浅谈UML中常用的几种图/uml18.png" alt="avatar"></p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://blog.csdn.net/qq_35495763/article/details/80764914" target="_blank" rel="noopener">https://blog.csdn.net/qq_35495763/article/details/80764914</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列小结</title>
    <url>/2021/05/29/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h4 id="消息队列优势劣势"><a href="#消息队列优势劣势" class="headerlink" title="消息队列优势劣势"></a>消息队列优势劣势</h4><p>消息队列最常被使用的三种场景：异步处理、流量控制和服务解耦。当然，消息队列的适用范围不仅仅局限于这些场景，还有包括：</p>
<ul>
<li>作为发布/订阅系统实现一个微服务级系统间的观察者模式；</li>
<li>连接流计算任务和数据；</li>
<li>用于将消息广播给大量接收者。</li>
</ul>
<p>同时我们也要认识到，消息队列也有它自身的一些问题和局限性，包括：</p>
<ul>
<li>引入消息队列带来的延迟问题；</li>
<li>增加了系统的复杂度；</li>
<li>可能产生数据不一致的问题。</li>
</ul>
<h4 id="该如何选择消息队列？"><a href="#该如何选择消息队列？" class="headerlink" title="该如何选择消息队列？"></a>该如何选择消息队列？</h4><p>如果说，消息队列并不是你将要构建系统的主角之一，你对消息队列功能和性能都没有很高的要求，只需要一个开箱即用易于维护的产品，我建议你使用RabbitMQ。</p>
<p>如果你的系统使用消息队列主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，那RocketMQ的低延迟和金融级的稳定性是你需要的。</p>
<p>如果你需要处理海量的消息，像收集日志、监控信息或是前端的埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品，那Kafka是最适合你的消息队列。</p>
<p><strong>第二梯队的消息队列</strong></p>
<p>先说ActiveMQ，ActiveMQ是最老牌的开源消息队列，是十年前唯一可供选择的开源消息队列，目前已进入老年期，社区不活跃。无论是功能还是性能方面，ActiveMQ都与现代的消息队列存在明显的差距，它存在的意义仅限于兼容那些还在用的爷爷辈儿的系统。</p>
<p>接下来说说ZeroMQ，严格来说ZeroMQ并不能称之为一个消息队列，而是一个基于消息队列的多线程网络库，如果你的需求是将消息队列的功能集成到你的系统进程中，可以考虑使用ZeroMQ。</p>
<p>最后说一下Pulsar，很多人可能都没听说过这个产品，Pulsar是一个新兴的开源消息队列产品，最早是由Yahoo开发，目前处于成长期，流行度和成熟度相对没有那么高。与其他消息队列最大的不同是，Pulsar采用存储和计算分离的设计，它有可能会引领未来消息队列的一个发展方向，建议你持续关注这个项目。</p>
<p><img src="/2021/05/29/消息队列小结/mq1.png" alt="avatar"></p>
<h4 id="引入mq会多哪些问题"><a href="#引入mq会多哪些问题" class="headerlink" title="引入mq会多哪些问题"></a>引入mq会多哪些问题</h4><p><strong>重复消息问题</strong></p>
<p>重复消费问题可以说是mq中普遍存在的问题，不管你用哪种mq都无法避免。有哪些场景会出现重复的消息呢？</p>
<ul>
<li>消息生产者产生了重复的消息</li>
<li>kafka和rocketmq的offset被回调了</li>
<li>消息消费者确认失败</li>
<li>消息消费者确认时超时了</li>
<li>业务系统主动发起重试</li>
</ul>
<p><strong>数据一致性问题</strong></p>
<p>很多时候，如果mq的消费者业务处理异常的话，就会出现数据一致性问题。比如：一个完整的业务流程是，下单成功之后，送100个积分。下单写库了，但是消息消费者在送积分的时候失败了，就会造成数据不一致的情况，即该业务流程的部分数据写库了，另外一部分没有写库。</p>
<p>如果下单和送积分在同一个事务中，要么同时成功，要么同时失败，是不会出现数据一致性问题的。</p>
<p>但由于跨系统调用，为了性能考虑，一般不会使用强一致性的方案，而改成达成最终一致性即可。</p>
<p><strong>消息丢失问题</strong></p>
<p>同样消息丢失问题，也是mq中普遍存在的问题，不管你用哪种mq都无法避免。有哪些场景会出现消息丢失问题呢？</p>
<ul>
<li>消息生产者发生消息时，由于网络原因，发生到mq失败了。</li>
<li>mq服务器持久化时，磁盘出现异常</li>
<li>kafka和rocketmq的offset被回调时，略过了很多消息。</li>
<li>消息消费者刚读取消息，已经ack确认了，但业务还没处理完，服务就被重启了。</li>
</ul>
<p>导致消息丢失问题的原因挺多的，生产者、mq服务器、消费者 都有可能产生问题，我在这里就不一一列举了。最终的结果会导致消费者无法正确的处理消息，而导致数据不一致的情况。</p>
<p><strong>消息顺序问题</strong></p>
<p>有些业务数据是有状态的，比如订单有：下单、支付、完成、退货等状态，如果订单数据作为消息体，就会涉及顺序问题了。如果消费者收到同一个订单的两条消息，第一条消息的状态是下单，第二条消息的状态是支付，这是没问题的。但如果第一条消息的状态是支付，第二条消息的状态是下单就会有问题了，没有下单就先支付了？</p>
<p>消息顺序问题是一个非常棘手的问题，比如：</p>
<ul>
<li>kafka同一个partition中能保证顺序，但是不同的partition无法保证顺序。</li>
<li>rabbitmq的同一个queue能够保证顺序，但是如果多个消费者同一个queue也会有顺序问题。</li>
</ul>
<p>如果消费者使用多线程消费消息，也无法保证顺序。</p>
<p>如果消费消息时同一个订单的多条消息中，中间的一条消息出现异常情况，顺序将会被打乱。</p>
<p>还有如果生产者发送到mq中的路由规则，跟消费者不一样，也无法保证顺序。</p>
<p><strong>消息堆积</strong></p>
<p>如果消息消费者读取消息的速度，能够跟上消息生产者的节奏，那么整套mq机制就能发挥最大作用。但是很多时候，由于某些批处理，或者其他原因，导致消息消费的速度小于生产的速度。这样会直接导致消息堆积问题，从而影响业务功能。</p>
<h4 id="解决问题方案"><a href="#解决问题方案" class="headerlink" title="解决问题方案"></a>解决问题方案</h4><p><strong>重复消息问题</strong></p>
<p>增加一张消费消息表，来解决mq的这类问题。消费消息表中，使用messageId做唯一索引，在处理业务逻辑之前，先根据messageId查询一下该消息有没有处理过，如果已经处理过了则直接返回成功，如果没有处理过，则继续做业务处理。</p>
<p><img src="/2021/05/29/消息队列小结/mq2.png" alt="avatar"></p>
<p><strong>数据一致性问题</strong></p>
<p>数据一致性分为：强一致性、弱一致性、最终一致性</p>
<p>而mq为了性能考虑使用的是最终一致性，那么必定会出现数据不一致的问题。这类问题大概率是因为消费者读取消息后，业务逻辑处理失败导致的，这时候可以增加重试机制。</p>
<p>重试分为：同步重试 和 异步重试。</p>
<p>有些消息量比较小的业务场景，可以采用同步重试，在消费消息时如果处理失败，立刻重试3-5次，如何还是失败，则写入到记录表中。但如果消息量比较大，则不建议使用这种方式，因为如果出现网络异常，可能会导致大量的消息不断重试，影响消息读取速度，造成消息堆积。</p>
<p><img src="/2021/05/29/消息队列小结/mq3.png" alt="avatar"></p>
<p>而消息量比较大的业务场景，建议采用异步重试，在消费者处理失败之后，立刻写入重试表，有个job专门定时重试。</p>
<p>还有一种做法是，如果消费失败，自己给同一个topic发一条消息，在后面的某个时间点，自己又会消费到那条消息，起到了重试的效果。如果对消息顺序要求不高的场景，可以使用这种方式。</p>
<p><strong>消息丢失问题</strong></p>
<p>不管你是否承认有时候消息真的会丢，即使这种概率非常小，也会对业务有影响。生产者、mq服务器、消费者都有可能会导致消息丢失的问题。</p>
<p>为了解决这个问题，我们可以增加一张消息发送表，当生产者发完消息之后，会往该表中写入一条数据，状态status标记为待确认。如果消费者读取消息之后，调用生产者的api更新该消息的status为已确认。有个job，每隔一段时间检查一次消息发送表，如果5分钟（这个时间可以根据实际情况来定）后还有状态是待确认的消息，则认为该消息已经丢失了，重新发条消息。</p>
<p><img src="/2021/05/29/消息队列小结/mq4.png" alt="avatar"></p>
<p><strong>消息顺序问题</strong></p>
<p>消息顺序问题是我们非常常见的问题，我们以kafka消费订单消息为例。订单有：下单、支付、完成、退货等状态，这些状态是有先后顺序的，如果顺序错了会导致业务异常。</p>
<p>解决这类问题之前，我们先确认一下，消费者是否真的需要知道中间状态，只知道最终状态行不行？</p>
<p>这种方式可以解决大部分的消息顺序问题。</p>
<p>但如果真的有需要保证消息顺序的需求。订单号路由到不同的partition，同一个订单号的消息，每次到发到同一个partition。</p>
<p><img src="/2021/05/29/消息队列小结/mq5.png" alt="avatar"></p>
<p><strong>消息堆积</strong></p>
<p>那么消息堆积问题该如何解决呢？</p>
<p>这个要看消息是否需要保证顺序。</p>
<p>如果不需要保证顺序，可以读取消息之后用多线程处理业务逻辑。</p>
<p><img src="/2021/05/29/消息队列小结/mq6.png" alt="avatar"></p>
<p>这样就能增加业务逻辑处理速度，解决消息堆积问题。但是线程池的核心线程数和最大线程数需要合理配置，不然可能会浪费系统资源。</p>
<p>如果需要保证顺序，可以读取消息之后，将消息按照一定的规则分发到多个队列中，然后在队列中用单线程处理</p>
<p><img src="/2021/05/29/消息队列小结/mq7.png" alt="avatar"></p>
<h4 id="半事务消息"><a href="#半事务消息" class="headerlink" title="半事务消息"></a>半事务消息</h4><p>事务消息就是MQ提供的类似XA的分布式事务能⼒，通过事务消息可以达到分布式事务的最终⼀致性。</p>
<p>半事务消息就是MQ收到了⽣产者的消息，但是没有收到⼆次确认，不能投递的消息。</p>
<p>实现原理如下：</p>
<ol>
<li>⽣产者先发送⼀条半事务消息到MQ</li>
<li>MQ收到消息后返回ack确认</li>
<li>⽣产者开始执⾏本地事务</li>
<li>如果事务执⾏成功发送commit到MQ，失败发送rollback</li>
<li>如果MQ⻓时间未收到⽣产者的⼆次确认commit或者rollback，MQ对⽣产者发起消息回查</li>
<li>⽣产者查询事务执⾏最终状态</li>
<li>根据查询事务状态再次提交⼆次确认</li>
</ol>
<p>最终，如果MQ收到⼆次确认commit，就可以把消息投递给消费者，反之如果是rollback，消息会保存下来并且在3天后被删除。</p>
<p><img src="/2021/05/29/消息队列小结/mq8.png" alt="avatar"></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://mp.weixin.qq.com/s/9tUnhdVRHHkpGpYUQdFVuQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/9tUnhdVRHHkpGpYUQdFVuQ</a></li>
</ol>
]]></content>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列小结二</title>
    <url>/2021/06/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B0%8F%E7%BB%93%E4%BA%8C/</url>
    <content><![CDATA[<h4 id="kafka目录"><a href="#kafka目录" class="headerlink" title="kafka目录"></a>kafka目录</h4><p>在kafka当中， 每一个topic会有一个单独文件夹，这个文件夹存储在 {kafka_home}/config/server.properties中指定的log.dirs路径中。</p>
<p>在topic下会为每一个分区生成一个单独的文件夹，将这二者合并命名topicName-分区号, 例如topic1-0。</p>
<p>在每一个分区下又会有多个segment,，既然已经有多个分区了, 为什么要再进行划分为多个segment？因为：</p>
<ul>
<li>如果只存一个文件中, 文件会越来越大；</li>
<li>Kafka中的数据默认存储7天、每一天都会删除7天前的数据、 如果都存在一个文件当中、会不好删。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建topic</span><br><span class="line">bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic test2</span><br><span class="line"></span><br><span class="line">生成测试数据</span><br><span class="line">bin/kafka-producer-perf-test.sh --topic test --num-records 100000 --record-size 1000  --producer-props bootstrap.servers=hadoop101:9092 --throughput 1000000000</span><br><span class="line"></span><br><span class="line">查看log文件</span><br><span class="line">bin/kafka-run-class.sh kafka.tools.DumpLogSegments --files 00000000000000000000.log --print-data-log</span><br><span class="line"></span><br><span class="line">baseOffset: 0 lastOffset: 0 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 0 CreateTime: 1622516506987 size: 84 magic: 2 compresscodec: NONE crc: 2268928679 isvalid: true</span><br><span class="line">| offset: 0 isValid: true crc: null keySize: -1 valueSize: 16 CreateTime: 1622516506987 baseOffset: 0 lastOffset: 0 baseSequence: -1 lastSequence: -1 producerEpoch: -1 partitionLeaderEpoch: 0 batchSize: 84 magic: 2 compressType: NONE position: 0 sequence: -1 headerKeys: [] payload: ajlkdsfajkldfjad</span><br><span class="line">baseOffset: 1 lastOffset: 1 count: 1 baseSequence: -1 lastSequence: -1 producerId: -1 producerEpoch: -1 partitionLeaderEpoch: 0 isTransactional: false isControl: false position: 84 CreateTime: 1622516642240 size: 71 magic: 2 compresscodec: NONE crc: 427485767 isvalid: true</span><br><span class="line">| offset: 1 isValid: true crc: null keySize: -1 valueSize: 3 CreateTime: 1622516642240 baseOffset: 1 lastOffset: 1 baseSequence: -1 lastSequence: -1 producerEpoch: -1 partitionLeaderEpoch: 0 batchSize: 71 magic: 2 compressType: NONE position: 84 sequence: -1 headerKeys: [] payload: 哲</span><br><span class="line"></span><br><span class="line">查看index文件</span><br><span class="line">bin/kafka-run-class.sh kafka.tools.DumpLogSegments --files 00000000000000000000.index --print-data-log</span><br><span class="line"></span><br><span class="line">Dumping /tmp/kafka-logs/test2-1/00000000000000000000.index</span><br><span class="line">offset: 0 position: 0</span><br></pre></td></tr></table></figure>
<h4 id="kafka架构"><a href="#kafka架构" class="headerlink" title="kafka架构"></a>kafka架构</h4><p><strong>Kafka Topic</strong></p>
<ul>
<li>Topic是已发布消息的类别名称</li>
<li>发布和订阅数据必须指定Topic</li>
<li>Topic副本数量不大于Brokers个数，即不能多于服务器的数量</li>
<li>创建的Topic存储在 {kafka_home}/config/server.properties 指定的log.dirs路径中</li>
</ul>
<p><strong>Kafka Producer</strong></p>
<p>生产者将消息写入到Broker</p>
<ul>
<li>Producer直接发送消息到Broker上的Leader Partition</li>
<li>Producer客户端自己根据分区策略（随机分配、自定义分区算法等）控制着消息被推送到哪些Partition</li>
<li>Producer 可以以同步和异步的方式发送消息</li>
</ul>
<p>Batch推送提高效率</p>
<p>Producer 负责向 Kafka 主题发布（生产）消息，一个 Topic 可以有多个 Producer实例，其相互之间没有协作关系。Producer 的 send() 方法用于发送消息，参数ProducerRecord 封装了消息的内容：Topic、Partition、key、value 等信息。如果发送成功，返回的 RecordMetadata 中记录了消息的偏移量(Offset)，如果发送失败就会重试或者抛出异常。如下图所示。<br><img src="/2021/06/01/消息队列小结二/mq1.png" alt="avatar"><br>Producer 以 Batch 的方式推送数据可以极大的提高处理效率，Kafka Producer 可以将消息在内存中累计到一定数量后作为一个 Batch 发送请求，Batch 的数量大小可以人为进行干预，通过增加 Batch 的大小，可以减少网络请求和磁盘 IO 的次数，当然具体参数设置需要在效率和时效性方面做一个权衡。</p>
<p><strong>Kafka Consumer</strong></p>
<ol>
<li>消费者通过订阅消息并消费消息</li>
</ol>
<ul>
<li>Offset的管理是基于消费组（group.id）的级别</li>
<li>每个Partition只能由同一消费组内的一个Consumer来消费</li>
<li>每个Consumer可以消费多个分区</li>
<li>消费过的数据仍会保留在Kafka中</li>
<li>消费者不能超过分区数量</li>
</ul>
<ol start="2">
<li>消费模式</li>
</ol>
<ul>
<li>队列：所有消费者在一个消费组内</li>
<li>发布/订阅：所有消费者被分配到不同的消费组</li>
</ul>
<ol start="3">
<li>提交方式</li>
</ol>
<ul>
<li>自动提交：自动提交的优点是方便，但是可能会重复处理消息。</li>
<li>手动提交：又分为同步提交commitSync和异步提交commitAsync。</li>
</ul>
<p><img src="/2021/06/01/消息队列小结二/mq2.png" alt="avatar"></p>
<p>Consumer 负责订阅（消费）主题并处理消息。Consumer 负责维护到 Broker 的 TCP 连接以便获取数据，在一个 Partition 中每一个记录的 Offset 是该记录的 唯一标识，即每一个 Offset 唯一标识当前 Partition 中的一条记录，同时 Offset 也可以标识 Consumer 在 Partition 中的位置（Position）。对 Consumer 来讲，这个 位置有两种含义：Current Offset 和 Committed Offset。</p>
<ol>
<li>Current Offset保存在 Consumer 客户端中，它表示 Consumer 希望收到的下 一条消息的序号。它仅仅在 poll()方法中使用，例如，Consumer 第一次调用 poll() 方法后收到了 20 条消息（offset:0-19），那么 Current Offset 就被设置为 20。这样 Consumer 下一次调用 poll()方法时，Kafka 就知道应该从序号为 20 的消息开始读 取。这样就能够保证每次 Consumer poll 消息时，都能够收到不重复的消息。</li>
<li>Committed Offset保存在 Broker 上，它表示 Consumer 已经确认消费过的 消息的序号。主要通过 commitSync 和 commitAsync API 来操作。 例如，如果 Committed Offset 为 0，Consumer 通过 poll()方法收到 20 条消息 后，此时 Current Offset 就是 20，经过一系列的逻辑处理后，并没有调用 consumer.commitAsync()或 consumer.commitSync()来提交 Committed Offset，那么 此时 Committed Offset 依旧是 0，下一次 Consumer 重启后调用 poll()继续从 0 开 始消费。</li>
</ol>
<p>又如，如果一个 Consumer 消费了 5 条消息（poll 并且成功 commitSync）之 后宕机了，重新启动之后它仍然能够从第 6 条消息开始消费，因为 Committed Offset 已经被 Kafka 记录为 5。</p>
<p>可以将多个 Consumer 设置为同一个 Consumer Group，组内的所有 Consumer 协调在一起来消费订阅主题的所有分区。但是每个分区只能由同一个消费组内的 一个 Consumer 来消费。很明显，Consumer Group 的作用是为了实现多个 Consumer 并行消费一个 Topic。</p>
<p><strong>Kafka Message</strong></p>
<p><img src="/2021/06/01/消息队列小结二/mq3.png" alt="avatar"></p>
<ul>
<li>header：消息头，固定长度<br>  offset：唯一确定每条消息在分区内的位置<br>  CRC32：用crc32校验消息<br>  magic：表示本次发布Kafka服务程序协议版本号<br>  attributes”：表示为独立版本、或标识压缩类型、或编码类型</li>
<li>body：消息体<br>  key：表示消息键，可选<br>  value bytes payload：表示实际消息数据</li>
</ul>
<p><strong>存储策略</strong></p>
<p>无论消息是否被消费，kafka 都会保留所有消息。有两种策略可以删除旧数据：</p>
<ol>
<li>基于时间：log.retention.hours=168</li>
<li>基于大小：log.retention.bytes=1073741824</li>
</ol>
<p>因为 Kafka 读取特定消息的时间复杂度为 O(1)，即与文件大小无关，所以这里删除过期文件与提高 Kafka 性能无关。</p>
<p><strong>ZooKeeper在Kafka中的作用</strong></p>
<ol>
<li>Broker注册并监控状态</li>
</ol>
<p>znode:/brokers/ids，保存了所有 Broker id，实现对 Broker 的动态监控。</p>
<ol start="2">
<li>Topic注册</li>
</ol>
<p>znode:/brokers/topics，保存了所有 Topic。</p>
<ol start="3">
<li>生产者负载均衡</li>
</ol>
<p>每个Broker启动时，都会完成Broker注册过程，生产者会通过该节点的变化来动态地感知到Broker服务器列表的变更</p>
<ol start="4">
<li>offset维护</li>
</ol>
<p>Kafka早期版本使用ZooKeeper为每个消费者存储offset，由于ZooKeeper写入性能较差，从0.10版本后，Kafka使用自己的内部主题维护offset</p>
<p><strong>副本同步</strong></p>
<p>Kafka 引入了 In-sync Replicas，也就是 ISR 副本集合。ISR 中的副本都是与 Leader 同步的副本，相反，不在 ISR 中的追随者副本就被认为是与 Leader 不同步的。ISR 不只是追随者副本集合，它必然包括 Leader 副本。甚至在某些情况下，ISR 只有 Leader 这一个副本。设置 ISR 主要是为了 Broker 宕掉之后，重新选举 Partition 的 Leader 时从 ISR 列表中选择，也就是说当 Leader 副本发生故障时，只有在 ISR 集合中的 Follower 副本才有资格被选举为新的Leader。</p>
<p>ISR 是 一个动态调整的集合 ， 而 非 静 态 不 变 的 。 通 过 Broker 端replica.lag.time.max.ms 参数（Follower 副本能够落后 Leader 副本的最长时间间隔，默认值 10000）值来控制哪个追随者副本与 Leader 同步。只要一个 Follower 副本落后 Leader副本的时间不连续超过10秒，那么 Kafka 就认为该 Follower 副本与 Leader 是同步的，即使此时 Follower 副本中保存的消息明显少于 Leader 副本中的消息。如下图所示。<br><img src="/2021/06/01/消息队列小结二/mq4.png" alt="avatar"></p>
<p>上图中，Follower1 与 Follower2 中的消息条数明显少于 Leader，但并不一定与Leader 不同步。Follower 副本唯一的工作就是不断地从 Leader副本拉取消息，然后写入到自己的提交日志中。如果这个同步过程的速度持续慢于 Leader副本的消息写入速度，那么在 replica.lag.time.max.ms 时间后，此 Follower 副本就会被认为是与 Leader 副本不同步的，因此不能再放入 ISR 中。此时，Kafka 会自动收缩 ISR 集合，将该副本踢出ISR。</p>
<p>值得注意的是，倘若该副本后面慢慢地追上了 Leader 的进度，那么它是能够重新被加回 ISR 的。</p>
<p><strong>高吞吐</strong></p>
<p>1.顺序读写</p>
<p>Kafka 的消息是不断追加到文件中的，这个特性使 Kafka 可以充分利用磁盘的顺序读写性能。顺序读写不需要硬盘磁头的寻道时间，只需很少的扇区旋转时间，所以速度远快于随机读写。</p>
<p>2.零拷贝</p>
<p>在 Linux kernel2.2 之后出现了一种叫做”零拷贝(zero-copy)”系统调用机制，就是跳过“用户缓冲区”的拷贝，建立一个磁盘空间和内存的直接映射，数据不再复制到“用户态缓冲区”。</p>
<p>零拷贝并不是不需要拷贝，而是减少不必要的拷贝次数。通常是说在 IO 读写过程中。“零拷贝技术”只用将磁盘文件的数据复制到页面缓存中一次，然后将数据从页面缓存直接发送到网络中。</p>
<p><img src="/2021/06/01/消息队列小结二/mq5.png" alt="avatar"></p>
<p>3.分区</p>
<p>Kafka 的队列 topic 被分为了多个区 partition，每个 partition 又分为多个段 segment，所以一个队列中的消息实际上是保存在 N 多个片段文件中通过分段的方式，每次文件操作都是对一个小文件的操作，非常轻便，同时也增加了并行处理能力。</p>
<p>4.批量发送</p>
<p>Kafka 允许进行批量发送消息，先将消息缓存在内存中，然后一次请求批量发送出去比如可以指定缓存的消息达到某个量的时候就发出去，或者缓存了固定的时间后就发送出去如 100条消息就发送，或者每 5 秒发送一次这种策略将大大减少服务端的 I/O 次数。</p>
<p>5.数据压缩</p>
<p>Kafka 还支持对消息集合进行压缩，Producer 可以通过 GZIP 或 Snappy 格式对消息集合进行压缩压缩的好处就是减少传输的数据量，减轻对网络传输的压力。</p>
<p>6.Consumer 的负载均衡</p>
<p>当一个 group 中,有 consumer 加入或者离开时,会触发 partitions 均衡.均衡的最终目的,是提升topic 的并发消费能力。</p>
]]></content>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>生成可排序（时间序列）的唯一 id</title>
    <url>/2019/03/30/%E7%94%9F%E6%88%90%E5%8F%AF%E6%8E%92%E5%BA%8F%EF%BC%88%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%EF%BC%89%E7%9A%84%E5%94%AF%E4%B8%80%20id/</url>
    <content><![CDATA[<p>参考文章:<a href="https://www.callicoder.com/distributed-unique-id-sequence-number-generator/" target="_blank" rel="noopener">https://www.callicoder.com/distributed-unique-id-sequence-number-generator/</a></p>
<h2 id="已有解决方案"><a href="#已有解决方案" class="headerlink" title="已有解决方案"></a>已有解决方案</h2><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>UUID是全局唯一的128位十六进制数字。 两次生成相同UUID的可能性可以忽略不计。<br>UUID的问题在于它们的大小非常大并且索引不好。 当您的数据集增加时，索引大小也会增加，并且查询性能会受到影响。</p>
<h3 id="MongoDB的ObjectId"><a href="#MongoDB的ObjectId" class="headerlink" title="MongoDB的ObjectId"></a>MongoDB的ObjectId</h3><p>MongoDB的ObjectID是12字节（96位）十六进制数字，由 - 组成 -<br>一个4字节的纪元时间戳，以秒为单位，<br>一个3字节的机器标识符，<br>一个2字节的进程ID，和<br>一个3字节的计数器，以随机值开始。<br>这比早期的128位UUID小。但同样，大小比我们通常在单个MySQL自动增量字段（64位bigint值）中的长度要长。</p>
<h3 id="Database-Ticket-Servers"><a href="#Database-Ticket-Servers" class="headerlink" title="Database Ticket Servers"></a>Database Ticket Servers</h3><p>此方法使用集中式数据库服务器生成唯一的递增ID。 这就像一个集中的自动增量。 Flickr使用此方法。<br>这种方法的问题是票证服务器可能成为写入瓶颈。 此外，您还需要在基础架构中引入一个需要管理和扩展的组件。</p>
<h3 id="Twitter-Snowflake"><a href="#Twitter-Snowflake" class="headerlink" title="Twitter Snowflake"></a>Twitter Snowflake</h3><p>Twitter Snowflake是一种专用网络服务，用于大规模生成64位唯一ID。 此服务生成的ID大致可按时间排序。<br>ID由以下组件组成：<br>Epoch时间戳以毫秒为单位精度 -  41位（使用自定义纪元为69年）<br>配置的机器ID  -  10位（最多可提供1024台机器）<br>序列号 -  12位（每台机器的本地计数器，每4096重复一次）<br>为了后续扩展，他们保留了1位。 由于ID使用时间戳作为第一个组件，因此它们是可排序的。</p>
<p>Twitter Snowflake 生成的ID符合64位，并且是时间可排序的, 这就是我们想要的。但如果我们使用Twitter Snowflake，我们将再次在我们需要维护的基础架构中引入另一个组件。</p>
<h2 id="Distributed-64-bit-unique-ID-generator-inspired-by-Twitter-Snowflake"><a href="#Distributed-64-bit-unique-ID-generator-inspired-by-Twitter-Snowflake" class="headerlink" title="Distributed 64-bit unique ID generator inspired by Twitter Snowflake"></a>Distributed 64-bit unique ID generator inspired by Twitter Snowflake</h2><p>该序列生成器生成的ID由 - 组成；<br>Epoch时间戳以毫秒为单位精度 -  42位。 可以使用42位表示的最大时间戳是2^42-1，或4398046511103，其发布时间是2109年5月15日星期三7：35：11.103 AM。 可以使用139年的定制时代。<br>节点ID  -  10位。 这为我们提供了1024个节点/机器。<br>每台机器的本地计数器 -  12位。 计数器的最大值为4095。<br>您的微服务可以使用此序列生成器独立生成ID。 这是有效的，适合bigint的大小。</p>
<h3 id="java版本代码"><a href="#java版本代码" class="headerlink" title="java版本代码"></a>java版本代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.net.NetworkInterface;</span><br><span class="line">import java.security.SecureRandom;</span><br><span class="line">import java.time.Instant;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Distributed Sequence Generator.</span><br><span class="line"> * Inspired by Twitter snowflake: https://github.com/twitter/snowflake/tree/snowflake-2010</span><br><span class="line"> *</span><br><span class="line"> * This class should be used as a Singleton.</span><br><span class="line"> * Make sure that you create and reuse a Single instance of SequenceGenerator per node in your distributed system cluster.</span><br><span class="line"> */</span><br><span class="line">public class SequenceGenerator &#123;</span><br><span class="line"></span><br><span class="line">    private static final int TOTAL_BITS = 64;</span><br><span class="line">    private static final int EPOCH_BITS = 42;</span><br><span class="line">    private static final int NODE_ID_BITS = 10;</span><br><span class="line">    private static final int SEQUENCE_BITS = 12;</span><br><span class="line"></span><br><span class="line">    private static final int maxNodeId = (int)(Math.pow(2,NODE_ID_BITS)-1);</span><br><span class="line">    private static final int maxSequence = (int)(Math.pow(2,SEQUENCE_BITS)-1);</span><br><span class="line">    //2019-03-30 22:59:53</span><br><span class="line">    private static final long CUSTOM_EPOCH =1553957993000L;</span><br><span class="line"></span><br><span class="line">    private  int nodeId;</span><br><span class="line"></span><br><span class="line">    private volatile long lastTimestamp = -1L;</span><br><span class="line">    private volatile long sequence = 0L;</span><br><span class="line"></span><br><span class="line">    public SequenceGenerator(int nodeId)&#123;</span><br><span class="line">        if(nodeId &lt;0 || nodeId &gt; maxSequence)&#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;NodeId must be between %d and %d&quot;,0,maxNodeId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SequenceGenerator()&#123;</span><br><span class="line">        this.nodeId = createNodeId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized long nextId()&#123;</span><br><span class="line">        long currentTimestamp = timestamp();</span><br><span class="line">        if(currentTimestamp &lt; lastTimestamp)&#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Invalid System Clock!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(currentTimestamp == lastTimestamp)&#123;</span><br><span class="line">            sequence = (sequence+1)&amp;maxSequence;</span><br><span class="line">            if(sequence == 0)&#123;</span><br><span class="line">                // Sequence Exhausted, wait till next millisecond.</span><br><span class="line">                currentTimestamp = waitNextMillis(currentTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // reset sequence to start with zero for the next millisecond</span><br><span class="line">            sequence = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTimestamp = currentTimestamp;</span><br><span class="line">        long id = currentTimestamp &lt;&lt;(TOTAL_BITS-EPOCH_BITS);</span><br><span class="line">        id |= (nodeId &lt;&lt;(TOTAL_BITS-EPOCH_BITS-NODE_ID_BITS));</span><br><span class="line">        id |= sequence;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static long timestamp()&#123;</span><br><span class="line">        return Instant.now().toEpochMilli() - CUSTOM_EPOCH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long waitNextMillis(long currentTimestamp)&#123;</span><br><span class="line">        while ( currentTimestamp == lastTimestamp)&#123;</span><br><span class="line">            currentTimestamp = timestamp();</span><br><span class="line">        &#125;</span><br><span class="line">        return currentTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int createNodeId()&#123;</span><br><span class="line">        int nodeId;</span><br><span class="line">        try &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            Enumeration&lt;NetworkInterface&gt; networkInterfaceEnumeration = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">            while(networkInterfaceEnumeration.hasMoreElements())&#123;</span><br><span class="line">                NetworkInterface networkInterface = networkInterfaceEnumeration.nextElement();</span><br><span class="line">                byte[] mac = networkInterface.getHardwareAddress();</span><br><span class="line">                if(mac != null)&#123;</span><br><span class="line">                    for(int i=0;i&lt;mac.length;i++) &#123;</span><br><span class="line">                        sb.append(String.format(&quot;%02X&quot;, mac[i]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeId = sb.toString().hashCode();</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">           nodeId = (new SecureRandom().nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        nodeId = nodeId &amp; maxNodeId;</span><br><span class="line">        return nodeId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="go版本代码"><a href="#go版本代码" class="headerlink" title="go版本代码"></a>go版本代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;net&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	TotalBits    = 64 // 总位数</span><br><span class="line">	EpochBits    = 42 // 起始时间位数</span><br><span class="line">	NodeIdBits   = 10 // 节点位数，最大支持 1024 个节点</span><br><span class="line">	SequenceBits = 12 // 序列位数，最大支持 4096 个序列</span><br><span class="line"></span><br><span class="line">	MaxNodeId   = 1&lt;&lt;NodeIdBits - 1   // 最大节点数</span><br><span class="line">	MaxSequence = 1&lt;&lt;SequenceBits - 1 // 最大序列数</span><br><span class="line"></span><br><span class="line">	CustomEpoch = 1553957993000 // 起始时间</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	mac       uint64</span><br><span class="line">	seq       uint64</span><br><span class="line">	timestamp uint64</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init()&#123;</span><br><span class="line">	mac = getMac()</span><br><span class="line">	seq = getSeq()</span><br><span class="line">	timestamp = getTimestamp()</span><br><span class="line">&#125;</span><br><span class="line">//加锁引用</span><br><span class="line">func generateUniqueId() uint64&#123;</span><br><span class="line">	ct := getTimestamp()</span><br><span class="line">	if ct == timestamp&#123;</span><br><span class="line">		seq = (seq+1)%MaxSequence</span><br><span class="line">		if seq == 0&#123;</span><br><span class="line">			ct = getNextTimestamp()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		seq=0</span><br><span class="line">	&#125;</span><br><span class="line">	timestamp=ct</span><br><span class="line">	nodeId := getNodeId()</span><br><span class="line">	</span><br><span class="line">	id := ct&lt;&lt;(TotalBits-EpochBits)</span><br><span class="line">	id |= nodeId &lt;&lt;(TotalBits-EpochBits-NodeIdBits)</span><br><span class="line">	id |= seq</span><br><span class="line">	return id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取节点 Id</span><br><span class="line">// 根据 Mac 地址取模，0 ～ 1023</span><br><span class="line">func getNodeId() uint64 &#123;</span><br><span class="line">	return mac % MaxNodeId</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取毫秒时间戳</span><br><span class="line">func getTimestamp() uint64 &#123;</span><br><span class="line">	ns := time.Now().UnixNano()</span><br><span class="line">	ms := uint64(ns / 1000 / 1000)</span><br><span class="line">	shift := ms - CustomEpoch</span><br><span class="line"></span><br><span class="line">	return shift</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取下一个毫秒时间戳</span><br><span class="line">func getNextTimestamp() uint64 &#123;</span><br><span class="line">	t := getTimestamp()</span><br><span class="line">	for t != timestamp &#123;</span><br><span class="line">		t = getTimestamp()</span><br><span class="line">	&#125;</span><br><span class="line">	return t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getMac() uint64&#123;</span><br><span class="line">	var mac uint64</span><br><span class="line">	macAddress :=&quot;&quot;</span><br><span class="line"></span><br><span class="line">	netInterfaces, err := net.Interfaces()</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		fmt.Println(&quot;err&quot;,err)</span><br><span class="line">		return mac</span><br><span class="line">	&#125;</span><br><span class="line">	for _,netInterface := range netInterfaces &#123;</span><br><span class="line">		macAddress = netInterface.HardwareAddr.String()</span><br><span class="line">		if len(macAddress) != 0 &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	macAddress = strings.Replace(macAddress,&quot;:&quot;,&quot;&quot;,-1)</span><br><span class="line">	mac,err = strconv.ParseUint(macAddress,16,64)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;convert err&quot;, err)</span><br><span class="line">		return mac</span><br><span class="line">	&#125;</span><br><span class="line">	return mac</span><br><span class="line">&#125;</span><br><span class="line">// 获取序列号</span><br><span class="line">func getSeq() uint64&#123;</span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/twitter-archive/snowflake/tree/snowflake-2010" target="_blank" rel="noopener">https://github.com/twitter-archive/snowflake/tree/snowflake-2010</a><br><a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Universally_unique_identifier</a><br><a href="https://docs.mongodb.com/manual/reference/method/ObjectId/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/method/ObjectId/</a><br><a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/</a><br><a href="https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c" target="_blank" rel="noopener">https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c</a><br><a href="https://stackoverflow.com/questions/2671858/distributed-sequence-number-generation/5685869" target="_blank" rel="noopener">https://stackoverflow.com/questions/2671858/distributed-sequence-number-generation/5685869</a></p>
]]></content>
  </entry>
  <entry>
    <title>Jackson使用总结</title>
    <url>/2020/05/04/Jackson%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>JSON（JavaScript Object Notation），是一种简单易读的数据交换格式。 它在全球无数项目中很受欢迎并且实现，对于那些不喜欢XML的人来说，JSON是一个非常好的替代解决方案。</p>
<p>处理JSON的java工具很多，我们关注比较流行的Jackson、Google Gson和fastjson。</p>
<h3 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h3><p>Jackson是一个简单基于Java应用库，Jackson可以轻松的将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象。Jackson所依赖的jar包较少，简单易用并且性能也要相对高些，并且Jackson社区相对比较活跃，更新速度也比较快。</p>
<p>Jackson有以下特点：</p>
<ul>
<li>容易使用， jackson API提供了一个高层次外观，以简化常用的用例。</li>
<li>无需创建映射， API提供了默认的映射大部分对象序列化。</li>
<li>性能高 ，快速，低内存占用，适合大型对象图表或系统。</li>
<li>干净的JSON ， jackson创建一个干净和紧凑的JSON结果，这是让人很容易阅读。</li>
<li>不依赖 ， 库不需要任何其他的库，除了JDK。</li>
<li>开源代码， jackson是开源的，可以免费使用。</li>
</ul>
<p>JSON 提供了三种不同的方法来处理</p>
<ol>
<li>JSON 流式API ， 读取并将JSON内容写入作为离散事件。 JsonParser读取数据，而JsonGenerator写入数据。它是三者中最有效的方法，是最低的开销和最快的读/写操作。它类似于Stax解析器XML。</li>
<li>树模型 ，准备JSON文件在内存里以树形式表示。 ObjectMapper构建JsonNode节点树。这是最灵活的方法。它类似于XML的DOM解析器。</li>
<li>数据绑定， 转换JSON并从POJO（普通Java对象）使用属性访问或使用注释。它有两个类型。</li>
</ol>
<ul>
<li>简单的数据绑定 ，转换JSON和Java Maps, Lists, Strings, Numbers, Booleans 和null 对象。</li>
<li>全部数据绑定 ， 转换为JSON从任何JAVA类型。</li>
</ul>
<ol start="4">
<li>ObjectMapper读/写JSON两种类型的数据绑定。数据绑定是最方便的方式是类似XML的JAXB解析器。</li>
</ol>
<p><strong>jackson包介绍</strong></p>
<ul>
<li><p>jackson-core，核心包，提供基于”流模式”解析的相关 API，它包括 JsonPaser 和 JsonGenerator。 Jackson 内部实现正是通过高性能的流模式 API 的 JsonGenerator 和 JsonParser 来生成和解析 json。</p>
</li>
<li><p>jackson-annotations，注解包，提供标准注解功能；</p>
</li>
<li><p>jackson-databind ，数据绑定包， 提供基于”对象绑定” 解析的相关 API （ ObjectMapper ） 和”树模型” 解析的相关 API （JsonNode）；基于”对象绑定” 解析的 API 和”树模型”解析的 API 依赖基于”流模式”解析的 API。</p>
</li>
</ul>
<h3 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h3><p>Gson（又称Google Gson）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。</p>
<p>Gson的应用主要为toJson与fromJson两个转换函数，而在使用这种对象转换之前需先创建好对象的类别以及其成员才能成功的将JSON字符串成功转换成相对应的对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  private age = 5;</span><br><span class="line">  private String username = &quot;paopaozhu&quot;;</span><br><span class="line">  User()&#123;</span><br><span class="line">  &#125;     // default constructor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>序列化JAVA对象成JSON字符串<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user = new User();</span><br><span class="line">Gson gson = new Gson();</span><br><span class="line">String json = gson.toJson(user);</span><br></pre></td></tr></table></figure></p>
<p>反序列化JSON字符串成对应的JAVA对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user= gson.fromJson(json,User.class);</span><br></pre></td></tr></table></figure></p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>使用Jackson将java对象和json对象相互转换非常简单。</p>
<p><strong>关键技术 1 引用依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>jackson-databind 依赖 jackson-core 和 jackson-annotations，当添加 jackson-databind 之后， jackson-core 和 jackson-annotations 也随之添加到 Java 项目工程中。在添加相关依赖包之后，就可以使用 Jackson。</p>
<p><strong>关键技术 2 使用 ObjectMapper 对象的方法写成String、写成文件</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String writeValueAsString(Object value) 写String</span><br><span class="line"></span><br><span class="line">void writeValue(File resultFile, Object value) 写文件</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wukong.learn.jackson;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonFormat;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * POJO类，用于序列化和反序列化</span><br><span class="line"> *</span><br><span class="line"> * @author paopaozhu</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    @JsonFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private Date birthday;</span><br><span class="line"></span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getEmail() &#123;</span><br><span class="line">        return email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmail(String email) &#123;</span><br><span class="line">        this.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;, birthday=&quot; + birthday + &quot;, email=&quot; + email + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@JsonFormat 此注解用于属性上，作用是把Date类型直接转化为想要的格式，如@JsonFormat(pattern = “yyyy-MM-dd HH-mm-ss”)。</p>
<p>@JsonIgnore 此注解用于属性上，作用是进行JSON操作时忽略该属性。不会输出被注释的字段和值。</p>
<p>@JsonProperty 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把Nickname属性序列化为name，@JsonProperty(“name”)。</p>
<p><strong>Java对象转换成json对象</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wukong.learn.jackson;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.text.ParseException;</span><br><span class="line"></span><br><span class="line">public class ToJson &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setName(&quot;paopaozhu&quot;);</span><br><span class="line">        user.setEmail(&quot;admin@lpaopaozhu.com&quot;);</span><br><span class="line">        user.setAge(4);</span><br><span class="line">        SimpleDateFormat dateformat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            user.setBirthday(dateformat.parse(&quot;2020-05-02&quot;));</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            String json = mapper.writeValueAsString(user);</span><br><span class="line">            System.out.printf(&quot;json=&quot;+json);</span><br><span class="line">            //mapper.writeValue(new File(&quot;/Users/zyy/Downloads/user.json&quot;),user);</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">json=&#123;&quot;name&quot;:&quot;paopaozhu&quot;,&quot;age&quot;:4,&quot;birthday&quot;:&quot;2020年05月01日&quot;,&quot;email&quot;:&quot;admin@lpaopaozhu.com&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>将json对象转换成java对象</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wukong.learn.jackson;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.core.JsonParseException;</span><br><span class="line">import com.fasterxml.jackson.databind.JsonMappingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FromJson &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String json = &quot;&#123;\&quot;name\&quot;:\&quot;paopaozhu\&quot;,\&quot;age\&quot;:4,\&quot;birthday\&quot;:\&quot;2020-05-02 00:00:00\&quot;,&quot; +</span><br><span class="line">                &quot;\&quot;email\&quot;:\&quot;admin@lpaopaozhu.com\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        User user = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            user = mapper.readValue(json, User.class);</span><br><span class="line">        &#125; catch (JsonParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (JsonMappingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="List-Java对象互转"><a href="#List-Java对象互转" class="headerlink" title="List/Java对象互转"></a>List/Java对象互转</h3><p>前端发给后台的数据是一个数组对象，数组里的元素也是对象。</p>
<p>它是下面格式的数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;id&quot;:1,&quot;checked&quot;:true&#125;,&#123;&quot;id&quot;:3,&quot;checked&quot;:true&#125;,&#123;&quot;id&quot;:4,&quot;checked&quot;:true&#125;,&#123;&quot;id&quot;:2,&quot;checked&quot;:false&#125;]</span><br></pre></td></tr></table></figure></p>
<p>在Jackson的基础上， 我们需要一个DTO对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wukong.learn.jackson;</span><br><span class="line"></span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class PermissionChecker &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private boolean checked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个DTO对象有id和checked两个属性，用于对应json中的id和checked。</p>
<p>接下来就使用Jackson 工具将接收到的json转换成<code>List&lt;PermissionChecker &gt;</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wukong.learn.jackson;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.databind.JavaType;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class ListToJson &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String jsonstr=&quot;[&#123;\&quot;id\&quot;:1,\&quot;checked\&quot;:true&#125;,&#123;\&quot;id\&quot;:3,\&quot;checked\&quot;:true&#125;,&quot; +</span><br><span class="line">                &quot;&#123;\&quot;id\&quot;:4,\&quot;checked\&quot;:true&#125;,&#123;\&quot;id\&quot;:2,\&quot;checked\&quot;:false&#125;]&quot;;</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        JavaType jt = mapper.getTypeFactory().constructParametricType(ArrayList.class, PermissionChecker.class);</span><br><span class="line">        List&lt;PermissionChecker&gt; list= new ArrayList&lt;PermissionChecker&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            list = mapper.readValue(jsonstr, jt);</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        for(PermissionChecker pc:list) &#123;</span><br><span class="line">            System.out.println(pc.getId()+&quot; is &quot;+pc.isChecked());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Map-Json对象互转"><a href="#Map-Json对象互转" class="headerlink" title="Map/Json对象互转"></a>Map/Json对象互转</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wukong.learn.jackson;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.core.JsonParseException;</span><br><span class="line">import com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line">import com.fasterxml.jackson.core.type.TypeReference;</span><br><span class="line">import com.fasterxml.jackson.databind.JsonMappingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class MapToJson &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //toJson();</span><br><span class="line">        toMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void toJson() &#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();</span><br><span class="line">        map.put(&quot;site&quot;, &quot;昨非&quot;);</span><br><span class="line">        map.put(&quot;URL&quot;, &quot;https://alfredliukai.github.io&quot;);</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        String json;</span><br><span class="line">        try&#123;</span><br><span class="line">            json = mapper.writeValueAsString(map);</span><br><span class="line">            System.out.println(json);</span><br><span class="line">        &#125;catch (JsonProcessingException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void toMap()&#123;</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">        String json = &quot;&#123;\&quot;site\&quot;:\&quot;昨非\&quot;,\&quot;URL\&quot;:\&quot;https://alfredliukai.github.io\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">           map= mapper.readValue(json, new TypeReference&lt;Map&lt;String,Object&gt;&gt;() &#123;&#125;);</span><br><span class="line">        &#125;catch (JsonParseException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;catch (JsonMappingException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        for (Map.Entry&lt;String,Object&gt; entry : map.entrySet())&#123;</span><br><span class="line">            System.out.println(entry.getKey() + &quot; : &quot; + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tree-Model"><a href="#Tree-Model" class="headerlink" title="Tree Model"></a>Tree Model</h3><p>树形结构的数据在工作中出现的频率非常高。</p>
<p>如一个叫张大大的同学，他的信息用json表示如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;   : 1,</span><br><span class="line">  &quot;name&quot; : &#123;</span><br><span class="line">    &quot;first&quot; : &quot;zhang&quot;,</span><br><span class="line">    &quot;last&quot; : &quot;dada&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;contact&quot; : [</span><br><span class="line">    &#123; &quot;type&quot; : &quot;QQ&quot;, &quot;ref&quot; : &quot;88888888&quot;&#125;,</span><br><span class="line">    &#123; &quot;type&quot; : &quot;phone&quot;, &quot;ref&quot; : &quot;18822222222&quot;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样数据具有树形的特点，处理方式有些繁琐。</p>
<p><strong>处理单条记录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wukong.learn.jackson;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line">import com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class TreeModel &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String content = &quot;&#123;\n&quot; +</span><br><span class="line">                &quot;  \&quot;id\&quot;   : 1,\n&quot; +</span><br><span class="line">                &quot;  \&quot;name\&quot; : &#123;\n&quot; +</span><br><span class="line">                &quot;    \&quot;first\&quot; : \&quot;zhang\&quot;,\n&quot; +</span><br><span class="line">                &quot;    \&quot;last\&quot; : \&quot;dada\&quot;\n&quot; +</span><br><span class="line">                &quot;  &#125;,\n&quot; +</span><br><span class="line">                &quot;  \&quot;contact\&quot; : [\n&quot; +</span><br><span class="line">                &quot;    &#123; \&quot;type\&quot; : \&quot;QQ\&quot;, \&quot;ref\&quot; : \&quot;88888888\&quot;&#125;,\n&quot; +</span><br><span class="line">                &quot;    &#123; \&quot;type\&quot; : \&quot;phone\&quot;, \&quot;ref\&quot; : \&quot;18822222222\&quot;&#125;\n&quot; +</span><br><span class="line">                &quot;  ]\n&quot; +</span><br><span class="line">                &quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">        long id;</span><br><span class="line">        String firstName = &quot;&quot;;</span><br><span class="line">        String lastName = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        JsonNode root;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            root = mapper.readTree(content);</span><br><span class="line"></span><br><span class="line">            id = root.path(&quot;id&quot;).asLong();</span><br><span class="line">            System.out.println(&quot;id: &quot;+id);</span><br><span class="line"></span><br><span class="line">            JsonNode nameNode = root.path(&quot;name&quot;);</span><br><span class="line">            if (nameNode.isMissingNode()) &#123;</span><br><span class="line">                // 处理缺失的节点</span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                firstName = nameNode.path(&quot;first&quot;).asText();</span><br><span class="line">                lastName = nameNode.path(&quot;last&quot;).asText();</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;姓： &quot; + firstName);</span><br><span class="line">                System.out.println(&quot;名： &quot; + lastName);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            JsonNode contactNode = root.path(&quot;contact&quot;);</span><br><span class="line">            if (contactNode.isArray()) &#123;</span><br><span class="line">                // 处理数组</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (JsonNode node : contactNode) &#123;</span><br><span class="line">                String type = node.path(&quot;type&quot;).asText();</span><br><span class="line">                String ref = node.path(&quot;ref&quot;).asText();</span><br><span class="line">                System.out.println(&quot;type : &quot; + type);</span><br><span class="line">                System.out.println(&quot;ref : &quot; + ref);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;---------------------- 我是分割线 ------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键技术：</p>
<p>使用 readTree(File file) 方法从磁盘读取json文件<br>使用 JsonNode 对象的 path(String fieldName); 方法返回一个JsonNode<br>再对JsonNode 对象进行类型转换，转换成基本的数据类型或包装器类型</p>
<p>计算结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id: 1</span><br><span class="line">姓： zhang</span><br><span class="line">名： dada</span><br><span class="line">type : QQ</span><br><span class="line">ref : 88888888</span><br><span class="line">type : phone</span><br><span class="line">ref : 18822222222</span><br><span class="line">---------------------- 我是分割线 ------------------------</span><br></pre></td></tr></table></figure></p>
<h3 id="流式API"><a href="#流式API" class="headerlink" title="流式API"></a>流式API</h3><p>使用Jackson流式API可以读写json</p>
<p>用到的关键技术：</p>
<ul>
<li>com.fasterxml.jackson.core.JsonGenerator 写入json文件</li>
<li>com.fasterxml.jackson.core.JsonParser 解析文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wukong.learn.jackson;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.core.JsonEncoding;</span><br><span class="line">import com.fasterxml.jackson.core.JsonFactory;</span><br><span class="line">import com.fasterxml.jackson.core.JsonGenerator;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class APIReadAndWrite &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JsonFactory factory = new JsonFactory();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            JsonGenerator generator = factory.createGenerator(new File(&quot;/Users/zyy/Downloads/user.json&quot;),</span><br><span class="line">                    JsonEncoding.UTF8);</span><br><span class="line"></span><br><span class="line">            generator.writeStartObject();</span><br><span class="line"></span><br><span class="line">            generator.writeStringField(&quot;site&quot;, &quot;alfred.github.io&quot;);</span><br><span class="line">            generator.writeStringField(&quot;URL&quot;, &quot;http://alfred.github.io&quot;);</span><br><span class="line"></span><br><span class="line">            generator.writeFieldName(&quot;messages&quot;);</span><br><span class="line">            generator.writeStartArray(); // [</span><br><span class="line"></span><br><span class="line">            generator.writeString(&quot;第一条消息 为人民服务&quot;);</span><br><span class="line">            generator.writeString(&quot;第二条消息 好好学习，天天向上&quot;);</span><br><span class="line">            generator.writeString(&quot;第三条消息 快乐编程&quot;);</span><br><span class="line"></span><br><span class="line">            generator.writeEndArray(); // ]</span><br><span class="line"></span><br><span class="line">            generator.writeEndObject(); // &#125;</span><br><span class="line"></span><br><span class="line">            generator.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键方法有：</p>
<ul>
<li>JsonFactory 对象用于产生JsonGenerator 对象;</li>
<li>void writeStartObject() 方法用于写一个{</li>
<li>void writeEndObject() 方法用于写一个}</li>
<li>void writeStartArray() 方法用于写入一个[</li>
<li>void writeEndArray() 方法用于写一个]</li>
<li>void writeStringField(String fieldName, String value) 方法用于写入一个字段，包括字段名和值，字段是String类型</li>
<li>void writeNumberField(String fieldName, int value) 方法用于写入一个字段，包括字段名和值，字段是Number类型</li>
<li>void writeString(String text) 方法用于写入一个值</li>
</ul>
<p>计算结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;site&quot;:&quot;alfred.github.io&quot;,&quot;URL&quot;:&quot;http://alfred.github.io&quot;,&quot;messages&quot;:[&quot;第一条消息 为人民服务&quot;,&quot;第二条消息 好好学习，天天向上&quot;,&quot;第三条消息 快乐编程&quot;]&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>JsonParser解析文件</strong><br>使用JsonParser可以解析json文件。这种解析试建立在对json结构有清晰认识的基础上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wukong.learn.jackson;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.core.*;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class APIReadAndWrite &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //jsonGenerator();</span><br><span class="line">        jsonParser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void jsonGenerator() &#123;</span><br><span class="line">        JsonFactory factory = new JsonFactory();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            JsonGenerator generator = factory.createGenerator(new File(&quot;/Users/zyy/Downloads/user.json&quot;),</span><br><span class="line">                    JsonEncoding.UTF8);</span><br><span class="line"></span><br><span class="line">            generator.writeStartObject();</span><br><span class="line"></span><br><span class="line">            generator.writeStringField(&quot;site&quot;, &quot;alfred.github.io&quot;);</span><br><span class="line">            generator.writeStringField(&quot;URL&quot;, &quot;http://alfred.github.io&quot;);</span><br><span class="line"></span><br><span class="line">            generator.writeFieldName(&quot;messages&quot;);</span><br><span class="line">            generator.writeStartArray(); // [</span><br><span class="line"></span><br><span class="line">            generator.writeString(&quot;第一条消息 为人民服务&quot;);</span><br><span class="line">            generator.writeString(&quot;第二条消息 好好学习，天天向上&quot;);</span><br><span class="line">            generator.writeString(&quot;第三条消息 快乐编程&quot;);</span><br><span class="line"></span><br><span class="line">            generator.writeEndArray(); // ]</span><br><span class="line"></span><br><span class="line">            generator.writeEndObject(); // &#125;</span><br><span class="line"></span><br><span class="line">            generator.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void jsonParser()&#123;</span><br><span class="line">        JsonFactory factory = new JsonFactory();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            JsonParser parser = factory.createParser(new File(&quot;/Users/zyy/Downloads/user.json&quot;));</span><br><span class="line"></span><br><span class="line">            // 读取每一行，直到找到 &quot;&#125;&quot;</span><br><span class="line">            while (parser.nextToken() != JsonToken.END_OBJECT) &#123;</span><br><span class="line"></span><br><span class="line">                String fieldname = parser.getCurrentName();</span><br><span class="line">                if (&quot;site&quot;.equals(fieldname)) &#123;</span><br><span class="line">                    // 找到site后，再找下一个</span><br><span class="line">                    parser.nextToken();</span><br><span class="line">                    System.out.println(parser.getText());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (&quot;URL&quot;.equals(fieldname)) &#123;</span><br><span class="line">                    // 找到URL后，再找下一个</span><br><span class="line">                    parser.nextToken();</span><br><span class="line">                    System.out.println(parser.getText());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (&quot;messages&quot;.equals(fieldname)) &#123;</span><br><span class="line">                    parser.nextToken();</span><br><span class="line">                    // 读取每一行，直到找到 &quot;]&quot;</span><br><span class="line">                    while (parser.nextToken() != JsonToken.END_ARRAY) &#123;</span><br><span class="line">                        System.out.println(parser.getText());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            parser.close();</span><br><span class="line"></span><br><span class="line">        &#125; catch (JsonParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键方法：</p>
<p>JsonToken nextToken() 方法用于读取每一个JsonToken<br>JsonParser 对象的方法 String getCurrentName() 读取字段名<br>JsonParser 对象的方法 String getText() 读取字段值</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://www.jianshu.com/p/040e8671e560" target="_blank" rel="noopener">https://www.jianshu.com/p/040e8671e560</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/jackson-advanced-application/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/jackson-advanced-application/index.html</a></li>
<li><a href="https://www.wangshenghua.com/wiki/jackson/f5789c8c7cd39ad348e3a8ccadfa9523/" target="_blank" rel="noopener">https://www.wangshenghua.com/wiki/jackson/f5789c8c7cd39ad348e3a8ccadfa9523/</a></li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Lombok使用</title>
    <url>/2020/05/05/Lombok%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Lombok背景介绍"><a href="#Lombok背景介绍" class="headerlink" title="Lombok背景介绍"></a>Lombok背景介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Project Lombok makes java a spicier language by adding &apos;handlers&apos; that know how to build and compile simple, boilerplate-free, not-quite-java code.</span><br></pre></td></tr></table></figure>
<p>大致意思是Lombok通过增加一些“处理程序”，可以让java变得简洁、快速。</p>
<h3 id="Lombok使用方法"><a href="#Lombok使用方法" class="headerlink" title="Lombok使用方法"></a>Lombok使用方法</h3><p><strong>依赖管理</strong></p>
<p>Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法，而且需要维护，当属性多时会出现大量的getter/setter方法，这些显得很冗长也没有太多技术含量，一旦修改属性，就容易出现忘记修改对应方法的失误。</p>
<p>Lombok能通过注解的方式，在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法。出现的神奇就是在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。这样就省去了手动重建这些代码的麻烦，使代码看起来更简洁些。</p>
<p>Lombok的使用跟引用jar包一样，可以在官网（<a href="https://projectlombok.org/download）下载jar包，也可以使用maven添加依赖：" target="_blank" rel="noopener">https://projectlombok.org/download）下载jar包，也可以使用maven添加依赖：</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.10&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>Lombok的scope=provided，说明它只在编译阶段生效，不需要打入包中。事实正是如此，Lombok在编译期将带Lombok注解的Java文件正确编译为完整的Class文件。<br>接下来我们来分析Lombok中注解的具体用法。</p>
<p><strong>IDEA插件的安装</strong></p>
<ol>
<li>在IDEA插件里搜索lombok，安装，重启</li>
<li>直接官网下载插件，安装，这是链接</li>
<li>设置中启用annotation processors</li>
</ol>
<p><img src="/2020/05/05/Lombok使用/lombok.png" alt="avatar"></p>
<h3 id="Lombok实现原理"><a href="#Lombok实现原理" class="headerlink" title="Lombok实现原理"></a>Lombok实现原理</h3><p>自从Java 6起，javac就支持“JSR 269 Pluggable Annotation Processing API”规范，只要程序实现了该API，就能在javac运行的时候得到调用。</p>
<p>Lombok就是一个实现了”JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下：</p>
<ol>
<li>javac对源代码进行分析，生成一棵抽象语法树(AST)</li>
<li>javac编译过程中调用实现了JSR 269的Lombok程序</li>
<li>此时Lombok就对第一步骤得到的AST进行处理，找到Lombok注解所在类对应的语法树(AST)，然后修改该语法树(AST)，增加Lombok注解定义的相应树节点</li>
<li>javac使用修改后的抽象语法树(AST)生成字节码文件</li>
</ol>
<h3 id="Lombok注解的使用"><a href="#Lombok注解的使用" class="headerlink" title="Lombok注解的使用"></a>Lombok注解的使用</h3><ol>
<li>@Setter 注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。</li>
<li>@Getter 使用方法同上，区别在于生成的是getter方法。</li>
<li>@ToString 注解在类，添加toString方法。</li>
<li>@EqualsAndHashCode 注解在类，生成hashCode和equals方法。</li>
<li>@NoArgsConstructor 注解在类，生成无参的构造方法。</li>
<li>@RequiredArgsConstructor 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。</li>
<li>@AllArgsConstructor 注解在类，生成包含类中所有字段的构造方法。</li>
<li>@Data 注解在类，为类的所有字段注解@ToString、@EqualsAndHashCode、@Getter的便捷方法，同时为所有非final字段注解@Setter。</li>
</ol>
<p><strong>@Data注解</strong></p>
<p>@Data注解在类上，会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。<br>@Data可以很好地处理字段的泛型参数。 为了在为具有泛型的类构造对象时减少样板，可以使用staticConstructor参数来生成私有构造函数，以及返回新实例的静态方法。 这样，javac将推断变量名称。 因此，通过这样声明：@Data（staticConstructor =“of”）类Foo {private T x;}可以通过写入来创建Foo的新实例：Foo.of（5）; 而不必写：new Foo （5）;</p>
<p>如果使用了@Data注解<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data public class DataExample &#123;</span><br><span class="line">  private final String name;</span><br><span class="line">  </span><br><span class="line">  @Setter(AccessLevel.PACKAGE) </span><br><span class="line">  private int age;</span><br><span class="line">  </span><br><span class="line">  private double score;</span><br><span class="line">  private String[] tags;</span><br><span class="line">  </span><br><span class="line">  @ToString(includeFieldNames=true)</span><br><span class="line">  @Data(staticConstructor=&quot;of&quot;)</span><br><span class="line">  public static class Exercise&lt;T&gt; &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final T value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>不加lombok注解的Pojo的写法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DataExample &#123;</span><br><span class="line">  private final String name;</span><br><span class="line">  private int age;</span><br><span class="line">  private double score;</span><br><span class="line">  private String[] tags;</span><br><span class="line">  </span><br><span class="line">  public DataExample(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void setAge(int age) &#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int getAge() &#123;</span><br><span class="line">    return this.age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void setScore(double score) &#123;</span><br><span class="line">    this.score = score;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public double getScore() &#123;</span><br><span class="line">    return this.score;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public String[] getTags() &#123;</span><br><span class="line">    return this.tags;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void setTags(String[] tags) &#123;</span><br><span class="line">    this.tags = tags;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override public String toString() &#123;</span><br><span class="line">    return &quot;DataExample(&quot; + this.getName() + &quot;, &quot; + this.getAge() + &quot;, &quot; + this.getScore() + &quot;, &quot; + Arrays.deepToString(this.getTags()) + &quot;)&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected boolean canEqual(Object other) &#123;</span><br><span class="line">    return other instanceof DataExample;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override public boolean equals(Object o) &#123;</span><br><span class="line">    if (o == this) return true;</span><br><span class="line">    if (!(o instanceof DataExample)) return false;</span><br><span class="line">    DataExample other = (DataExample) o;</span><br><span class="line">    if (!other.canEqual((Object)this)) return false;</span><br><span class="line">    if (this.getName() == null ? other.getName() != null : !this.getName().equals(other.getName())) return false;</span><br><span class="line">    if (this.getAge() != other.getAge()) return false;</span><br><span class="line">    if (Double.compare(this.getScore(), other.getScore()) != 0) return false;</span><br><span class="line">    if (!Arrays.deepEquals(this.getTags(), other.getTags())) return false;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override public int hashCode() &#123;</span><br><span class="line">    final int PRIME = 59;</span><br><span class="line">    int result = 1;</span><br><span class="line">    final long temp1 = Double.doubleToLongBits(this.getScore());</span><br><span class="line">    result = (result*PRIME) + (this.getName() == null ? 43 : this.getName().hashCode());</span><br><span class="line">    result = (result*PRIME) + this.getAge();</span><br><span class="line">    result = (result*PRIME) + (int)(temp1 ^ (temp1 &gt;&gt;&gt; 32));</span><br><span class="line">    result = (result*PRIME) + Arrays.deepHashCode(this.getTags());</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static class Exercise&lt;T&gt; &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final T value;</span><br><span class="line">    </span><br><span class="line">    private Exercise(String name, T value) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //可以看到这里自动生成了of方法</span><br><span class="line">    public static &lt;T&gt; Exercise&lt;T&gt; of(String name, T value) &#123;</span><br><span class="line">      return new Exercise&lt;T&gt;(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public T getValue() &#123;</span><br><span class="line">      return this.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">      return &quot;Exercise(name=&quot; + this.getName() + &quot;, value=&quot; + this.getValue() + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected boolean canEqual(Object other) &#123;</span><br><span class="line">      return other instanceof Exercise;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override public boolean equals(Object o) &#123;</span><br><span class="line">      if (o == this) return true;</span><br><span class="line">      if (!(o instanceof Exercise)) return false;</span><br><span class="line">      Exercise&lt;?&gt; other = (Exercise&lt;?&gt;) o;</span><br><span class="line">      if (!other.canEqual((Object)this)) return false;</span><br><span class="line">      if (this.getName() == null ? other.getValue() != null : !this.getName().equals(other.getName())) return false;</span><br><span class="line">      if (this.getValue() == null ? other.getValue() != null : !this.getValue().equals(other.getValue())) return false;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override public int hashCode() &#123;</span><br><span class="line">      final int PRIME = 59;</span><br><span class="line">      int result = 1;</span><br><span class="line">      result = (result*PRIME) + (this.getName() == null ? 43 : this.getName().hashCode());</span><br><span class="line">      result = (result*PRIME) + (this.getValue() == null ? 43 : this.getValue().hashCode());</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@Getter/@Setter</strong></p>
<p>如果觉得@Data太过残暴（因为@Data集合了@ToString、@EqualsAndHashCode、@Getter/@Setter、@RequiredArgsConstructor的所有特性）不够精细，可以使用@Getter/@Setter注解，此注解在属性上，可以为相应的属性自动生成Getter/Setter方法.<br>@Getter/@Setter: 作用类上，生成所有成员变量的getter/setter方法；作用于成员变量上，生成该成员变量的getter/setter方法。可以设定访问权限及是否懒加载等。示例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import lombok.AccessLevel;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line"></span><br><span class="line">public class GetterSetterExample &#123;</span><br><span class="line"></span><br><span class="line">  @Getter </span><br><span class="line">  @Setter </span><br><span class="line">  private int age = 10;</span><br><span class="line">  </span><br><span class="line">  @Setter(AccessLevel.PROTECTED) </span><br><span class="line">  private String name;</span><br><span class="line">  </span><br><span class="line">  @Override public String toString() &#123;</span><br><span class="line">    return String.format(&quot;%s (age: %d)&quot;, name, age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不使用Lombok：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GetterSetterExample &#123;</span><br><span class="line"></span><br><span class="line">  private int age = 10;</span><br><span class="line"></span><br><span class="line">  private String name;</span><br><span class="line">  </span><br><span class="line">  @Override </span><br><span class="line">  public String toString() &#123;</span><br><span class="line">    return String.format(&quot;%s (age: %d)&quot;, name, age);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int getAge() &#123;</span><br><span class="line">    return age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void setAge(int age) &#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected void setName(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@NonNull</strong><br>该注解用在属性或构造器上，Lombok会生成一个非空的声明，可用于校验参数，能帮助避免空指针。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import lombok.NonNull;</span><br><span class="line"></span><br><span class="line">public class NonNullExample extends Something &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  </span><br><span class="line">  public NonNullExample(@NonNull Person person) &#123;</span><br><span class="line">    super(&quot;Hello&quot;);</span><br><span class="line">    this.name = person.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不使用Lombok：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import lombok.NonNull;</span><br><span class="line"></span><br><span class="line">public class NonNullExample extends Something &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  </span><br><span class="line">  public NonNullExample(@NonNull Person person) &#123;</span><br><span class="line">    super(&quot;Hello&quot;);</span><br><span class="line">    if (person == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;person&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.name = person.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@EqualsAndHashCode</strong></p>
<p>默认情况下，会使用所有非静态（non-static）和非瞬态（non-transient）属性来生成equals和hasCode，也能通过exclude注解来排除一些属性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mport lombok.EqualsAndHashCode;</span><br><span class="line"></span><br><span class="line">@EqualsAndHashCode(exclude=&#123;&quot;id&quot;, &quot;shape&quot;&#125;)</span><br><span class="line">public class EqualsAndHashCodeExample &#123;</span><br><span class="line">  private transient int transientVar = 10;</span><br><span class="line">  private String name;</span><br><span class="line">  private double score;</span><br><span class="line">  private Shape shape = new Square(5, 10);</span><br><span class="line">  private String[] tags;</span><br><span class="line">  private int id;</span><br><span class="line">  </span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @EqualsAndHashCode(callSuper=true)</span><br><span class="line">  public static class Square extends Shape &#123;</span><br><span class="line">    private final int width, height;</span><br><span class="line">    </span><br><span class="line">    public Square(int width, int height) &#123;</span><br><span class="line">      this.width = width;</span><br><span class="line">      this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@ToString</strong></p>
<p>类使用@ToString注解，Lombok会生成一个toString()方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割。<br>通过将includeFieldNames参数设为true，就能明确的输出toString()属性。这一点是不是有点绕口，通过代码来看会更清晰些。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import lombok.ToString;</span><br><span class="line"></span><br><span class="line">@ToString(exclude=&quot;id&quot;)</span><br><span class="line">public class ToStringExample &#123;</span><br><span class="line">  private static final int STATIC_VAR = 10;</span><br><span class="line">  private String name;</span><br><span class="line">  private Shape shape = new Square(5, 10);</span><br><span class="line">  private String[] tags;</span><br><span class="line">  private int id;</span><br><span class="line">  </span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return this.getName();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @ToString(callSuper=true, includeFieldNames=true)</span><br><span class="line">  public static class Square extends Shape &#123;</span><br><span class="line">    private final int width, height;</span><br><span class="line">    </span><br><span class="line">    public Square(int width, int height) &#123;</span><br><span class="line">      this.width = width;</span><br><span class="line">      this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不使用Lombok的示例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class ToStringExample &#123;</span><br><span class="line">  private static final int STATIC_VAR = 10;</span><br><span class="line">  private String name;</span><br><span class="line">  private Shape shape = new Square(5, 10);</span><br><span class="line">  private String[] tags;</span><br><span class="line">  private int id;</span><br><span class="line">  </span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return this.getName();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static class Square extends Shape &#123;</span><br><span class="line">    private final int width, height;</span><br><span class="line">    </span><br><span class="line">    public Square(int width, int height) &#123;</span><br><span class="line">      this.width = width;</span><br><span class="line">      this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override </span><br><span class="line">    public String toString() &#123;</span><br><span class="line">      return &quot;Square(super=&quot; + super.toString() + &quot;, width=&quot; + this.width + &quot;, height=&quot; + this.height + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override </span><br><span class="line">  public String toString() &#123;</span><br><span class="line">    return &quot;ToStringExample(&quot; + this.getName() + &quot;, &quot; + this.shape + &quot;, &quot; + Arrays.deepToString(this.tags) + &quot;)&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</strong></p>
<p>无参构造器、部分参数构造器、全参构造器。Lombok没法实现多种参数构造器的重载。</p>
<p>@NoArgsConstructor将生成一个没有参数的构造函数。如果这是不可能的（因为最终字段），将导致编译器错误，除非使用@NoArgsConstructor（force = true），然后使用0 / false / null初始化所有final字段。对于具有约束的字段，例如@NonNull字段，不会生成任何检查，因此请注意，在稍后正确初始化这些字段之前，通常不会满足这些约束。某些java构造（例如hibernate和Service Provider Interface）需要no-args构造函数。</p>
<p>@RequiredArgsConstructor为每个需要特殊处理的字段生成一个带有1个参数的构造函数。所有未初始化的final字段都会获得一个参数，以及标记为@NonNull的任何字段，这些字段在声明它们时未初始化。对于标有@NonNull的字段，还会生成显式空检查。如果用于标记为@NonNull的字段的任何参数包含null，则构造函数将抛出NullPointerException。参数的顺序与字段在类中的显示顺序相匹配。</p>
<p>@AllArgsConstructor</p>
<p>@AllArgsConstructor为类中的每个字段生成一个带有1个参数的构造函数。标有@NonNull的字段会导致对这些参数进行空检查。</p>
<p>这些注释中的每一个都允许使用替代形式，其中生成的构造函数始终是私有的，并且生成包围私有构造函数的附加静态工厂方法。通过为注释提供staticName值来启用此模式，如下所示：@RequiredArgsConstructor（staticName =“of”）。与普通构造函数不同，这种静态工厂方法将推断泛型。这意味着您的API用户可以编写MapEntry.of（“foo”，5）而不是更长的新MapEntry &lt;String，Integer&gt;（“foo”，5）。</p>
<p>与大多数其他lombok注释不同，显式构造函数的存在不会阻止这些注解生成自己的构造函数。这意味着可以编写自己的专用构造函数，并让lombok生成样板文件。</p>
<p>注意：如果出现冲突（自定义的一个构造函数最终使用与lombok生成的构造函数相同），则会发生编译器错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import lombok.AccessLevel;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.NonNull;</span><br><span class="line"></span><br><span class="line">@RequiredArgsConstructor(staticName = &quot;of&quot;)</span><br><span class="line">@AllArgsConstructor(access = AccessLevel.PROTECTED)</span><br><span class="line">public class ConstructorExample&lt;T&gt; &#123;</span><br><span class="line">  private int x, y;</span><br><span class="line">  @NonNull private T description;</span><br><span class="line">  </span><br><span class="line">  @NoArgsConstructor</span><br><span class="line">  public static class NoArgsExample &#123;</span><br><span class="line">    @NonNull private String field;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不使用Lombok的示例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConstructorExample&lt;T&gt; &#123;</span><br><span class="line">  private int x, y;</span><br><span class="line">  @NonNull private T description;</span><br><span class="line">  </span><br><span class="line">  private ConstructorExample(T description) &#123;</span><br><span class="line">    if (description == null) throw new NullPointerException(&quot;description&quot;);</span><br><span class="line">    this.description = description;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static &lt;T&gt; ConstructorExample&lt;T&gt; of(T description) &#123;</span><br><span class="line">    return new ConstructorExample&lt;T&gt;(description);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @java.beans.ConstructorProperties(&#123;&quot;x&quot;, &quot;y&quot;, &quot;description&quot;&#125;)</span><br><span class="line">  protected ConstructorExample(int x, int y, T description) &#123;</span><br><span class="line">    if (description == null) throw new NullPointerException(&quot;description&quot;);</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">    this.description = description;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static class NoArgsExample &#123;</span><br><span class="line">    @NonNull private String field;</span><br><span class="line">    </span><br><span class="line">    public NoArgsExample() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@Log及其日志注解</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Log</span><br><span class="line">public class LogExample &#123;</span><br><span class="line">  </span><br><span class="line">  public static void main(String... args) &#123;</span><br><span class="line">    log.severe(&quot;Something&apos;s wrong here&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">public class LogExampleOther &#123;</span><br><span class="line">  </span><br><span class="line">  public static void main(String... args) &#123;</span><br><span class="line">    log.error(&quot;Something else is wrong here&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@CommonsLog(topic=&quot;CounterLog&quot;)</span><br><span class="line">public class LogExampleCategory &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String... args) &#123;</span><br><span class="line">    log.error(&quot;Calling the &apos;CounterLog&apos; with a message&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等效于：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());</span><br><span class="line">  </span><br><span class="line">  public static void main(String... args) &#123;</span><br><span class="line">    log.severe(&quot;Something&apos;s wrong here&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LogExampleOther &#123;</span><br><span class="line">  private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExampleOther.class);</span><br><span class="line">  </span><br><span class="line">  public static void main(String... args) &#123;</span><br><span class="line">    log.error(&quot;Something else is wrong here&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LogExampleCategory &#123;</span><br><span class="line">  private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(&quot;CounterLog&quot;);</span><br><span class="line"></span><br><span class="line">  public static void main(String... args) &#123;</span><br><span class="line">    log.error(&quot;Calling the &apos;CounterLog&apos; with a message&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>bean中的链式风格</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Accessors(chain = true)</span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setId(1L).setAge(2).setName(&quot;Zhangsan&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>静态构造方法</strong><br>构造参数为空的最佳实践<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Accessors(chain = true)</span><br><span class="line">@Data</span><br><span class="line">@RequiredArgsConstructor(staticName = &quot;of&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void testConstructor() &#123;</span><br><span class="line">    User user = User.of().setId(1L).setAge(2).setName(&quot;Zhangsan&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造参数为name的最佳实践<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Accessors(chain = true)</span><br><span class="line">@Data</span><br><span class="line">@RequiredArgsConstructor(staticName = &quot;of&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    @NonNull</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testConstructorOfName() &#123;</span><br><span class="line">    User user = User.of(&quot;Zhangsan&quot;).setId(1L).setAge(2);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Builder模式</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Builder</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testBuilder() &#123;</span><br><span class="line">    User user = User.builder().id(1L).age(2).name(&quot;Zhangsan&quot;).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://www.cnblogs.com/heyonggang/p/8638374.html" target="_blank" rel="noopener">https://www.cnblogs.com/heyonggang/p/8638374.html</a></li>
<li><a href="https://www.cnblogs.com/keeya/p/9929617.html" target="_blank" rel="noopener">https://www.cnblogs.com/keeya/p/9929617.html</a></li>
<li><a href="https://www.jianshu.com/p/2543c71a8e45" target="_blank" rel="noopener">https://www.jianshu.com/p/2543c71a8e45</a></li>
<li><a href="https://www.jianshu.com/p/ef0646d05f3c" target="_blank" rel="noopener">https://www.jianshu.com/p/ef0646d05f3c</a></li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>S3总结</title>
    <url>/2019/09/14/S3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="AWS-S3对象存储"><a href="#AWS-S3对象存储" class="headerlink" title="AWS S3对象存储"></a>AWS S3对象存储</h4><p>Amazon Simple Storage Service (Amazon S3) 是一种面向 Internet 的存储服务。您可以通过Amazon S3随时在Web上的任何位置存储和检索的任意大小的数 据。Amazon S3 特意内置了着重于简易性和稳健性的最小功能集。以下是 Amazon S3 服务的一些优势:</p>
<p>创建存储桶 – 创建和命名存储数据的存储桶。存储桶是 Amazon S3 中用于数据存储的基础容器。<br>在存储桶中存储数据 – 在存储桶中存储无限量的数据。可将所需数量的对象上传到 Amazon S3 存储桶。每个对象可包含最多 5TB的数据。使用开发人员分配的唯一键值存储和检索每个对象。</p>
<p>下载数据 – 下载您的数据或允许其他人下载。随时下载您的数据或允许其他人执行相同的操作。<br>权限 - 对于要在您的 Amazon S3 存储桶中上传或下载数据的其他人员，您可授予其访问权限或拒绝其访问。将上传和下载的许可授予3种类型的用户。身份验证机制可帮助确保数据安全，以防未授权访问<br>标准接口 – 使用标准的REST接口(SOAP接口已弃用)，它们可与任何 Internet 开发工具包搭配使用</p>
<h5 id="1-1-1-存储桶-bucket"><a href="#1-1-1-存储桶-bucket" class="headerlink" title="1.1.1 存储桶(bucket)"></a>1.1.1 存储桶(bucket)</h5><p>我们的数据都是存储在AWS 的存储桶中，我们可以把桶理解为磁盘分区，不过它是由一个桶名（字符串）唯一标识，即你不能创建别人已经创建过的桶。以下是S3 存储桶命名规则:<br>在S3中的所有现有存储桶名称中必须唯一<br>必须符合DNS命名约定<br>名称长度必须为至少3个字符，且不能超过 63 个字符<br>名称不能包含大写字符或下划线<br>名称必须以小写字母或数字开头<br>名称必须是一系列的一个或多个标签。相邻标签通过单个句点 (.) 分隔。名称可以包含小写字母、数字和连字符。每个标签都必须以小写字母或数字开头和结尾<br>名称不得采用IP地址格式<br>当通过安全套接字 (SSL) 使用虚拟托管式存储桶时，SSL通配符证书仅匹配不包含句点的存储桶。要解决此问题，请使用 HTTP或编写自己的证书验证逻辑</p>
<h5 id="1-1-2-对象"><a href="#1-1-2-对象" class="headerlink" title="1.1.2 对象"></a>1.1.2 对象</h5><p>对象是 Amazon S3 中存储的基本实体。对象由对象数据和元数据组成。数据部分对S3不透明。元数据是一组描述对象的名称-值对。其中包括一些默认元数据 (如上次修改日期) 和标准 HTTP 元数据 (如 Content-Type)。您还可在存储对象时指定自定义元数据。<br>在存储桶中，对象将由键 (名称) 和版本 ID 进行唯一标识<br>S3数据模型是一种扁平结构。不存在子存储桶或子文件夹层次结构；但可用键名称前缀和分隔符推断逻辑层次结构<br>键名称中的以下字符可能需要进行代码处理，且可能需要以16进制形式在URL中编码或引用。其中部分字符是不可打印的字符，浏览器可能无法处理，这也需特殊处理</p>
<table>
<thead>
<tr>
<th>选择</th>
<th>说明</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>表示和的符号 (“&amp;”)</td>
<td>美元 (“$”)</td>
<td>ASCII 字符范围 00–1F 十六进制 (0–31 十进制) 和 7F (127 十进制)</td>
</tr>
<tr>
<td>“At”符号 (“@”)</td>
<td>等于 (“=”)</td>
<td>分号 (“;”)</td>
</tr>
<tr>
<td>冒号 (“:”)</td>
<td>加号 (“+”)</td>
<td>空格 – 大量连续空格可能会在某些使用情形中丢失 (特别是多个空格)</td>
</tr>
<tr>
<td>逗号 (“,”)</td>
<td>问号 (“?”)</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="1-1-3-对象标签-tag"><a href="#1-1-3-对象标签-tag" class="headerlink" title="1.1.3 对象标签(tag)"></a>1.1.3 对象标签(tag)</h5><p>使用存储对象打标签对存储进行分类。每个标签都是一个键-值对。<br>您可以将标签添加到新对象 (当您上传新对象时)，也可以将标签添加到现有对象。请注意以下几点：</p>
<p>您最多可以将 10 个标签与对象关联。与对象关联的标签必须具有唯一的标签键。<br>标签键的长度最大可以为 128 个 Unicode 字符，标签值的长度最大可以为 256 个 Unicode 字符。<br>键和值区分大小写。<br>标签对于对象管理相当好用所以重点说明<br>利用标签，您现在获得了另一个维度。如果您希望 photo1 属于项目 x 类别，则可以相应地标记该对象。除了数据分类之外，标签还提供其他好处。例如:</p>
<p>对象标签支持权限的精细访问控制。例如，您可以向一个 IAM 用户授予仅读取带有特定标签的对象的权限。<br>对象标签支持精细的对象生命周期管理，在其中，除了在生命周期规则中指定键名称前缀之外，还可以指定基于标签的筛选条件。<br>使用 Amazon S3 分析时，您可以配置筛选条件，以便按对象标签、键名称前缀或前缀和标签的组合对对象进行分组以进行分析。<br>您还可以自定义 Amazon CloudWatch 指标以按特定标签筛选条件显示信息。以下各节提供了详细信息。</p>
<h4 id="S3存储类型"><a href="#S3存储类型" class="headerlink" title="S3存储类型"></a>S3存储类型</h4><p>Amazon S3 中的每个对象都有与之关联的存储类别</p>
<p><img src="/2019/09/14/S3总结/S3.png" alt="avatar"></p>
<p>对于经常访问的存储类均为STANDARD，我们默认也是该存储类<br>创建对象时，要指定键名称(Key)，它在存储桶中唯一地标识该对象。可以理解为存储文件相对于当前桶的路径。</p>
<h4 id="S3数据一致性模型"><a href="#S3数据一致性模型" class="headerlink" title="S3数据一致性模型"></a>S3数据一致性模型</h4><p>S3在所有区域为S3存储桶中的新对象的PUTS提供写后读一致性，但要注意，如果在创建对象前对键名发出HEAD或GET请求 (查看该对象是否存在)S3提供写后读最终一致性。</p>
<p>S3在所有区域提供最终一致性用于覆盖PUTS和DELETES。</p>
<p>单个键的更新是原子更新。例如，如果您对一个现有键执行PUT操作，则后续读取可能会返回旧数据或已更新的数据，但它永远不会返回损坏的数据或部分数据。</p>
<p>S3通过在卓越亚马逊数据中心内的多个服务器间复制数据，从而实现高可用。如果PUT请求成功，则数据已安全存储。但有关更改的信息必须在S3间进行复制，这可能需要一些时间，因此您可能会观察到以下行为：</p>
<p>这是一个过程，会将一个新对象写入S3，并立即列出其存储桶内的键。在充分传播此更改前，此对象可能不会显示在列表<br>这是一个过程，会替换一个现有对象，并立即尝试读取此对象。在充分传播此更改前，S3可能会返回先前的数据<br>这是一个过程，会删除一个现有的对象，并立即尝试读取此对象。在充分传播此删除前，S3可能会返回删除的数据<br>这是一个过程，会删除一个现有的对象，并立即列出其存储桶内的键。在充分传播此删除前，S3可能会列出删除的对象<br>注意: S3目前不支持对象锁定。如果同时对同一键发出2个PUT请求，则以带有最新时间戳的请求为准。如果这会导致问题，您需在应用程序中创建对象锁定机制。</p>
<p>更新基于键值; 无法跨键值实现原子更新。例如，无法根据一个键值的更新对另一键值进行更新，除非将此功能设计到应用程序</p>
<h4 id="代码实例操作"><a href="#代码实例操作" class="headerlink" title="代码实例操作"></a>代码实例操作</h4><p>Java创建存储桶<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">import com.amazonaws.AmazonServiceException;</span><br><span class="line">import com.amazonaws.SdkClientException;</span><br><span class="line">import com.amazonaws.auth.profile.ProfileCredentialsProvider;</span><br><span class="line">import com.amazonaws.services.s3.AmazonS3;</span><br><span class="line">import com.amazonaws.services.s3.AmazonS3ClientBuilder;</span><br><span class="line">import com.amazonaws.services.s3.model.CreateBucketRequest;</span><br><span class="line">import com.amazonaws.services.s3.model.GetBucketLocationRequest;</span><br><span class="line"> </span><br><span class="line">public class CreateBucket &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String clientRegion = &quot;*** Client region ***&quot;;</span><br><span class="line">        String bucketName = &quot;*** Bucket name ***&quot;;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            AmazonS3 s3Client = AmazonS3ClientBuilder.standard()</span><br><span class="line">                    .withCredentials(new ProfileCredentialsProvider())</span><br><span class="line">                    .withRegion(clientRegion)</span><br><span class="line">                    .build();</span><br><span class="line"> </span><br><span class="line">            if (!s3Client.doesBucketExistV2(bucketName)) &#123;</span><br><span class="line">                // Because the CreateBucketRequest object doesn&apos;t specify a region, the</span><br><span class="line">                // bucket is created in the region specified in the client.</span><br><span class="line">                s3Client.createBucket(new CreateBucketRequest(bucketName));</span><br><span class="line">                </span><br><span class="line">                // Verify that the bucket was created by retrieving it and checking its location.</span><br><span class="line">                String bucketLocation = s3Client.getBucketLocation(new GetBucketLocationRequest(bucketName));</span><br><span class="line">                System.out.println(&quot;Bucket location: &quot; + bucketLocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(AmazonServiceException e) &#123;</span><br><span class="line">            // The call was transmitted successfully, but Amazon S3 couldn&apos;t process </span><br><span class="line">            // it and returned an error response.</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(SdkClientException e) &#123;</span><br><span class="line">            // Amazon S3 couldn&apos;t be contacted for a response, or the client</span><br><span class="line">            // couldn&apos;t parse the response from Amazon S3.</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java删除存储桶<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Iterator;</span><br><span class="line"> </span><br><span class="line">import com.amazonaws.AmazonServiceException;</span><br><span class="line">import com.amazonaws.SdkClientException;</span><br><span class="line">import com.amazonaws.auth.profile.ProfileCredentialsProvider;</span><br><span class="line">import com.amazonaws.services.s3.AmazonS3;</span><br><span class="line">import com.amazonaws.services.s3.AmazonS3ClientBuilder;</span><br><span class="line">import com.amazonaws.services.s3.model.ListVersionsRequest;</span><br><span class="line">import com.amazonaws.services.s3.model.ObjectListing;</span><br><span class="line">import com.amazonaws.services.s3.model.S3ObjectSummary;</span><br><span class="line">import com.amazonaws.services.s3.model.S3VersionSummary;</span><br><span class="line">import com.amazonaws.services.s3.model.VersionListing;</span><br><span class="line"> </span><br><span class="line">public class DeleteBucket &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String clientRegion = &quot;*** Client region ***&quot;;</span><br><span class="line">        String bucketName = &quot;*** Bucket name ***&quot;;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            AmazonS3 s3Client = AmazonS3ClientBuilder.standard()</span><br><span class="line">                    .withCredentials(new ProfileCredentialsProvider())</span><br><span class="line">                    .withRegion(clientRegion)</span><br><span class="line">                    .build();</span><br><span class="line">    </span><br><span class="line">            // Delete all objects from the bucket. This is sufficient</span><br><span class="line">            // for unversioned buckets. For versioned buckets, when you attempt to delete objects, Amazon S3 inserts</span><br><span class="line">            // delete markers for all objects, but doesn&apos;t delete the object versions.</span><br><span class="line">            // To delete objects from versioned buckets, delete all of the object versions before deleting</span><br><span class="line">            // the bucket (see below for an example).</span><br><span class="line">            ObjectListing objectListing = s3Client.listObjects(bucketName);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Iterator&lt;S3ObjectSummary&gt; objIter = objectListing.getObjectSummaries().iterator();</span><br><span class="line">                while (objIter.hasNext()) &#123;</span><br><span class="line">                    s3Client.deleteObject(bucketName, objIter.next().getKey());</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                // If the bucket contains many objects, the listObjects() call</span><br><span class="line">                // might not return all of the objects in the first listing. Check to</span><br><span class="line">                // see whether the listing was truncated. If so, retrieve the next page of objects </span><br><span class="line">                // and delete them.</span><br><span class="line">                if (objectListing.isTruncated()) &#123;</span><br><span class="line">                    objectListing = s3Client.listNextBatchOfObjects(objectListing);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // Delete all object versions (required for versioned buckets).</span><br><span class="line">            VersionListing versionList = s3Client.listVersions(new ListVersionsRequest().withBucketName(bucketName));</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Iterator&lt;S3VersionSummary&gt; versionIter = versionList.getVersionSummaries().iterator();</span><br><span class="line">                while (versionIter.hasNext()) &#123;</span><br><span class="line">                    S3VersionSummary vs = versionIter.next();</span><br><span class="line">                    s3Client.deleteVersion(bucketName, vs.getKey(), vs.getVersionId());</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                if (versionList.isTruncated()) &#123;</span><br><span class="line">                    versionList = s3Client.listNextBatchOfVersions(versionList);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // After all objects and object versions are deleted, delete the bucket.</span><br><span class="line">            s3Client.deleteBucket(bucketName);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(AmazonServiceException e) &#123;</span><br><span class="line">            // The call was transmitted successfully, but Amazon S3 couldn&apos;t process </span><br><span class="line">            // it, so it returned an error response.</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(SdkClientException e) &#123;</span><br><span class="line">            // Amazon S3 couldn&apos;t be contacted for a response, or the client couldn&apos;t</span><br><span class="line">            // parse the response from Amazon S3.</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可配置存储桶的生命周期以使对象过期，S3随后将删除过期对象。可添加生命周期配置规则，以使所有或部分带特定键名称前缀的对象过期。e.g.,要删除存储桶中所有对象，可将生命周期规则设置为使对象在创建一天后过期。在S3删除所有对象后，可删除或保留存储桶.(未启用版本控制的存储桶，可直接删除所有对象，然后删除存储桶。启用了版本控制的存储桶，必须先删除所有对象版本，然后再删除存储桶)<br>Java管理存储桶的网站配置(要将网站配置添加到存储桶，请提供存储桶名称和网站配置。网站配置必须包含索引文档，且可包含可选的错误文档。这些文档必须已存在于存储桶)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">import com.amazonaws.AmazonServiceException;</span><br><span class="line">import com.amazonaws.SdkClientException;</span><br><span class="line">import com.amazonaws.auth.profile.ProfileCredentialsProvider;</span><br><span class="line">import com.amazonaws.services.s3.AmazonS3;</span><br><span class="line">import com.amazonaws.services.s3.AmazonS3ClientBuilder;</span><br><span class="line">import com.amazonaws.services.s3.model.BucketWebsiteConfiguration;</span><br><span class="line"> </span><br><span class="line">public class WebsiteConfiguration &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String clientRegion = &quot;*** Client region ***&quot;;</span><br><span class="line">        String bucketName = &quot;*** Bucket name ***&quot;;</span><br><span class="line">        String indexDocName = &quot;*** Index document name ***&quot;;</span><br><span class="line">        String errorDocName = &quot;*** Error document name ***&quot;;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            AmazonS3 s3Client = AmazonS3ClientBuilder.standard()</span><br><span class="line">                    .withRegion(clientRegion)</span><br><span class="line">                    .withCredentials(new ProfileCredentialsProvider())</span><br><span class="line">                    .build();</span><br><span class="line"> </span><br><span class="line">            // Print the existing website configuration, if it exists.</span><br><span class="line">            printWebsiteConfig(s3Client, bucketName);</span><br><span class="line">    </span><br><span class="line">            // Set the new website configuration.</span><br><span class="line">            s3Client.setBucketWebsiteConfiguration(bucketName, new BucketWebsiteConfiguration(indexDocName, errorDocName));</span><br><span class="line">    </span><br><span class="line">            // Verify that the configuration was set properly by printing it.</span><br><span class="line">            printWebsiteConfig(s3Client, bucketName);</span><br><span class="line">    </span><br><span class="line">            // Delete the website configuration.</span><br><span class="line">            s3Client.deleteBucketWebsiteConfiguration(bucketName);</span><br><span class="line">    </span><br><span class="line">            // Verify that the website configuration was deleted by printing it.</span><br><span class="line">            printWebsiteConfig(s3Client, bucketName);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(AmazonServiceException e) &#123;</span><br><span class="line">            // The call was transmitted successfully, but Amazon S3 couldn&apos;t process </span><br><span class="line">            // it, so it returned an error response.</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(SdkClientException e) &#123;</span><br><span class="line">            // Amazon S3 couldn&apos;t be contacted for a response, or the client</span><br><span class="line">            // couldn&apos;t parse the response from Amazon S3.</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void printWebsiteConfig(AmazonS3 s3Client, String bucketName) &#123;</span><br><span class="line">        System.out.println(&quot;Website configuration: &quot;);</span><br><span class="line">        BucketWebsiteConfiguration bucketWebsiteConfig = s3Client.getBucketWebsiteConfiguration(bucketName);</span><br><span class="line">        if (bucketWebsiteConfig == null) &#123;</span><br><span class="line">            System.out.println(&quot;No website config.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Index doc: &quot; + bucketWebsiteConfig.getIndexDocumentSuffix());</span><br><span class="line">            System.out.println(&quot;Error doc: &quot; + bucketWebsiteConfig.getErrorDocument());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上传对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//存储桶的名字</span><br><span class="line">    private String bucket_name=&quot;beijing&quot;;</span><br><span class="line">    //自定义上传到bucket后的目录结构</span><br><span class="line">    private String key_name=&quot;beijing/haidingqu/xierqi/yuanzougaofei.mp3&quot;;</span><br><span class="line">    //本地文件路径</span><br><span class="line">    private String file_path=&quot;E:/music/china/yuanzougaofei.mp3&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 上传文件到指定的bucket中。</span><br><span class="line">     * 注意点：这里的本地路径的文件必须存在才行，不然文件不存在回异常。</span><br><span class="line">     */</span><br><span class="line">    public void uploadObj()&#123;</span><br><span class="line">        final AmazonS3 s3 = new AmazonS3Client();</span><br><span class="line">        try &#123;</span><br><span class="line">            s3.putObject(bucket_name, key_name, file_path);</span><br><span class="line">        &#125; catch (AmazonServiceException e) &#123;</span><br><span class="line">            System.err.println(e.getErrorMessage());</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>列出所有bucket中的对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void showListObjFromBucket(String bucketName)&#123;</span><br><span class="line">        final AmazonS3 s3 = new AmazonS3Client();</span><br><span class="line">        ObjectListing ol = s3.listObjects(bucketName);</span><br><span class="line"></span><br><span class="line">        List&lt;S3ObjectSummary&gt; objects = ol.getObjectSummaries();</span><br><span class="line"></span><br><span class="line">        for (S3ObjectSummary os: objects) &#123;</span><br><span class="line">            System.out.println(&quot;* &quot; + os.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>下载对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void downloadObjByKey(String buketName,String key)&#123;</span><br><span class="line">        final AmazonS3 s3 = new AmazonS3Client();</span><br><span class="line">        try &#123;</span><br><span class="line">            S3Object o = s3.getObject(buketName, key);</span><br><span class="line">            S3ObjectInputStream s3is = o.getObjectContent();</span><br><span class="line">            //下载到指定路径file_path下</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(new File(file_path));</span><br><span class="line">            byte[] read_buf = new byte[1024];</span><br><span class="line">            int read_len = 0;</span><br><span class="line">            while ((read_len = s3is.read(read_buf)) &gt; 0) &#123;</span><br><span class="line">                fos.write(read_buf, 0, read_len);</span><br><span class="line">            &#125;</span><br><span class="line">            s3is.close();</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; catch (AmazonServiceException e) &#123;</span><br><span class="line">            System.err.println(e.getErrorMessage());</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>删除对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void deleteObject(String bucket_name, String object_key) &#123;</span><br><span class="line">        final AmazonS3 s3 = new AmazonS3Client();</span><br><span class="line">        try &#123;</span><br><span class="line">            s3.deleteObject(bucket_name, object_key);</span><br><span class="line">        &#125; catch (AmazonServiceException e) &#123;</span><br><span class="line">            System.err.println(e.getErrorMessage());</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://blog.csdn.net/m0_37263637/article/details/80697920" target="_blank" rel="noopener">https://blog.csdn.net/m0_37263637/article/details/80697920</a><br><a href="https://blog.csdn.net/u013747798/article/details/85261830" target="_blank" rel="noopener">https://blog.csdn.net/u013747798/article/details/85261830</a><br><a href="https://blog.csdn.net/zhanglf02/article/details/78500015" target="_blank" rel="noopener">https://blog.csdn.net/zhanglf02/article/details/78500015</a><br><a href="https://blog.csdn.net/weixin_33851429/article/details/91907444" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33851429/article/details/91907444</a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java日志体系</title>
    <url>/2020/04/25/java%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s/iuWJxBghqhF09JqYfejBWw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/iuWJxBghqhF09JqYfejBWw</a></p>
<p>在项目开发中，为了跟踪代码的运行情况，常常要使用日志来记录信息。在 Java 世界，有很多的日志工具库来实现日志功能，避免了我们重复造轮子。</p>
<p>我们先来逐一了解一下主流日志工具。</p>
<h4 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h4><p><strong>java.util.logging (JUL)</strong></p>
<p>JDK1.4 开始，通过 java.util.logging 提供日志功能。</p>
<p>它能满足基本的日志需要，但是功能没有 Log4j 强大，而且使用范围也没有 Log4j 广泛。</p>
<p><strong>Log4j</strong></p>
<p>Log4j 是 apache 的一个开源项目，创始人 Ceki Gulcu。</p>
<p>Log4j 应该说是 Java 领域资格最老，应用最广的日志工具。从诞生之日到现在一直广受业界欢迎。</p>
<p>Log4j 是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX 系统日志等。</p>
<p><strong>Log4j 中有三个主要组成部分：</strong></p>
<ul>
<li>loggers - 负责捕获记录信息。</li>
<li>appenders - 负责发布日志信息，以不同的首选目的地。</li>
<li>layouts - 负责格式化不同风格的日志信息。</li>
</ul>
<p>官网地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://logging.apache.org/log4j/2.x/</span><br></pre></td></tr></table></figure>
<p><strong>Logback</strong></p>
<p>Logback 是由 log4j 创始人 Ceki Gulcu 设计的又一个开源日记组件，目标是替代 log4j。<br>logback 当前分成三个模块：logback-core、logback-classic 和 logback-access。</p>
<ul>
<li>logback-core - 是其它两个模块的基础模块。</li>
<li>logback-classic - 是 log4j 的一个 改良版本。此外 logback-classic 完整实现 SLF4J API 使你可以很方便地更换成其它日记系统如 log4j 或 JDK14 Logging。</li>
<li>logback-access - 访问模块与 Servlet 容器集成提供通过 Http 来访问日记的功能。</li>
</ul>
<p>官网地址:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://logback.qos.ch/</span><br></pre></td></tr></table></figure>
<p><strong>Log4j2</strong></p>
<p>官网地址:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://logging.apache.org/log4j/2.x/</span><br></pre></td></tr></table></figure>
<p>按照官方的说法，Log4j2 是 Log4j 和 Logback 的替代。</p>
<p>Log4j2 架构：</p>
<p><img src="/2020/04/25/java日志体系/log4j2.png" alt="avatar"></p>
<p><strong>Log4j vs Logback vs Log4j2</strong></p>
<p>按照官方的说法，Log4j2 大大优于 Log4j 和 Logback。</p>
<p>那么，Log4j2 相比于先问世的 Log4j 和 Logback，它具有哪些优势呢？</p>
<ul>
<li>Log4j2 旨在用作审计日志记录框架。Log4j1.x 和 Logback 都会在重新配置时丢失事件。Log4j2 不会。在 Logback 中，Appender 中的异常永远不会对应用程序可见。在 Log4j 中，可以将 Appender 配置为允许异常渗透到应用程序。</li>
<li>Log4j2 在多线程场景中，异步 Loggers 的吞吐量比 Log4j1.x 和 Logback 高 10 倍，延迟低几个数量级。</li>
<li>Log4j2 对于独立应用程序是无垃圾的，对于稳定状态日志记录期间的 Web 应用程序来说是低垃圾。这减少了垃圾收集器的压力，并且可以提供更好的响应时间性能。</li>
<li>Log4j2 使用插件系统，通过添加新的 Appender、Filter、Layout、Lookup 和 Pattern Converter，可以非常轻松地扩展框架，而无需对 Log4j 进行任何更改。</li>
<li>由于插件系统配置更简单。配置中的条目不需要指定类名。</li>
<li>支持自定义日志等级。</li>
<li>支持 lambda 表达式。</li>
<li>支持消息对象。</li>
<li>Log4j 和 Logback 的 Layout 返回的是字符串，而 Log4j2 返回的是二进制数组，这使得它能被各种 Appender 使用。</li>
<li>Syslog Appender 支持 TCP 和 UDP 并且支持 BSD 系统日志。</li>
<li>Log4j2 利用 Java5 并发特性，尽量小粒度的使用锁，减少锁的开销。</li>
</ul>
<h4 id="日志门面"><a href="#日志门面" class="headerlink" title="日志门面"></a>日志门面</h4><p><strong>何谓日志门面？</strong></p>
<p>日志门面是对不同日志框架提供的一个 API 封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。</p>
<p><strong>common-logging</strong></p>
<p>common-logging 是 apache 的一个开源项目。也称Jakarta Commons Logging，缩写 JCL。<br>common-logging 的功能是提供日志功能的 API 接口，本身并不提供日志的具体实现（当然，common-logging 内部有一个 Simple logger 的简单实现，但是功能很弱，直接忽略），而是在运行时动态的绑定日志实现组件来工作（如 log4j、java.util.logging）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网地址: http://commons.apache.org/proper/commons-logging/</span><br></pre></td></tr></table></figure></p>
<p><strong>slf4j</strong></p>
<p>全称为 Simple Logging Facade for Java，即 java 简单日志门面。<br>什么，作者又是 Ceki Gulcu！这位大神写了 Log4j、Logback 和 slf4j，专注日志组件开发五百年，一直只能超越自己。<br>类似于 Common-Logging，slf4j 是对不同日志框架提供的一个 API 封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。但是，slf4j 在编译时静态绑定真正的 Log 库。使用 SLF4J 时，如果你需要使用某一种日志实现，那么你必须选择正确的 SLF4J 的 jar 包的集合（各种桥接包）。<br><img src="/2020/04/25/java日志体系/slf4j.png" alt="avatar"></p>
<p><strong>common-logging vs slf4j</strong></p>
<p>slf4j 库类似于 Apache Common-Logging。但是，他在编译时静态绑定真正的日志库。这点似乎很麻烦，其实也不过是导入桥接 jar 包而已。</p>
<p>slf4j 一大亮点是提供了更方便的日志记录方式：</p>
<p>不需要使用logger.isDebugEnabled()来解决日志因为字符拼接产生的性能问题。slf4j 的方式是使用{}作为字符串替换符，形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.debug(&quot;id: &#123;&#125;, name: &#123;&#125; &quot;, id, name);</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>综上所述，使用 slf4j + Logback 可谓是目前最理想的日志解决方案了。<br>接下来，就是如何在项目中实施了。</p>
<h4 id="实施日志解决方案"><a href="#实施日志解决方案" class="headerlink" title="实施日志解决方案"></a>实施日志解决方案</h4><p>使用日志解决方案基本可分为三步：</p>
<ul>
<li>引入 jar 包</li>
<li>配置</li>
<li>使用 API<br>常见的各种日志解决方案的第 2 步和第 3 步基本一样，实施上的差别主要在第 1 步，也就是使用不同的库。</li>
</ul>
<p><strong>引入 jar 包</strong></p>
<p>这里首选推荐使用 slf4j + logback 的组合。</p>
<p>如果你习惯了 common-logging，可以选择 common-logging+log4j。</p>
<p>强烈建议不要直接使用日志实现组件(logback、log4j、java.util.logging)，理由前面也说过，就是无法灵活替换日志库。</p>
<p>还有一种情况：你的老项目使用了 common-logging，或是直接使用日志实现组件。如果修改老的代码，工作量太大，需要兼容处理。在下文，都将看到各种应对方法。</p>
<p><strong>slf4j 直接绑定日志组件</strong></p>
<p><strong>slf4j + logback</strong><br>添加依赖到 pom.xml 中即可。<br>logback-classic-1.0.13.jar 会自动将 slf4j-api-1.7.21.jar 和 logback-core-1.0.13.jar 也添加到你的项目中。</p>
<p><strong>slf4j + log4j</strong></p>
<p>添加依赖到 pom.xml 中即可。<br>slf4j-log4j12-1.7.21.jar 会自动将 slf4j-api-1.7.21.jar 和 log4j-1.2.17.jar 也添加到你的项目中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>slf4j + java.util.logging</strong></p>
<p>添加依赖到 pom.xml 中即可。<br>slf4j-jdk14-1.7.21.jar 会自动将 slf4j-api-1.7.21.jar 也添加到你的项目中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>slf4j 兼容非 slf4j 日志组件</strong></p>
<p>在介绍解决方案前，先提一个概念——桥接</p>
<p>什么是桥接呢<br>假如你正在开发应用程序所调用的组件当中已经使用了 common-logging，这时你需要 jcl-over-slf4j.jar 把日志信息输出重定向到 slf4j-api，slf4j-api 再去调用 slf4j 实际依赖的日志组件。这个过程称为桥接。下图是官方的 slf4j 桥接策略图：<br><img src="/2020/04/25/java日志体系/bridge.png" alt="avatar"></p>
<p>从图中应该可以看出，无论你的老项目中使用的是 common-logging 或是直接使用 log4j、java.util.logging，都可以使用对应的桥接 jar 包来解决兼容问题。</p>
<p><strong>slf4j 兼容 common-logging</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.7.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>slf4j 兼容 log4j</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>slf4j 兼容 java.util.logging</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>spring 集成 slf4j</strong></p>
<p>做 java web 开发，基本离不开 spring 框架。很遗憾，spring 使用的日志解决方案是 common-logging + log4j。<br>所以，你需要一个桥接 jar 包：logback-ext-spring。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.logback-extensions&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;logback-ext-spring&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.7.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>common-logging 绑定日志组件</strong></p>
<p>common-logging + log4j<br>添加依赖到 pom.xml 中即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用 API</strong></p>
<p><strong>slf4j 用法</strong></p>
<p>使用 slf4j 的 API 很简单。使用LoggerFactory初始化一个Logger实例，然后调用 Logger 对应的打印等级函数就行了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(App.class);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String msg = &quot;print log, current level: &#123;&#125;&quot;;</span><br><span class="line">        log.trace(msg, &quot;trace&quot;);</span><br><span class="line">        log.debug(msg, &quot;debug&quot;);</span><br><span class="line">        log.info(msg, &quot;info&quot;);</span><br><span class="line">        log.warn(msg, &quot;warn&quot;);</span><br><span class="line">        log.error(msg, &quot;error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>common-logging 用法</strong></p>
<p>common-logging 用法和 slf4j 几乎一样，但是支持的打印等级多了一个更高级别的：fatal。<br>此外，common-logging 不支持{}替换参数，你只能选择拼接字符串这种方式了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.logging.Log;</span><br><span class="line">import org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line">public class JclTest &#123;</span><br><span class="line">    private static final Log log = LogFactory.getLog(JclTest.class);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String msg = &quot;print log, current level: &quot;;</span><br><span class="line">        log.trace(msg + &quot;trace&quot;);</span><br><span class="line">        log.debug(msg + &quot;debug&quot;);</span><br><span class="line">        log.info(msg + &quot;info&quot;);</span><br><span class="line">        log.warn(msg + &quot;warn&quot;);</span><br><span class="line">        log.error(msg + &quot;error&quot;);</span><br><span class="line">        log.fatal(msg + &quot;fatal&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>log4j2 配置</strong></p>
<p>log4j2 基本配置形式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;;</span><br><span class="line">&lt;Configuration&gt;</span><br><span class="line">  &lt;Properties&gt;</span><br><span class="line">    &lt;Property name=&quot;name1&quot;&gt;value&lt;/property&gt;</span><br><span class="line">    &lt;Property name=&quot;name2&quot; value=&quot;value2&quot;/&gt;</span><br><span class="line">  &lt;/Properties&gt;</span><br><span class="line">  &lt;Filter type=&quot;type&quot; ... /&gt;</span><br><span class="line">  &lt;Appenders&gt;</span><br><span class="line">    &lt;Appender type=&quot;type&quot; name=&quot;name&quot;&gt;</span><br><span class="line">      &lt;Filter type=&quot;type&quot; ... /&gt;</span><br><span class="line">    &lt;/Appender&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/Appenders&gt;</span><br><span class="line">  &lt;Loggers&gt;</span><br><span class="line">    &lt;Logger name=&quot;name1&quot;&gt;</span><br><span class="line">      &lt;Filter type=&quot;type&quot; ... /&gt;</span><br><span class="line">    &lt;/Logger&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;Root level=&quot;level&quot;&gt;</span><br><span class="line">      &lt;AppenderRef ref=&quot;name&quot;/&gt;</span><br><span class="line">    &lt;/Root&gt;</span><br><span class="line">  &lt;/Loggers&gt;</span><br><span class="line">&lt;/Configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>配置示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Configuration status=&quot;debug&quot; strict=&quot;true&quot; name=&quot;XMLConfigTest&quot;</span><br><span class="line">               packages=&quot;org.apache.logging.log4j.test&quot;&gt;</span><br><span class="line">  &lt;Properties&gt;</span><br><span class="line">    &lt;Property name=&quot;filename&quot;&gt;target/test.log&lt;/Property&gt;</span><br><span class="line">  &lt;/Properties&gt;</span><br><span class="line">  &lt;Filter type=&quot;ThresholdFilter&quot; level=&quot;trace&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Appenders&gt;</span><br><span class="line">    &lt;Appender type=&quot;Console&quot; name=&quot;STDOUT&quot;&gt;</span><br><span class="line">      &lt;Layout type=&quot;PatternLayout&quot; pattern=&quot;%m MDC%X%n&quot;/&gt;</span><br><span class="line">      &lt;Filters&gt;</span><br><span class="line">        &lt;Filter type=&quot;MarkerFilter&quot; marker=&quot;FLOW&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;</span><br><span class="line">        &lt;Filter type=&quot;MarkerFilter&quot; marker=&quot;EXCEPTION&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;ACCEPT&quot;/&gt;</span><br><span class="line">      &lt;/Filters&gt;</span><br><span class="line">    &lt;/Appender&gt;</span><br><span class="line">    &lt;Appender type=&quot;Console&quot; name=&quot;FLOW&quot;&gt;</span><br><span class="line">      &lt;Layout type=&quot;PatternLayout&quot; pattern=&quot;%C&#123;1&#125;.%M %m %ex%n&quot;/&gt;&lt;!-- class and line number --&gt;</span><br><span class="line">      &lt;Filters&gt;</span><br><span class="line">        &lt;Filter type=&quot;MarkerFilter&quot; marker=&quot;FLOW&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;</span><br><span class="line">        &lt;Filter type=&quot;MarkerFilter&quot; marker=&quot;EXCEPTION&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;</span><br><span class="line">      &lt;/Filters&gt;</span><br><span class="line">    &lt;/Appender&gt;</span><br><span class="line">    &lt;Appender type=&quot;File&quot; name=&quot;File&quot; fileName=&quot;$&#123;filename&#125;&quot;&gt;</span><br><span class="line">      &lt;Layout type=&quot;PatternLayout&quot;&gt;</span><br><span class="line">        &lt;Pattern&gt;%d %p %C&#123;1.&#125; [%t] %m%n&lt;/Pattern&gt;</span><br><span class="line">      &lt;/Layout&gt;</span><br><span class="line">    &lt;/Appender&gt;</span><br><span class="line">  &lt;/Appenders&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Loggers&gt;</span><br><span class="line">    &lt;Logger name=&quot;org.apache.logging.log4j.test1&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;</span><br><span class="line">      &lt;Filter type=&quot;ThreadContextMapFilter&quot;&gt;</span><br><span class="line">        &lt;KeyValuePair key=&quot;test&quot; value=&quot;123&quot;/&gt;</span><br><span class="line">      &lt;/Filter&gt;</span><br><span class="line">      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">    &lt;/Logger&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Logger name=&quot;org.apache.logging.log4j.test2&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;</span><br><span class="line">      &lt;AppenderRef ref=&quot;File&quot;/&gt;</span><br><span class="line">    &lt;/Logger&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Root level=&quot;trace&quot;&gt;</span><br><span class="line">      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">    &lt;/Root&gt;</span><br><span class="line">  &lt;/Loggers&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Configuration&gt;</span><br></pre></td></tr></table></figure>
<p><strong>logback 配置</strong></p>
<p><strong>configuration</strong></p>
<p>作用：configuration 是 logback 配置文件的根元素。</p>
<p>要点：它有 appender、logger、root 三个子元素。</p>
<p><img src="/2020/04/25/java日志体系/logback.png" alt="avatar"></p>
<p><strong>appender</strong></p>
<p>作用：将记录日志的任务委托给名为 appender 的组件。<br>要点：可以配置零个或多个；它有 file、filter、layout、encoder 四个子元素。<br>属性：</p>
<ul>
<li>name：设置 appender 名称。</li>
<li>class：设置具体的实例化类。</li>
</ul>
<p><strong>file</strong></p>
<p>作用：设置日志文件路径。</p>
<p><strong>filter</strong></p>
<p>作用：设置过滤器。<br>要点：可以配置零个或多个。</p>
<p><strong>layout</strong></p>
<p>作用：设置 appender。<br>要点：可以配置零个或一个。<br>属性：<br>class：设置具体的实例化类。</p>
<p><strong>encoder</strong></p>
<p>作用：设置编码。<br>要点：可以配置零个或多个。<br>属性：<br>class：设置具体的实例化类。</p>
<p><img src="/2020/04/25/java日志体系/appender.png" alt="avatar"></p>
<p><strong>logger</strong><br>作用：设置 logger。<br>要点：可以配置零个或多个。<br>属性：<br>name<br>level：设置日志级别。不区分大小写。可选值：TRACE、DEBUG、INFO、WARN、ERROR、ALL、OFF。<br>additivity：可选值：true 或 false。</p>
<p><strong>appender-ref</strong><br>作用：appender 引用。<br>要点：可以配置零个或多个。</p>
<p><strong>root</strong></p>
<p>作用：设置根 logger。<br>要点：只能配置一个；除了 level，不支持任何属性。level 属性和 logger 中的相同；有一个子元素 appender-ref，与 logger 中的相同。</p>
<p><strong>完整的 logback.xml 参考示例</strong><br>在下面的配置文件中，我为自己的项目代码（根目录：org.zp.notes.spring）设置了五种等级：<br>TRACE、DEBUG、INFO、WARN、ERROR，优先级依次从低到高。<br>因为关注 spring 框架本身的一些信息，我增加了专门打印 spring WARN 及以上等级的日志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- logback中一共有5种有效级别，分别是TRACE、DEBUG、INFO、WARN、ERROR，优先级依次从低到高 --&gt;</span><br><span class="line">&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property name=&quot;DIR_NAME&quot; value=&quot;spring-helloworld&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 将记录日志打印到控制台 --&gt;</span><br><span class="line">  &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">      &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] [%-5p] %c&#123;36&#125;.%M - %m%n&lt;/pattern&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- RollingFileAppender begin --&gt;</span><br><span class="line">  &lt;appender name=&quot;ALL&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;!-- 根据时间来制定滚动策略 --&gt;</span><br><span class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">      &lt;fileNamePattern&gt;$&#123;user.dir&#125;/logs/$&#123;DIR_NAME&#125;/all.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">    &lt;/rollingPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 根据文件大小来制定滚动策略 --&gt;</span><br><span class="line">    &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;</span><br><span class="line">      &lt;maxFileSize&gt;30MB&lt;/maxFileSize&gt;</span><br><span class="line">    &lt;/triggeringPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">      &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] [%-5p] %c&#123;36&#125;.%M - %m%n&lt;/pattern&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">  &lt;appender name=&quot;ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;!-- 根据时间来制定滚动策略 --&gt;</span><br><span class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">      &lt;fileNamePattern&gt;$&#123;user.dir&#125;/logs/$&#123;DIR_NAME&#125;/error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">    &lt;/rollingPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 根据文件大小来制定滚动策略 --&gt;</span><br><span class="line">    &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;</span><br><span class="line">      &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span><br><span class="line">    &lt;/triggeringPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">      &lt;level&gt;ERROR&lt;/level&gt;</span><br><span class="line">      &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">      &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">      &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] [%-5p] %c&#123;36&#125;.%M - %m%n&lt;/pattern&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">  &lt;appender name=&quot;WARN&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;!-- 根据时间来制定滚动策略 --&gt;</span><br><span class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">      &lt;fileNamePattern&gt;$&#123;user.dir&#125;/logs/$&#123;DIR_NAME&#125;/warn.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">    &lt;/rollingPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 根据文件大小来制定滚动策略 --&gt;</span><br><span class="line">    &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;</span><br><span class="line">      &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span><br><span class="line">    &lt;/triggeringPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">      &lt;level&gt;WARN&lt;/level&gt;</span><br><span class="line">      &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">      &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">      &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] [%-5p] %c&#123;36&#125;.%M - %m%n&lt;/pattern&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">  &lt;appender name=&quot;INFO&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;!-- 根据时间来制定滚动策略 --&gt;</span><br><span class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">      &lt;fileNamePattern&gt;$&#123;user.dir&#125;/logs/$&#123;DIR_NAME&#125;/info.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">    &lt;/rollingPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 根据文件大小来制定滚动策略 --&gt;</span><br><span class="line">    &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;</span><br><span class="line">      &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span><br><span class="line">    &lt;/triggeringPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">      &lt;level&gt;INFO&lt;/level&gt;</span><br><span class="line">      &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">      &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">      &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] [%-5p] %c&#123;36&#125;.%M - %m%n&lt;/pattern&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">  &lt;appender name=&quot;DEBUG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;!-- 根据时间来制定滚动策略 --&gt;</span><br><span class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">      &lt;fileNamePattern&gt;$&#123;user.dir&#125;/logs/$&#123;DIR_NAME&#125;/debug.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">    &lt;/rollingPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 根据文件大小来制定滚动策略 --&gt;</span><br><span class="line">    &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;</span><br><span class="line">      &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span><br><span class="line">    &lt;/triggeringPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">      &lt;level&gt;DEBUG&lt;/level&gt;</span><br><span class="line">      &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">      &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">      &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] [%-5p] %c&#123;36&#125;.%M - %m%n&lt;/pattern&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">  &lt;appender name=&quot;TRACE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;!-- 根据时间来制定滚动策略 --&gt;</span><br><span class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">      &lt;fileNamePattern&gt;$&#123;user.dir&#125;/logs/$&#123;DIR_NAME&#125;/trace.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">    &lt;/rollingPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 根据文件大小来制定滚动策略 --&gt;</span><br><span class="line">    &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;</span><br><span class="line">      &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span><br><span class="line">    &lt;/triggeringPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">      &lt;level&gt;TRACE&lt;/level&gt;</span><br><span class="line">      &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">      &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">      &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] [%-5p] %c&#123;36&#125;.%M - %m%n&lt;/pattern&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">  &lt;appender name=&quot;SPRING&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;!-- 根据时间来制定滚动策略 --&gt;</span><br><span class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">      &lt;fileNamePattern&gt;$&#123;user.dir&#125;/logs/$&#123;DIR_NAME&#125;/springframework.%d&#123;yyyy-MM-dd&#125;.log</span><br><span class="line">      &lt;/fileNamePattern&gt;</span><br><span class="line">      &lt;maxHistory&gt;30&lt;/maxHistory&gt;</span><br><span class="line">    &lt;/rollingPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 根据文件大小来制定滚动策略 --&gt;</span><br><span class="line">    &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;</span><br><span class="line">      &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span><br><span class="line">    &lt;/triggeringPolicy&gt;</span><br><span class="line"></span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">      &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] [%-5p] %c&#123;36&#125;.%M - %m%n&lt;/pattern&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line">  &lt;!-- RollingFileAppender end --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- logger begin --&gt;</span><br><span class="line">  &lt;!-- 本项目的日志记录，分级打印 --&gt;</span><br><span class="line">  &lt;logger name=&quot;org.zp.notes.spring&quot; level=&quot;TRACE&quot; additivity=&quot;false&quot;&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;ERROR&quot;/&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;WARN&quot;/&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;INFO&quot;/&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;DEBUG&quot;/&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;TRACE&quot;/&gt;</span><br><span class="line">  &lt;/logger&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- SPRING框架日志 --&gt;</span><br><span class="line">  &lt;logger name=&quot;org.springframework&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;SPRING&quot;/&gt;</span><br><span class="line">  &lt;/logger&gt;</span><br><span class="line"></span><br><span class="line">  &lt;root level=&quot;TRACE&quot;&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;ALL&quot;/&gt;</span><br><span class="line">  &lt;/root&gt;</span><br><span class="line">  &lt;!-- logger end --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p><strong>log4j 配置</strong><br>完整的 log4j.xml 参考示例</p>
<p>log4j 的配置文件一般有 xml 格式或 properties 格式。这里为了和 logback.xml 做个对比，就不介绍 properties 了，其实也没太大差别。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;log4j:configuration xmlns:log4j=&apos;http://jakarta.apache.org/log4j/&apos;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;</span><br><span class="line">    &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">      &lt;param name=&quot;ConversionPattern&quot;</span><br><span class="line">             value=&quot;%d&#123;yyyy-MM-dd HH:mm:ss,SSS\&#125; [%-5p] [%t] %c&#123;36\&#125;.%M - %m%n&quot;/&gt;</span><br><span class="line">    &lt;/layout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--过滤器设置输出的级别--&gt;</span><br><span class="line">    &lt;filter class=&quot;org.apache.log4j.varia.LevelRangeFilter&quot;&gt;</span><br><span class="line">      &lt;param name=&quot;levelMin&quot; value=&quot;debug&quot;/&gt;</span><br><span class="line">      &lt;param name=&quot;levelMax&quot; value=&quot;fatal&quot;/&gt;</span><br><span class="line">      &lt;param name=&quot;AcceptOnMatch&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;appender name=&quot;ALL&quot; class=&quot;org.apache.log4j.DailyRollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;param name=&quot;File&quot; value=&quot;$&#123;user.dir&#125;/logs/spring-common/jcl/all&quot;/&gt;</span><br><span class="line">    &lt;param name=&quot;Append&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;!-- 每天重新生成日志文件 --&gt;</span><br><span class="line">    &lt;param name=&quot;DatePattern&quot; value=&quot;&apos;-&apos;yyyy-MM-dd&apos;.log&apos;&quot;/&gt;</span><br><span class="line">    &lt;!-- 每小时重新生成日志文件 --&gt;</span><br><span class="line">    &lt;!--&lt;param name=&quot;DatePattern&quot; value=&quot;&apos;-&apos;yyyy-MM-dd-HH&apos;.log&apos;&quot;/&gt;--&gt;</span><br><span class="line">    &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">      &lt;param name=&quot;ConversionPattern&quot;</span><br><span class="line">             value=&quot;%d&#123;yyyy-MM-dd HH:mm:ss,SSS\&#125; [%-5p] [%t] %c&#123;36\&#125;.%M - %m%n&quot;/&gt;</span><br><span class="line">    &lt;/layout&gt;</span><br><span class="line">  &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 指定logger的设置，additivity指示是否遵循缺省的继承机制--&gt;</span><br><span class="line">  &lt;logger name=&quot;org.zp.notes.spring&quot; additivity=&quot;false&quot;&gt;</span><br><span class="line">    &lt;level value=&quot;error&quot;/&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;ALL&quot;/&gt;</span><br><span class="line">  &lt;/logger&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 根logger的设置--&gt;</span><br><span class="line">  &lt;root&gt;</span><br><span class="line">    &lt;level value=&quot;warn&quot;/&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">  &lt;/root&gt;</span><br><span class="line">&lt;/log4j:configuration&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol>
<li><a href="https://juejin.im/post/5e0e8f8b6fb9a048217a165a" target="_blank" rel="noopener">https://juejin.im/post/5e0e8f8b6fb9a048217a165a</a></li>
<li><a href="https://www.cnblogs.com/rjzheng/p/10042911.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/10042911.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter源码学习一</title>
    <url>/2020/01/04/jmeter%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
    <content><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>最近在搞jmeter版本升级的事情，此前仅仅对jmeter的使用有大致的了解，并没有完全熟悉jmeter的源码。趁着这次升级的计划，打算细致的看下jmeter源码。</p>
<h4 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h4><p>使用的是jmeter5.0版本的代码，项目目录如下<br><img src="/2020/01/04/jmeter源码学习一/jmeter1.png" alt="avatar"><br>源码目录如下<br><img src="/2020/01/04/jmeter源码学习一/jmeter2.png" alt="avatar"><br>运行机制如下<br><img src="/2020/01/04/jmeter源码学习一/jmeter3.png" alt="avatar"><br>HashTree 是 JMeter 执行测试依赖的数据结构，在执行测试之前进行配置测试数据，HashTree将数据组织到一个递归树结构中，并提供了操作该结构的方法<br>StandardJMeterEngine 执行JMeter 测试 ,直接用于本地 GUI 和非 GUI 调用，或者在服务器模式下运行时由 RemoteJMeterEngineImpl 启动<br>JMeterEngine 接口被运行 JMeter的测试类实现，此接口共8个方法，JMeterEngine本质就是一个线程。</p>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><ol>
<li><p>NewDriver类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main方法</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        if(!EXCEPTIONS_IN_INIT.isEmpty()) &#123;</span><br><span class="line">            System.err.println(&quot;Configuration error during init, see exceptions:&quot;+exceptionsToString(EXCEPTIONS_IN_INIT));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line"></span><br><span class="line">            setLoggingProperties(args);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Class&lt;?&gt; initialClass = loader.loadClass(&quot;org.apache.jmeter.JMeter&quot;);// $NON-NLS-1$</span><br><span class="line">                Object instance = initialClass.newInstance();</span><br><span class="line">                Method startup = initialClass.getMethod(&quot;start&quot;, new Class[] &#123; new String[0].getClass() &#125;);// $NON-NLS-1$</span><br><span class="line">                startup.invoke(instance, new Object[] &#123; args &#125;);</span><br><span class="line">            &#125; catch(Throwable e)&#123; // NOSONAR We want to log home directory in case of exception</span><br><span class="line">                e.printStackTrace(); // NOSONAR No logger at this step</span><br><span class="line">                System.err.println(&quot;JMeter home directory was detected as: &quot;+JMETER_INSTALLATION_DIRECTORY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Jmeter类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. start方法</span><br><span class="line"> public void start(String[] args) &#123;</span><br><span class="line">        CLArgsParser parser = new CLArgsParser(args, options);</span><br><span class="line">        String error = parser.getErrorString();</span><br><span class="line">        if (error == null)&#123;// Check option combinations</span><br><span class="line">            boolean gui = parser.getArgumentById(NONGUI_OPT)==null;</span><br><span class="line">            boolean nonGuiOnly = parser.getArgumentById(REMOTE_OPT)!=null</span><br><span class="line">                               || parser.getArgumentById(REMOTE_OPT_PARAM)!=null</span><br><span class="line">                               || parser.getArgumentById(REMOTE_STOP)!=null;</span><br><span class="line">            if (gui &amp;&amp; nonGuiOnly) &#123;</span><br><span class="line">                error = &quot;-r and -R and -X are only valid in non-GUI mode&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (null != error) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + error);//NOSONAR</span><br><span class="line">            System.out.println(&quot;Usage&quot;);//NOSONAR</span><br><span class="line">            System.out.println(CLUtil.describeOptions(options).toString());//NOSONAR</span><br><span class="line">            // repeat the error so no need to scroll back past the usage to see it</span><br><span class="line">            System.out.println(&quot;Error: &quot; + error);//NOSONAR</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            initializeProperties(parser); // Also initialises JMeter logging</span><br><span class="line"></span><br><span class="line">            Thread.setDefaultUncaughtExceptionHandler(</span><br><span class="line">                    (Thread t, Throwable e) -&gt; &#123;</span><br><span class="line">                    if (!(e instanceof ThreadDeath)) &#123;</span><br><span class="line">                        log.error(&quot;Uncaught exception: &quot;, e);</span><br><span class="line">                        System.err.println(&quot;Uncaught Exception &quot; + e + &quot;. See log file for details.&quot;);//NOSONAR</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            if (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(JMeterUtils.getJMeterCopyright());</span><br><span class="line">                log.info(&quot;Version &#123;&#125;&quot;, JMeterUtils.getJMeterVersion());</span><br><span class="line">                log.info(&quot;java.version=&#123;&#125;&quot;, System.getProperty(&quot;java.version&quot;));//$NON-NLS-1$ //$NON-NLS-2$</span><br><span class="line">                log.info(&quot;java.vm.name=&#123;&#125;&quot;, System.getProperty(&quot;java.vm.name&quot;));//$NON-NLS-1$ //$NON-NLS-2$</span><br><span class="line">                log.info(&quot;os.name=&#123;&#125;&quot;, System.getProperty(&quot;os.name&quot;));//$NON-NLS-1$ //$NON-NLS-2$</span><br><span class="line">                log.info(&quot;os.arch=&#123;&#125;&quot;, System.getProperty(&quot;os.arch&quot;));//$NON-NLS-1$ //$NON-NLS-2$</span><br><span class="line">                log.info(&quot;os.version=&#123;&#125;&quot;, System.getProperty(&quot;os.version&quot;));//$NON-NLS-1$ //$NON-NLS-2$</span><br><span class="line">                log.info(&quot;file.encoding=&#123;&#125;&quot;, System.getProperty(&quot;file.encoding&quot;));//$NON-NLS-1$ //$NON-NLS-2$</span><br><span class="line">                log.info(&quot;Max memory     =&#123;&#125;&quot;, Runtime.getRuntime().maxMemory());</span><br><span class="line">                log.info(&quot;Available Processors =&#123;&#125;&quot;, Runtime.getRuntime().availableProcessors());</span><br><span class="line">                log.info(&quot;Default Locale=&#123;&#125;&quot;, Locale.getDefault().getDisplayName());</span><br><span class="line">                log.info(&quot;JMeter  Locale=&#123;&#125;&quot;, JMeterUtils.getLocale().getDisplayName());</span><br><span class="line">                log.info(&quot;JMeterHome=&#123;&#125;&quot;, JMeterUtils.getJMeterHome());</span><br><span class="line">                log.info(&quot;user.dir  =&#123;&#125;&quot;, System.getProperty(&quot;user.dir&quot;));//$NON-NLS-1$ //$NON-NLS-2$</span><br><span class="line">                log.info(&quot;PWD       =&#123;&#125;&quot;, new File(&quot;.&quot;).getCanonicalPath());//$NON-NLS-1$</span><br><span class="line">                log.info(&quot;IP: &#123;&#125; Name: &#123;&#125; FullName: &#123;&#125;&quot;, JMeterUtils.getLocalHostIP(), JMeterUtils.getLocalHostName(),</span><br><span class="line">                        JMeterUtils.getLocalHostFullName());</span><br><span class="line">            &#125;</span><br><span class="line">            setProxy(parser);</span><br><span class="line"></span><br><span class="line">            updateClassLoader();</span><br><span class="line">            if (log.isDebugEnabled())</span><br><span class="line">            &#123;</span><br><span class="line">                String jcp=System.getProperty(&quot;java.class.path&quot;);// $NON-NLS-1$</span><br><span class="line">                String[] bits = jcp.split(File.pathSeparator);</span><br><span class="line">                log.debug(&quot;ClassPath&quot;);</span><br><span class="line">                for(String bit : bits)&#123;</span><br><span class="line">                    log.debug(bit);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Set some (hopefully!) useful properties</span><br><span class="line">            long now=System.currentTimeMillis();</span><br><span class="line">            JMeterUtils.setProperty(&quot;START.MS&quot;,Long.toString(now));// $NON-NLS-1$</span><br><span class="line">            Date today=new Date(now); // so it agrees with above</span><br><span class="line">            JMeterUtils.setProperty(&quot;START.YMD&quot;,new SimpleDateFormat(&quot;yyyyMMdd&quot;).format(today));// $NON-NLS-1$ $NON-NLS-2$</span><br><span class="line">            JMeterUtils.setProperty(&quot;START.HMS&quot;,new SimpleDateFormat(&quot;HHmmss&quot;).format(today));// $NON-NLS-1$ $NON-NLS-2$</span><br><span class="line"></span><br><span class="line">            if (parser.getArgumentById(VERSION_OPT) != null) &#123;</span><br><span class="line">                displayAsciiArt();</span><br><span class="line">            &#125; else if (parser.getArgumentById(HELP_OPT) != null) &#123;</span><br><span class="line">                displayAsciiArt();</span><br><span class="line">                System.out.println(JMeterUtils.getResourceFileAsText(&quot;org/apache/jmeter/help.txt&quot;));//NOSONAR $NON-NLS-1$</span><br><span class="line">            &#125; else if (parser.getArgumentById(OPTIONS_OPT) != null) &#123;</span><br><span class="line">                displayAsciiArt();</span><br><span class="line">                System.out.println(CLUtil.describeOptions(options).toString());//NOSONAR</span><br><span class="line">            &#125; else if (parser.getArgumentById(SERVER_OPT) != null) &#123;</span><br><span class="line">                // Start the server</span><br><span class="line">                try &#123;</span><br><span class="line">                    RemoteJMeterEngineImpl.startServer(RmiUtils.getRmiRegistryPort()); // $NON-NLS-1$</span><br><span class="line">                    startOptionalServers();</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                    System.err.println(&quot;Server failed to start: &quot;+ex);//NOSONAR</span><br><span class="line">                    log.error(&quot;Giving up, as server failed with:&quot;, ex);</span><br><span class="line">                    throw ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                String testFile=null;</span><br><span class="line">                CLOption testFileOpt = parser.getArgumentById(TESTFILE_OPT);</span><br><span class="line">                if (testFileOpt != null)&#123;</span><br><span class="line">                    testFile = testFileOpt.getArgument();</span><br><span class="line">                    if (USE_LAST_JMX.equals(testFile)) &#123;</span><br><span class="line">                        testFile = LoadRecentProject.getRecentFile(0);// most recent</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                CLOption testReportOpt = parser.getArgumentById(REPORT_GENERATING_OPT);</span><br><span class="line">                if (testReportOpt != null) &#123; // generate report from existing file</span><br><span class="line">                    String reportFile = testReportOpt.getArgument();</span><br><span class="line">                    extractAndSetReportOutputFolder(parser, false);</span><br><span class="line">                    ReportGenerator generator = new ReportGenerator(reportFile, null);</span><br><span class="line">                    generator.generate();</span><br><span class="line">                &#125; else if (parser.getArgumentById(NONGUI_OPT) == null) &#123; // not non-GUI =&gt; GUI</span><br><span class="line">                    startGui(testFile);</span><br><span class="line">                    startOptionalServers();</span><br><span class="line">                &#125; else &#123; // NON-GUI must be true</span><br><span class="line">                    extractAndSetReportOutputFolder(parser, deleteResultFile);</span><br><span class="line">                    </span><br><span class="line">                    CLOption rem = parser.getArgumentById(REMOTE_OPT_PARAM);</span><br><span class="line">                    if (rem == null) &#123;</span><br><span class="line">                        rem = parser.getArgumentById(REMOTE_OPT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    CLOption jtl = parser.getArgumentById(LOGFILE_OPT);</span><br><span class="line">                    String jtlFile = null;</span><br><span class="line">                    if (jtl != null) &#123;</span><br><span class="line">                        jtlFile = processLAST(jtl.getArgument(), &quot;.jtl&quot;); // $NON-NLS-1$</span><br><span class="line">                    &#125;</span><br><span class="line">                    CLOption reportAtEndOpt = parser.getArgumentById(REPORT_AT_END_OPT);</span><br><span class="line">                    if(reportAtEndOpt != null &amp;&amp; jtlFile == null) &#123;</span><br><span class="line">                        throw new IllegalUserActionException(</span><br><span class="line">                                &quot;Option -&quot;+ ((char)REPORT_AT_END_OPT)+&quot; requires -&quot;+((char)LOGFILE_OPT )+ &quot; option&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    startNonGui(testFile, jtlFile, rem, reportAtEndOpt != null);</span><br><span class="line">                    startOptionalServers();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IllegalUserActionException e) &#123;// NOSONAR</span><br><span class="line">            System.out.println(&quot;Incorrect Usage:&quot;+e.getMessage());//NOSONAR</span><br><span class="line">            System.out.println(CLUtil.describeOptions(options).toString());//NOSONAR</span><br><span class="line">        &#125; catch (Throwable e) &#123; // NOSONAR</span><br><span class="line">            log.error(&quot;An error occurred: &quot;, e);</span><br><span class="line">            System.out.println(&quot;An error occurred: &quot; + e.getMessage());//NOSONAR</span><br><span class="line">            // FIXME Should we exit here ? If we are called by Maven or Jenkins</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. startGui方法</span><br><span class="line">private void startGui(String testFile) &#123;</span><br><span class="line">        System.out.println(&quot;================================================================================&quot;);//NOSONAR</span><br><span class="line">        System.out.println(&quot;Don&apos;t use GUI mode for load testing !, only for Test creation and Test debugging.&quot;);//NOSONAR</span><br><span class="line">        System.out.println(&quot;For load testing, use NON GUI Mode:&quot;);//NOSONAR</span><br><span class="line">        System.out.println(&quot;   jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]&quot;);//NOSONAR</span><br><span class="line">        System.out.println(&quot;&amp; increase Java Heap to meet your test requirements:&quot;);//NOSONAR</span><br><span class="line">        System.out.println(&quot;   Modify current env variable HEAP=\&quot;-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m\&quot; in the jmeter batch file&quot;);//NOSONAR</span><br><span class="line">        System.out.println(&quot;Check : https://jmeter.apache.org/usermanual/best-practices.html&quot;);//NOSONAR</span><br><span class="line">        System.out.println(&quot;================================================================================&quot;);//NOSONAR</span><br><span class="line">        </span><br><span class="line">        SplashScreen splash = new SplashScreen();</span><br><span class="line">        splash.showScreen();</span><br><span class="line">        String jMeterLaf = LookAndFeelCommand.getJMeterLaf();</span><br><span class="line">        try &#123;</span><br><span class="line">            log.info(&quot;Setting LAF to: &#123;&#125;&quot;, jMeterLaf);</span><br><span class="line">            UIManager.setLookAndFeel(jMeterLaf);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            log.warn(&quot;Could not set LAF to: &#123;&#125;&quot;, jMeterLaf, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        splash.setProgress(10);</span><br><span class="line">        JMeterUtils.applyHiDPIOnFonts();</span><br><span class="line">        PluginManager.install(this, true);</span><br><span class="line"></span><br><span class="line">        JMeterTreeModel treeModel = new JMeterTreeModel();</span><br><span class="line">        splash.setProgress(30);</span><br><span class="line">        JMeterTreeListener treeLis = new JMeterTreeListener(treeModel);</span><br><span class="line">        final ActionRouter instance = ActionRouter.getInstance();</span><br><span class="line">        instance.populateCommandMap();</span><br><span class="line">        splash.setProgress(60);</span><br><span class="line">        treeLis.setActionHandler(instance);</span><br><span class="line">        GuiPackage.initInstance(treeLis, treeModel);</span><br><span class="line">        splash.setProgress(80);</span><br><span class="line">        MainFrame main = new MainFrame(treeModel, treeLis);</span><br><span class="line">        splash.setProgress(100);</span><br><span class="line">        ComponentUtil.centerComponentInWindow(main, 80);</span><br><span class="line">        main.setLocationRelativeTo(splash);</span><br><span class="line">        main.setVisible(true);</span><br><span class="line">        main.toFront();</span><br><span class="line">        instance.actionPerformed(new ActionEvent(main, 1, ActionNames.ADD_ALL));</span><br><span class="line">        if (testFile != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                File f = new File(testFile);</span><br><span class="line">                log.info(&quot;Loading file: &#123;&#125;&quot;, f);</span><br><span class="line">                FileServer.getFileServer().setBaseForScript(f);</span><br><span class="line"></span><br><span class="line">                HashTree tree = SaveService.loadTree(f);</span><br><span class="line"></span><br><span class="line">                GuiPackage.getInstance().setTestPlanFile(f.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">                Load.insertLoadedTree(1, tree);</span><br><span class="line">            &#125; catch (ConversionException e) &#123;</span><br><span class="line">                log.error(&quot;Failure loading test file&quot;, e);</span><br><span class="line">                JMeterUtils.reportErrorToUser(SaveService.CEtoString(e));</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.error(&quot;Failure loading test file&quot;, e);</span><br><span class="line">                JMeterUtils.reportErrorToUser(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            JTree jTree = GuiPackage.getInstance().getMainFrame().getTree();</span><br><span class="line">            TreePath path = jTree.getPathForRow(0);</span><br><span class="line">            jTree.setSelectionPath(path);</span><br><span class="line">            FocusRequester.requestFocus(jTree);</span><br><span class="line">        &#125;</span><br><span class="line">        splash.setProgress(100);</span><br><span class="line">        splash.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. startNoGui方法</span><br><span class="line">private void startNonGui(String testFile, String logFile, CLOption remoteStart, boolean generateReportDashboard)</span><br><span class="line">            throws IllegalUserActionException, ConfigurationException &#123;</span><br><span class="line">        // add a system property so samplers can check to see if JMeter</span><br><span class="line">        // is running in NonGui mode</span><br><span class="line">        System.setProperty(JMETER_NON_GUI, &quot;true&quot;);// $NON-NLS-1$</span><br><span class="line">        JMeter driver = new JMeter();// TODO - why does it create a new instance?</span><br><span class="line">        driver.remoteProps = this.remoteProps;</span><br><span class="line">        driver.remoteStop = this.remoteStop;</span><br><span class="line">        driver.deleteResultFile = this.deleteResultFile;</span><br><span class="line">        </span><br><span class="line">        PluginManager.install(this, false);</span><br><span class="line"></span><br><span class="line">        String remoteHostsString = null;</span><br><span class="line">        if (remoteStart != null) &#123;</span><br><span class="line">            remoteHostsString = remoteStart.getArgument();</span><br><span class="line">            if (remoteHostsString == null) &#123;</span><br><span class="line">                remoteHostsString = JMeterUtils.getPropDefault(</span><br><span class="line">                        &quot;remote_hosts&quot;, //$NON-NLS-1$</span><br><span class="line">                        &quot;127.0.0.1&quot;);//NOSONAR $NON-NLS-1$ </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (testFile == null) &#123;</span><br><span class="line">            throw new IllegalUserActionException(&quot;Non-GUI runs require a test plan&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        driver.runNonGui(testFile, logFile, remoteStart != null, remoteHostsString, generateReportDashboard);</span><br><span class="line">    &#125;</span><br><span class="line">    // run test in batch mode</span><br><span class="line">    private void runNonGui(String testFile, String logFile, boolean remoteStart, String remoteHostsString, boolean generateReportDashboard) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            File f = new File(testFile);</span><br><span class="line">            if (!f.exists() || !f.isFile()) &#123;</span><br><span class="line">                println(&quot;Could not open &quot; + testFile);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            FileServer.getFileServer().setBaseForScript(f);</span><br><span class="line"></span><br><span class="line">            HashTree tree = SaveService.loadTree(f);</span><br><span class="line"></span><br><span class="line">            @SuppressWarnings(&quot;deprecation&quot;) // Deliberate use of deprecated ctor</span><br><span class="line">            JMeterTreeModel treeModel = new JMeterTreeModel(new Object());// Create non-GUI version to avoid headless problems</span><br><span class="line">            JMeterTreeNode root = (JMeterTreeNode) treeModel.getRoot();</span><br><span class="line">            treeModel.addSubTree(tree, root);</span><br><span class="line"></span><br><span class="line">            // Hack to resolve ModuleControllers in non GUI mode</span><br><span class="line">            SearchByClass&lt;ReplaceableController&gt; replaceableControllers =</span><br><span class="line">                    new SearchByClass&lt;&gt;(ReplaceableController.class);</span><br><span class="line">            tree.traverse(replaceableControllers);</span><br><span class="line">            Collection&lt;ReplaceableController&gt; replaceableControllersRes = replaceableControllers.getSearchResults();</span><br><span class="line">            for (ReplaceableController replaceableController : replaceableControllersRes) &#123;</span><br><span class="line">                replaceableController.resolveReplacementSubTree(root);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Remove the disabled items</span><br><span class="line">            // For GUI runs this is done in Start.java</span><br><span class="line">            convertSubTree(tree);</span><br><span class="line">            </span><br><span class="line">            Summariser summariser = null;</span><br><span class="line">            String summariserName = JMeterUtils.getPropDefault(&quot;summariser.name&quot;, &quot;&quot;);//$NON-NLS-1$</span><br><span class="line">            if (summariserName.length() &gt; 0) &#123;</span><br><span class="line">                log.info(&quot;Creating summariser &lt;&#123;&#125;&gt;&quot;, summariserName);</span><br><span class="line">                println(&quot;Creating summariser &lt;&quot; + summariserName + &quot;&gt;&quot;);</span><br><span class="line">                summariser = new Summariser(summariserName);</span><br><span class="line">            &#125;</span><br><span class="line">            ResultCollector resultCollector = null;</span><br><span class="line">            if (logFile != null) &#123;</span><br><span class="line">                resultCollector = new ResultCollector(summariser);</span><br><span class="line">                resultCollector.setFilename(logFile);</span><br><span class="line">                tree.add(tree.getArray()[0], resultCollector);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // only add Summariser if it can not be shared with the ResultCollector</span><br><span class="line">                if (summariser != null) &#123;</span><br><span class="line">                    tree.add(tree.getArray()[0], summariser);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (deleteResultFile) &#123;</span><br><span class="line">                SearchByClass&lt;ResultCollector&gt; resultListeners = new SearchByClass&lt;&gt;(ResultCollector.class);</span><br><span class="line">                tree.traverse(resultListeners);</span><br><span class="line">                Iterator&lt;ResultCollector&gt; irc = resultListeners.getSearchResults().iterator();</span><br><span class="line">                while (irc.hasNext()) &#123;</span><br><span class="line">                    ResultCollector rc = irc.next();</span><br><span class="line">                    File resultFile = new File(rc.getFilename());</span><br><span class="line">                    if (resultFile.exists() &amp;&amp; !resultFile.delete()) &#123;</span><br><span class="line">                        throw new IllegalStateException(&quot;Could not delete results file &quot; + resultFile.getAbsolutePath()</span><br><span class="line">                            + &quot;(canRead:&quot;+resultFile.canRead()+&quot;, canWrite:&quot;+resultFile.canWrite()+&quot;)&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ReportGenerator reportGenerator = null;</span><br><span class="line">            if (logFile != null &amp;&amp; generateReportDashboard) &#123;</span><br><span class="line">                reportGenerator = new ReportGenerator(logFile, resultCollector);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Used for remote notification of threads start/stop,see BUG 54152</span><br><span class="line">            // Summariser uses this feature to compute correctly number of threads </span><br><span class="line">            // when NON GUI mode is used</span><br><span class="line">            tree.add(tree.getArray()[0], new RemoteThreadsListenerTestElement());</span><br><span class="line"></span><br><span class="line">            List&lt;JMeterEngine&gt; engines = new LinkedList&lt;&gt;();</span><br><span class="line">            tree.add(tree.getArray()[0], new ListenToTest(remoteStart &amp;&amp; remoteStop ? engines : null, reportGenerator));</span><br><span class="line">            println(&quot;Created the tree successfully using &quot;+testFile);</span><br><span class="line">            if (!remoteStart) &#123;</span><br><span class="line">                JMeterEngine engine = new StandardJMeterEngine();</span><br><span class="line">                engine.configure(tree);</span><br><span class="line">                long now=System.currentTimeMillis();</span><br><span class="line">                println(&quot;Starting the test @ &quot;+new Date(now)+&quot; (&quot;+now+&quot;)&quot;);</span><br><span class="line">                engine.runTest();</span><br><span class="line">                engines.add(engine);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                java.util.StringTokenizer st = new java.util.StringTokenizer(remoteHostsString, &quot;,&quot;);//$NON-NLS-1$</span><br><span class="line">                List&lt;String&gt; hosts = new LinkedList&lt;&gt;();</span><br><span class="line">                while (st.hasMoreElements()) &#123;</span><br><span class="line">                    hosts.add((String) st.nextElement());</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                DistributedRunner distributedRunner=new DistributedRunner(this.remoteProps);</span><br><span class="line">                distributedRunner.setStdout(System.out); // NOSONAR</span><br><span class="line">                distributedRunner.setStdErr(System.err); // NOSONAR</span><br><span class="line">                distributedRunner.init(hosts, tree);</span><br><span class="line">                engines.addAll(distributedRunner.getEngines());</span><br><span class="line">                distributedRunner.start();</span><br><span class="line">            &#125;</span><br><span class="line">            startUdpDdaemon(engines);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Error in NonGUIDriver &quot; + e.toString());//NOSONAR</span><br><span class="line">            log.error(&quot;Error in NonGUIDriver&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">1. 解析命令行参数，加载配置文件；</span><br><span class="line">2. 将 .Jmx 文件解析成 HashTree；</span><br><span class="line">3. 实例化一个StandardJMeterEngine,并把测试的工作交给JMeterEngine；</span><br><span class="line">4. 监听所有的 JMeterEngine ,当接收到 GUI 的 StopTestNow / Shutdown 等命令时候来调用JMeterEngine接口相应的方法。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>JMeterEngine接口<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface JMeterEngine &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Configure engine</span><br><span class="line">     * @param testPlan the test plan</span><br><span class="line">     */</span><br><span class="line">    void configure(HashTree testPlan);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Runs the test</span><br><span class="line">     * @throws JMeterEngineException if an error occurs</span><br><span class="line">     */</span><br><span class="line">    void runTest() throws JMeterEngineException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Stop test immediately interrupting current samplers</span><br><span class="line">     */</span><br><span class="line">    default void stopTest() &#123;</span><br><span class="line">        stopTest(true);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param now boolean that tell wether stop is immediate (interrupt) or not (wait for current sample end)</span><br><span class="line">     */</span><br><span class="line">    void stopTest(boolean now);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Stop test if running</span><br><span class="line">     */</span><br><span class="line">    void reset();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * set Properties on engine</span><br><span class="line">     * @param p the properties to set</span><br><span class="line">     */</span><br><span class="line">    void setProperties(Properties p);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Exit engine</span><br><span class="line">     */</span><br><span class="line">    void exit();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @return boolean Flag to show whether engine is active (true when test is running). Set to false at end of test</span><br><span class="line">     */</span><br><span class="line">    boolean isActive();</span><br><span class="line">&#125;</span><br><span class="line">JMeterEngine 依赖于 HashTree，而 HashTree 是由 jmx 文件解析而来,每一个 JMeter 测试计划都会对应一个 jmx 文件。所以我们只要生成合理的 jmx 文件，就可以通过 JMeterEngine 压测引擎去执行测试任务。</span><br><span class="line"></span><br><span class="line">具体 jmx 文件的生成方式，我们可以借鉴JMeter GUI模式下 jmx 文件生成方式。在这里我们的演示的处理方式是，先定义每个组件的生成方式，然后再按一定结构组装各个组件，示意代码如下。</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter源码学习四(StandardJMeterEngine)</title>
    <url>/2020/02/29/jmeter%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%9B%9B/</url>
    <content><![CDATA[<h4 id="StandardJMeterEngine源码"><a href="#StandardJMeterEngine源码" class="headerlink" title="StandardJMeterEngine源码"></a>StandardJMeterEngine源码</h4><p>JMeter 默认单机压测引擎，运行 JMeter 测试，直接用于本地 GUI 和非 GUI 调用，或者RemoteJMeterEngineImpl 在服务器模式下运行时启动。其逻辑关系如下：<br><img src="/2020/02/29/jmeter源码学习四/jmeter1.png" alt="avatar"><br>简要解读：</p>
<ul>
<li>HashTree是依赖的数据结构；</li>
<li>SearchByClass 用来查找 HashTree 中的所有节点，并把节点实例化为真正的对象，例如图中TestPlan/ThreadGroup/JavaSampler/ResultCollector 在 HashTree 中本来都是只是配置，全部通过 SearchByClass 实例化的；</li>
<li>实例化出来的对象如果是 TestStateListener 类型，则会在有生命周期的函数回调，测试前调 testStarted,结束掉 testEnded, 比如 ResultCollector是该类型的一种，在结束的时候回调 testEnded 方法完成 report 的写入；</li>
<li>PreCompiler 用来解析 Arguments, 把 TestPlan 节点中配置的参数作为JMeterVariables 加入到测试线程上线文中；</li>
<li>ThreadGroup 用来用来管理一组线程，包括线程的个数/启动/关闭等；</li>
<li>StopTest 作为其内部类对外不可见，作为一个 Runnable，作用是异步停止测试，stopTest方法也是通过该内部类实现的。</li>
</ul>
<h4 id="JMeterEngine-接口"><a href="#JMeterEngine-接口" class="headerlink" title="JMeterEngine 接口"></a>JMeterEngine 接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This interface is implemented by classes that can run JMeter tests.</span><br><span class="line"> */</span><br><span class="line">public interface JMeterEngine &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Configure engine</span><br><span class="line">     * @param testPlan the test plan</span><br><span class="line">     */</span><br><span class="line">    void configure(HashTree testPlan);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Runs the test</span><br><span class="line">     * @throws JMeterEngineException if an error occurs</span><br><span class="line">     */</span><br><span class="line">    void runTest() throws JMeterEngineException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Stop test immediately interrupting current samplers</span><br><span class="line">     */</span><br><span class="line">    default void stopTest() &#123;</span><br><span class="line">        stopTest(true);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param now boolean that tell wether stop is immediate (interrupt) or not (wait for current sample end)</span><br><span class="line">     */</span><br><span class="line">    void stopTest(boolean now);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Stop test if running</span><br><span class="line">     */</span><br><span class="line">    void reset();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * set Properties on engine</span><br><span class="line">     * @param p the properties to set</span><br><span class="line">     */</span><br><span class="line">    void setProperties(Properties p);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Exit engine</span><br><span class="line">     */</span><br><span class="line">    void exit();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @return boolean Flag to show whether engine is active (true when test is running). Set to false at end of test</span><br><span class="line">     */</span><br><span class="line">    boolean isActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StandardJmeterEngine类"><a href="#StandardJmeterEngine类" class="headerlink" title="StandardJmeterEngine类"></a>StandardJmeterEngine类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StandardJMeterEngine implements JMeterEngine, Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(StandardJMeterEngine.class);</span><br><span class="line"></span><br><span class="line">    // Should we exit at end of the test? (only applies to server, because host is non-null)</span><br><span class="line">    private static final boolean EXIT_AFTER_TEST =</span><br><span class="line">        JMeterUtils.getPropDefault(&quot;server.exitaftertest&quot;, false);  // $NON-NLS-1$</span><br><span class="line"></span><br><span class="line">    // Allow engine and threads to be stopped from outside a thread</span><br><span class="line">    // e.g. from beanshell server</span><br><span class="line">    // Assumes that there is only one instance of the engine</span><br><span class="line">    // at any one time so it is not guaranteed to work ...</span><br><span class="line">    // 灵魂级变量,注意关键字volatile</span><br><span class="line">    private static volatile StandardJMeterEngine engine;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Allow functions etc to register for testStopped notification.</span><br><span class="line">     * Only used by the function parser so far.</span><br><span class="line">     * The list is merged with the testListeners and then cleared.</span><br><span class="line">     */</span><br><span class="line">    private static final List&lt;TestStateListener&gt; testList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /** Whether to call System.exit(0) in exit after stopping RMI */</span><br><span class="line">    private static final boolean REMOTE_SYSTEM_EXIT = JMeterUtils.getPropDefault(&quot;jmeterengine.remote.system.exit&quot;, false);</span><br><span class="line"></span><br><span class="line">    /** Whether to call System.exit(1) if threads won&apos;t stop */</span><br><span class="line">    private static final boolean SYSTEM_EXIT_ON_STOP_FAIL = JMeterUtils.getPropDefault(&quot;jmeterengine.stopfail.system.exit&quot;, true);</span><br><span class="line">    </span><br><span class="line">    /** Whether to call System.exit(0) unconditionally at end of non-GUI test */</span><br><span class="line">    private static final boolean SYSTEM_EXIT_FORCED = JMeterUtils.getPropDefault(&quot;jmeterengine.force.system.exit&quot;, false);</span><br><span class="line"></span><br><span class="line">    /** Flag to show whether test is running. Set to false to stop creating more threads. */</span><br><span class="line">    private volatile boolean running = false;</span><br><span class="line"></span><br><span class="line">    /** Flag to show whether engine is active. Set to false at end of test. */</span><br><span class="line">    private volatile boolean active = false;</span><br><span class="line"></span><br><span class="line">    /** Thread Groups run sequentially */</span><br><span class="line">    private volatile boolean serialized = false;</span><br><span class="line"></span><br><span class="line">    /** tearDown Thread Groups run after shutdown of main threads */</span><br><span class="line">    private volatile boolean tearDownOnShutdown = false;</span><br><span class="line"></span><br><span class="line">    private HashTree test;</span><br><span class="line"></span><br><span class="line">    private final String host;</span><br><span class="line"></span><br><span class="line">    // The list of current thread groups; may be setUp, main, or tearDown.</span><br><span class="line">    private final List&lt;AbstractThreadGroup&gt; groups = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public StandardJMeterEngine() &#123;</span><br><span class="line">        this(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public StandardJMeterEngine(String host) &#123;</span><br><span class="line">        this.host = host;</span><br><span class="line">        // Hack to allow external control</span><br><span class="line">        initSingletonEngine(this);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Set the shared engine</span><br><span class="line">     * @param standardJMeterEngine </span><br><span class="line">     */</span><br><span class="line">    private static void initSingletonEngine(StandardJMeterEngine standardJMeterEngine) &#123;</span><br><span class="line">        StandardJMeterEngine.engine = standardJMeterEngine; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * set the shared engine to null</span><br><span class="line">     */</span><br><span class="line">    private static void resetSingletonEngine() &#123;</span><br><span class="line">        StandardJMeterEngine.engine = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void stopEngineNow() &#123;</span><br><span class="line">        if (engine != null) &#123;// May be null if called from Unit test</span><br><span class="line">            engine.stopTest(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void stopEngine() &#123;</span><br><span class="line">        if (engine != null) &#123; // May be null if called from Unit test</span><br><span class="line">            engine.stopTest(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void register(TestStateListener tl) &#123;</span><br><span class="line">        testList.add(tl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean stopThread(String threadName) &#123;</span><br><span class="line">        return stopThread(threadName, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean stopThreadNow(String threadName) &#123;</span><br><span class="line">        return stopThread(threadName, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean stopThread(String threadName, boolean now) &#123;</span><br><span class="line">        if (engine == null) &#123;</span><br><span class="line">            return false;// e.g. not yet started</span><br><span class="line">        &#125;</span><br><span class="line">        boolean wasStopped = false;</span><br><span class="line">        // ConcurrentHashMap does not need synch. here</span><br><span class="line">        for (AbstractThreadGroup threadGroup : engine.groups) &#123;</span><br><span class="line">            wasStopped = wasStopped || threadGroup.stopThread(threadName, now);</span><br><span class="line">        &#125;</span><br><span class="line">        return wasStopped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // End of code to allow engine to be controlled remotely</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HashTree testTree) &#123;</span><br><span class="line">        // Is testplan serialised?</span><br><span class="line">        SearchByClass&lt;TestPlan&gt; testPlan = new SearchByClass&lt;&gt;(TestPlan.class);</span><br><span class="line">        testTree.traverse(testPlan);</span><br><span class="line">        Object[] plan = testPlan.getSearchResults().toArray();</span><br><span class="line">        if (plan.length == 0) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Could not find the TestPlan class!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        TestPlan tp = (TestPlan) plan[0];</span><br><span class="line">        serialized = tp.isSerialized();</span><br><span class="line">        tearDownOnShutdown = tp.isTearDownOnShutdown();</span><br><span class="line">        active = true;</span><br><span class="line">        test = testTree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void runTest() throws JMeterEngineException &#123;</span><br><span class="line">        if (host != null)&#123;</span><br><span class="line">            long now=System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;Starting the test on host &quot; + host + &quot; @ &quot;+new Date(now)+&quot; (&quot;+now+&quot;)&quot;); // NOSONAR Intentional</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread runningThread = new Thread(this, &quot;StandardJMeterEngine&quot;);</span><br><span class="line">            runningThread.start();</span><br><span class="line">        &#125; catch (Exception err) &#123;</span><br><span class="line">            stopTest();</span><br><span class="line">            throw new JMeterEngineException(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void removeThreadGroups(List&lt;?&gt; elements) &#123;</span><br><span class="line">        Iterator&lt;?&gt; iter = elements.iterator();</span><br><span class="line">        while (iter.hasNext()) &#123; // Can&apos;t use for loop here because we remove elements</span><br><span class="line">            Object item = iter.next();</span><br><span class="line">            if (item instanceof AbstractThreadGroup) &#123;</span><br><span class="line">                iter.remove();</span><br><span class="line">            &#125; else if (!(item instanceof TestElement)) &#123;</span><br><span class="line">                iter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void notifyTestListenersOfStart(SearchByClass&lt;TestStateListener&gt; testListeners) &#123;</span><br><span class="line">        for (TestStateListener tl : testListeners.getSearchResults()) &#123;</span><br><span class="line">            if (tl instanceof TestBean) &#123;</span><br><span class="line">                TestBeanHelper.prepare((TestElement) tl);</span><br><span class="line">            &#125;</span><br><span class="line">            if (host == null) &#123;</span><br><span class="line">                tl.testStarted();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tl.testStarted(host);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void notifyTestListenersOfEnd(SearchByClass&lt;TestStateListener&gt; testListeners) &#123;</span><br><span class="line">        log.info(&quot;Notifying test listeners of end of test&quot;);</span><br><span class="line">        for (TestStateListener tl : testListeners.getSearchResults()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (host == null) &#123;</span><br><span class="line">                    tl.testEnded();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    tl.testEnded(host);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.warn(&quot;Error encountered during shutdown of &quot;+tl.toString(),e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (host != null) &#123;</span><br><span class="line">            log.info(&quot;Test has ended on host &#123;&#125; &quot;, host);</span><br><span class="line">            long now=System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;Finished the test on host &quot; + host + &quot; @ &quot;+new Date(now)+&quot; (&quot;+now+&quot;)&quot; // NOSONAR Intentional</span><br><span class="line">                    +(EXIT_AFTER_TEST ? &quot; - exit requested.&quot; : &quot;&quot;));</span><br><span class="line">            if (EXIT_AFTER_TEST)&#123;</span><br><span class="line">                exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        active=false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void reset() &#123;</span><br><span class="line">        if (running) &#123;</span><br><span class="line">            stopTest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Stop Test Now</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void stopTest() &#123;</span><br><span class="line">        stopTest(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void stopTest(boolean now) &#123;</span><br><span class="line">        Thread stopThread = new Thread(new StopTest(now));</span><br><span class="line">        stopThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class StopTest implements Runnable &#123;</span><br><span class="line">        private final boolean now;</span><br><span class="line"></span><br><span class="line">        private StopTest(boolean b) &#123;</span><br><span class="line">            now = b;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * For each current thread group, invoke:</span><br><span class="line">         * &lt;ul&gt; </span><br><span class="line">         * &lt;li&gt;&#123;@link AbstractThreadGroup#stop()&#125; - set stop flag&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt; </span><br><span class="line">         */</span><br><span class="line">        private void stopAllThreadGroups() &#123;</span><br><span class="line">            // ConcurrentHashMap does not need synch. here</span><br><span class="line">            for (AbstractThreadGroup threadGroup : groups) &#123;</span><br><span class="line">                threadGroup.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * For each thread group, invoke &#123;@link AbstractThreadGroup#tellThreadsToStop()&#125;</span><br><span class="line">         */</span><br><span class="line">        private void tellThreadGroupsToStop() &#123;</span><br><span class="line">            // ConcurrentHashMap does not need protecting</span><br><span class="line">            for (AbstractThreadGroup threadGroup : groups) &#123;</span><br><span class="line">                threadGroup.tellThreadsToStop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * @return boolean true if all threads of all Thread Groups stopped</span><br><span class="line">         */</span><br><span class="line">        private boolean verifyThreadsStopped() &#123;</span><br><span class="line">            boolean stoppedAll = true;</span><br><span class="line">            // ConcurrentHashMap does not need synch. here</span><br><span class="line">            for (AbstractThreadGroup threadGroup : groups) &#123;</span><br><span class="line">                stoppedAll = stoppedAll &amp;&amp; threadGroup.verifyThreadsStopped();</span><br><span class="line">            &#125;</span><br><span class="line">            return stoppedAll;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @return total of active threads in all Thread Groups</span><br><span class="line">         */</span><br><span class="line">        private int countStillActiveThreads() &#123;</span><br><span class="line">            int reminingThreads= 0;</span><br><span class="line">            for (AbstractThreadGroup threadGroup : groups) &#123;</span><br><span class="line">                reminingThreads += threadGroup.numberOfActiveThreads();</span><br><span class="line">            &#125;            </span><br><span class="line">            return reminingThreads; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            running = false;</span><br><span class="line">            resetSingletonEngine();</span><br><span class="line">            if (now) &#123;</span><br><span class="line">                tellThreadGroupsToStop();</span><br><span class="line">                pause(10L * countStillActiveThreads());</span><br><span class="line">                boolean stopped = verifyThreadsStopped();</span><br><span class="line">                if (!stopped) &#123;  // we totally failed to stop the test</span><br><span class="line">                    if (JMeter.isNonGUI()) &#123;</span><br><span class="line">                        // TODO should we call test listeners? That might hang too ...</span><br><span class="line">                        log.error(JMeterUtils.getResString(&quot;stopping_test_failed&quot;)); //$NON-NLS-1$</span><br><span class="line">                        if (SYSTEM_EXIT_ON_STOP_FAIL) &#123; // default is true</span><br><span class="line">                            log.error(&quot;Exiting&quot;);</span><br><span class="line">                            System.out.println(&quot;Fatal error, could not stop test, exiting&quot;); // NOSONAR Intentional</span><br><span class="line">                            System.exit(1); // NOSONAR Intentional</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            System.out.println(&quot;Fatal error, could not stop test&quot;); // NOSONAR Intentional                            </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        JMeterUtils.reportErrorToUser(</span><br><span class="line">                                JMeterUtils.getResString(&quot;stopping_test_failed&quot;), //$NON-NLS-1$</span><br><span class="line">                                JMeterUtils.getResString(&quot;stopping_test_title&quot;)); //$NON-NLS-1$</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; // else will be done by threadFinished()</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stopAllThreadGroups();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        log.info(&quot;Running the test!&quot;);</span><br><span class="line">        running = true;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Ensure that the sample variables are correctly initialised for each run.</span><br><span class="line">         */</span><br><span class="line">        SampleEvent.initSampleVariables();</span><br><span class="line"></span><br><span class="line">        JMeterContextService.startTest();</span><br><span class="line">        try &#123;</span><br><span class="line">            PreCompiler compiler = new PreCompiler();</span><br><span class="line">            test.traverse(compiler);</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            log.error(&quot;Error occurred compiling the tree:&quot;,e);</span><br><span class="line">            JMeterUtils.reportErrorToUser(&quot;Error occurred compiling the tree: - see log file&quot;, e);</span><br><span class="line">            return; // no point continuing</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * Notification of test listeners needs to happen after function</span><br><span class="line">         * replacement, but before setting RunningVersion to true.</span><br><span class="line">         */</span><br><span class="line">        SearchByClass&lt;TestStateListener&gt; testListeners = new SearchByClass&lt;&gt;(TestStateListener.class); // TL - S&amp;E</span><br><span class="line">        test.traverse(testListeners);</span><br><span class="line"></span><br><span class="line">        // Merge in any additional test listeners</span><br><span class="line">        // currently only used by the function parser</span><br><span class="line">        testListeners.getSearchResults().addAll(testList);</span><br><span class="line">        testList.clear(); // no longer needed</span><br><span class="line"></span><br><span class="line">        test.traverse(new TurnElementsOn());</span><br><span class="line">        notifyTestListenersOfStart(testListeners);</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; testLevelElements = new LinkedList&lt;&gt;(test.list(test.getArray()[0]));</span><br><span class="line">        removeThreadGroups(testLevelElements);</span><br><span class="line"></span><br><span class="line">        SearchByClass&lt;SetupThreadGroup&gt; setupSearcher = new SearchByClass&lt;&gt;(SetupThreadGroup.class);</span><br><span class="line">        SearchByClass&lt;AbstractThreadGroup&gt; searcher = new SearchByClass&lt;&gt;(AbstractThreadGroup.class);</span><br><span class="line">        SearchByClass&lt;PostThreadGroup&gt; postSearcher = new SearchByClass&lt;&gt;(PostThreadGroup.class);</span><br><span class="line"></span><br><span class="line">        test.traverse(setupSearcher);</span><br><span class="line">        test.traverse(searcher);</span><br><span class="line">        test.traverse(postSearcher);</span><br><span class="line">        </span><br><span class="line">        TestCompiler.initialize();</span><br><span class="line">        // for each thread group, generate threads</span><br><span class="line">        // hand each thread the sampler controller</span><br><span class="line">        // and the listeners, and the timer</span><br><span class="line">        Iterator&lt;SetupThreadGroup&gt; setupIter = setupSearcher.getSearchResults().iterator();</span><br><span class="line">        Iterator&lt;AbstractThreadGroup&gt; iter = searcher.getSearchResults().iterator();</span><br><span class="line">        Iterator&lt;PostThreadGroup&gt; postIter = postSearcher.getSearchResults().iterator();</span><br><span class="line"></span><br><span class="line">        ListenerNotifier notifier = new ListenerNotifier();</span><br><span class="line"></span><br><span class="line">        int groupCount = 0;</span><br><span class="line">        JMeterContextService.clearTotalThreads();</span><br><span class="line">        </span><br><span class="line">        if (setupIter.hasNext()) &#123;</span><br><span class="line">            log.info(&quot;Starting setUp thread groups&quot;);</span><br><span class="line">            while (running &amp;&amp; setupIter.hasNext()) &#123;//for each setup thread group</span><br><span class="line">                AbstractThreadGroup group = setupIter.next();</span><br><span class="line">                groupCount++;</span><br><span class="line">                String groupName = group.getName();</span><br><span class="line">                log.info(&quot;Starting setUp ThreadGroup: &#123;&#125; : &#123;&#125; &quot;, groupCount, groupName);</span><br><span class="line">                startThreadGroup(group, groupCount, setupSearcher, testLevelElements, notifier);</span><br><span class="line">                if (serialized &amp;&amp; setupIter.hasNext()) &#123;</span><br><span class="line">                    log.info(&quot;Waiting for setup thread group: &#123;&#125; to finish before starting next setup group&quot;, </span><br><span class="line">                            groupName);</span><br><span class="line">                    group.waitThreadsStopped();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">            log.info(&quot;Waiting for all setup thread groups to exit&quot;);</span><br><span class="line">            //wait for all Setup Threads To Exit</span><br><span class="line">            waitThreadsStopped();</span><br><span class="line">            log.info(&quot;All Setup Threads have ended&quot;);</span><br><span class="line">            groupCount=0;</span><br><span class="line">            JMeterContextService.clearTotalThreads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        groups.clear(); // The groups have all completed now                </span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Here&apos;s where the test really starts. Run a Full GC now: it&apos;s no harm</span><br><span class="line">         * at all (just delays test start by a tiny amount) and hitting one too</span><br><span class="line">         * early in the test can impair results for short tests.</span><br><span class="line">         */</span><br><span class="line">        JMeterUtils.helpGC();</span><br><span class="line">        </span><br><span class="line">        JMeterContextService.getContext().setSamplingStarted(true);</span><br><span class="line">        boolean mainGroups = running; // still running at this point, i.e. setUp was not cancelled</span><br><span class="line">        while (running &amp;&amp; iter.hasNext()) &#123;// for each thread group</span><br><span class="line">            AbstractThreadGroup group = iter.next();</span><br><span class="line">            //ignore Setup and Post here.  We could have filtered the searcher. but then</span><br><span class="line">            //future Thread Group objects wouldn&apos;t execute.</span><br><span class="line">            if (group instanceof SetupThreadGroup ||</span><br><span class="line">                    group instanceof PostThreadGroup) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            groupCount++;</span><br><span class="line">            String groupName = group.getName();</span><br><span class="line">            log.info(&quot;Starting ThreadGroup: &#123;&#125; : &#123;&#125;&quot;, groupCount, groupName);</span><br><span class="line">            startThreadGroup(group, groupCount, searcher, testLevelElements, notifier);</span><br><span class="line">            if (serialized &amp;&amp; iter.hasNext()) &#123;</span><br><span class="line">                log.info(&quot;Waiting for thread group: &#123;&#125; to finish before starting next group&quot;, groupName);</span><br><span class="line">                group.waitThreadsStopped();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; // end of thread groups</span><br><span class="line">        if (groupCount == 0)&#123; // No TGs found</span><br><span class="line">            log.info(&quot;No enabled thread groups found&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (running) &#123;</span><br><span class="line">                log.info(&quot;All thread groups have been started&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                log.info(&quot;Test stopped - no more thread groups will be started&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //wait for all Test Threads To Exit</span><br><span class="line">        waitThreadsStopped();</span><br><span class="line">        groups.clear(); // The groups have all completed now            </span><br><span class="line"></span><br><span class="line">        if (postIter.hasNext())&#123;</span><br><span class="line">            groupCount = 0;</span><br><span class="line">            JMeterContextService.clearTotalThreads();</span><br><span class="line">            log.info(&quot;Starting tearDown thread groups&quot;);</span><br><span class="line">            if (mainGroups &amp;&amp; !running) &#123; // i.e. shutdown/stopped during main thread groups</span><br><span class="line">                running = tearDownOnShutdown; // re-enable for tearDown if necessary</span><br><span class="line">            &#125;</span><br><span class="line">            while (running &amp;&amp; postIter.hasNext()) &#123;//for each setup thread group</span><br><span class="line">                AbstractThreadGroup group = postIter.next();</span><br><span class="line">                groupCount++;</span><br><span class="line">                String groupName = group.getName();</span><br><span class="line">                log.info(&quot;Starting tearDown ThreadGroup: &#123;&#125; : &#123;&#125;&quot;, groupCount, groupName);</span><br><span class="line">                startThreadGroup(group, groupCount, postSearcher, testLevelElements, notifier);</span><br><span class="line">                if (serialized &amp;&amp; postIter.hasNext()) &#123;</span><br><span class="line">                    log.info(&quot;Waiting for post thread group: &#123;&#125; to finish before starting next post group&quot;, groupName);</span><br><span class="line">                    group.waitThreadsStopped();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            waitThreadsStopped(); // wait for Post threads to stop</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        notifyTestListenersOfEnd(testListeners);</span><br><span class="line">        JMeterContextService.endTest();</span><br><span class="line">        if (JMeter.isNonGUI() &amp;&amp; SYSTEM_EXIT_FORCED) &#123;</span><br><span class="line">            log.info(&quot;Forced JVM shutdown requested at end of test&quot;);</span><br><span class="line">            System.exit(0); // NOSONAR Intentional</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void startThreadGroup(AbstractThreadGroup group, int groupCount, SearchByClass&lt;?&gt; searcher, List&lt;?&gt; testLevelElements, ListenerNotifier notifier)</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int numThreads = group.getNumThreads();</span><br><span class="line">            JMeterContextService.addTotalThreads(numThreads);</span><br><span class="line">            boolean onErrorStopTest = group.getOnErrorStopTest();</span><br><span class="line">            boolean onErrorStopTestNow = group.getOnErrorStopTestNow();</span><br><span class="line">            boolean onErrorStopThread = group.getOnErrorStopThread();</span><br><span class="line">            boolean onErrorStartNextLoop = group.getOnErrorStartNextLoop();</span><br><span class="line">            String groupName = group.getName();</span><br><span class="line">            log.info(&quot;Starting &#123;&#125; threads for group &#123;&#125;.&quot;, numThreads, groupName);</span><br><span class="line">            if (onErrorStopTest) &#123;</span><br><span class="line">                log.info(&quot;Test will stop on error&quot;);</span><br><span class="line">            &#125; else if (onErrorStopTestNow) &#123;</span><br><span class="line">                log.info(&quot;Test will stop abruptly on error&quot;);</span><br><span class="line">            &#125; else if (onErrorStopThread) &#123;</span><br><span class="line">                log.info(&quot;Thread will stop on error&quot;);</span><br><span class="line">            &#125; else if (onErrorStartNextLoop) &#123;</span><br><span class="line">                log.info(&quot;Thread will start next loop on error&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                log.info(&quot;Thread will continue on error&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            ListedHashTree threadGroupTree = (ListedHashTree) searcher.getSubTree(group);</span><br><span class="line">            threadGroupTree.add(group, testLevelElements);</span><br><span class="line">    </span><br><span class="line">            groups.add(group);</span><br><span class="line">            group.start(groupCount, notifier, threadGroupTree, this);</span><br><span class="line">        &#125; catch (JMeterStopTestException ex) &#123; // NOSONAR Reported by log</span><br><span class="line">            JMeterUtils.reportErrorToUser(&quot;Error occurred starting thread group :&quot; + group.getName()+ &quot;, error message:&quot;+ex.getMessage()</span><br><span class="line">                +&quot;, \r\nsee log file for more details&quot;, ex);</span><br><span class="line">            return; // no point continuing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Wait for Group Threads to stop</span><br><span class="line">     */</span><br><span class="line">    private void waitThreadsStopped() &#123;</span><br><span class="line">        // ConcurrentHashMap does not need synch. here</span><br><span class="line">        for (AbstractThreadGroup threadGroup : groups) &#123;</span><br><span class="line">            threadGroup.waitThreadsStopped();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Clean shutdown ie, wait for end of current running samplers</span><br><span class="line">     */</span><br><span class="line">    public void askThreadsToStop() &#123;</span><br><span class="line">        if (engine != null) &#123; // Will be null if StopTest thread has started</span><br><span class="line">            engine.stopTest(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * Remote exit</span><br><span class="line">     * Called by RemoteJMeterEngineImpl.rexit()</span><br><span class="line">     * and by notifyTestListenersOfEnd() iff exitAfterTest is true;</span><br><span class="line">     * in turn that is called by the run() method and the StopTest class</span><br><span class="line">     * also called</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void exit() &#123;</span><br><span class="line">        ClientJMeterEngine.tidyRMI(log); // This should be enough to allow server to exit.</span><br><span class="line">        if (REMOTE_SYSTEM_EXIT) &#123; // default is false</span><br><span class="line">            log.warn(&quot;About to run System.exit(0) on &#123;&#125;&quot;, host);</span><br><span class="line">            // Needs to be run in a separate thread to allow RMI call to return OK</span><br><span class="line">            Thread t = new Thread() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    pause(1000); // Allow RMI to complete</span><br><span class="line">                    log.info(&quot;Bye from &#123;&#125;&quot;, host);</span><br><span class="line">                    System.out.println(&quot;Bye from &quot;+host); // NOSONAR Intentional</span><br><span class="line">                    System.exit(0); // NOSONAR Intentional</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void pause(long ms)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(ms);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties p) &#123;</span><br><span class="line">        log.info(&quot;Applying properties &#123;&#125;&quot;, p);</span><br><span class="line">        JMeterUtils.getJMeterProperties().putAll(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean isActive() &#123;</span><br><span class="line">        return active;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RemoteJMeterEngine-接口"><a href="#RemoteJMeterEngine-接口" class="headerlink" title="RemoteJMeterEngine 接口"></a>RemoteJMeterEngine 接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RemoteJMeterEngine extends Remote &#123;</span><br><span class="line">    void rconfigure(HashTree testTree, String host, File jmxBase, String scriptName) throws RemoteException;</span><br><span class="line"></span><br><span class="line">    void rrunTest() throws RemoteException, JMeterEngineException;</span><br><span class="line"></span><br><span class="line">    void rstopTest(boolean now) throws RemoteException;</span><br><span class="line"></span><br><span class="line">    void rreset() throws RemoteException;</span><br><span class="line"></span><br><span class="line">    void rsetProperties(Properties p) throws RemoteException;</span><br><span class="line"></span><br><span class="line">    void rexit() throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm小结</title>
    <url>/2021/06/19/jvm%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h4 id="jvm整体架构"><a href="#jvm整体架构" class="headerlink" title="jvm整体架构"></a>jvm整体架构</h4><p>JVM(虚拟机)：指以软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的完整计算机系统 ，是物理机的软件实现。jvm的整体架构如下<br><img src="/2021/06/19/jvm小结/jvm1.png" alt="avatar"></p>
<p>详细的jvm整体架构如下<br><img src="/2021/06/19/jvm小结/jvm6.png" alt="avatar"></p>
<p>在一个java进程中可能有很多正在运行的java线程，那么在每一个java线程中都会独立开辟本地方法栈，程序计算器，和Java栈的，而方法区和堆并不是独立开辟的，他们之间是可以共享的。</p>
<p><strong>内存结构每个组成模块的具体概念</strong></p>
<p>本地方法栈(线程私有)：登记native方法，在Execution Engine执行时加载本地方法库</p>
<p>程序计数器（线程私有）：就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p>
<p>方法区(线程共享)：类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p>
<p>Java栈（线程私有）： Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致</p>
<p>JVM对该区域规范了两种异常：</p>
<p>1) 线程请求的栈深度大于虚拟机栈所允许的深度，将抛出StackOverFlowError异常</p>
<p>2) 若虚拟机栈可动态扩展，当无法申请到足够内存空间时将抛出OutOfMemoryError，通过jvm参数–Xss指定栈空间，空间大小决定函数调用的深度</p>
<p>堆(线程共享)：虚拟机启动时创建，用于存放对象实例，几乎所有的对象（包含常量池）都在堆上分配内存，当对象无法再该空间申请到内存时将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。可通过 -Xmx –Xms 参数来分别指定最大堆和最小堆</p>
<p><strong>栈+堆+方法区的交互关系</strong></p>
<p>HotSpot是使用指针的方式来访问对象，Java堆中会存放访问类元数据的地址，reference存储的就直接是对象的地址<br><img src="/2021/06/19/jvm小结/jvm2.png" alt="avatar"></p>
<p>•堆(线程共享)：虚拟机启动时创建，用于存放对象实例，几乎所有的对象（包含常量池）都在堆上分配内存，当对象无法再该空间申请到内存时将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。可通过 -Xmx –Xms 参数来分别指定最大堆和最小堆<br><img src="/2021/06/19/jvm小结/jvm3.png" alt="avatar"></p>
<p>新生区</p>
<p>类诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。</p>
<p>新生区分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的类都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。若幸存 0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？</p>
<p>老年区</p>
<p>新生区经过多次GC仍然存活的对象移动到老年区。若老年区也满了，那么这个时候将产生MajorGC（FullGC），进行老年区的内存清理。若老年区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”</p>
<p>元数据区：元数据区取代了永久代(jdk1.8以前)，本质和永久代类似，都是对JVM规范中方法区的实现，区别在于元数据区并不在虚拟机中，而是使用本地物理内存，永久代在虚拟机中，永久代逻辑结构上属于堆，但是物理上不属于堆，堆大小=新生代+老年代。元数据区也有可能发生OutOfMemory异常。</p>
<p>Jdk1.6及之前： 有永久代, 常量池在方法区</p>
<p>Jdk1.7：       有永久代，但已经逐步“去永久代”，常量池在堆</p>
<p>Jdk1.8及之后： 无永久代，常量池在元空间</p>
<p>元数据区的动态扩展，默认–XX:MetaspaceSize值为21MB的高水位线。一旦触及则Full GC将被触发并卸载没有用的类（类对应的类加载器不再存活），然后高水位线将会重置。新的高水位线的值取决于GC后释放的元空间。如果释放的空间少，这个高水位线则上升。如果释放空间过多，则高水位线下降。</p>
<p>为什么jdk1.8用元数据区取代了永久代？</p>
<p>官方解释：移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代</p>
<p><strong>执行引擎</strong><br>读取运行时数据区的Java字节码并逐个执行<br><img src="/2021/06/19/jvm小结/jvm4.png" alt="avatar"></p>
<p>JIT：在Java编程语言和环境中，即时编译器（JIT compiler，just-in-time compiler）是一个把Java的字节码（包括需要被解释的指令的程序）转换成可以直接发送给处理器的指令的程序。</p>
<p><img src="/2021/06/19/jvm小结/jvm5.png" alt="avatar"></p>
<h4 id="jvm生命周期"><a href="#jvm生命周期" class="headerlink" title="jvm生命周期"></a>jvm生命周期</h4><p>Java虚拟机的生命周期 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。程序开始执行时他才运行，程序结束时他就停止。你在同一台机器上运行三个程序，就会有三个运行中的Java虚拟机。 Java虚拟机总是开始于一个main()方法，这个方法必须是公有、返回void、直接受一个字符串数组。在程序执行时，你必须给Java虚拟机指明这个包换main()方法的类名。 Main()方法是程序的起点，他被执行的线程初始化为程序的初始线程。程序中其他的线程都由他来启动。Java中的线程分为两种：守护线程（daemon）和普通线程（non-daemon）。守护线程是Java虚拟机自己使用的线程，比如负责垃圾收集GC的线程就是一个守护线程。当然，你也可 以把自己的程序用setDeamon设置为守护线程。包含Main()方法的初始线程不是守护线程。 只要Java虚拟机中还有普通的线程在执行，Java虚拟机就不会停止。如果有足够的权限，你可以调用exit()方法终止程序。</p>
<h4 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h4><p><strong>类加载子系统的作用</strong></p>
<ol>
<li>类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识；</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定</li>
<li>加载的类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li>
</ol>
<p><strong>类加载子系统的概览图</strong></p>
<p><img src="/2021/06/19/jvm小结/jvm7.png" alt="avatar"></p>
<p>类加载器子系统负责从文件系统或网络中加载class文件，class文件在文件头具有特定的文件标识。</p>
<p>Classloader只负责class文件的加载，至于他是否可以运行，则由Execution Engine决定。</p>
<p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量。</p>
<p>类加载子系统主要包括三个环节：</p>
<ul>
<li>loading</li>
<li>linking：verify，prepare，resolve</li>
<li>initialization</li>
</ul>
<p>1.Loading（加载）环节</p>
<ul>
<li>通过一个类的全限定明获取定义此类的二进制字节流；</li>
<li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据；</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p>2.Linking（链接）环节</p>
<p>Verify(验证)</p>
<ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li>
<li>主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证。</li>
</ul>
<p>Prepare(准备)环节</p>
<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值；</li>
<li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</li>
<li>不会为实例变量分配初始化，类变量会分配在方法去中，而实例变量是会随着对象一起分配到java堆中。</li>
</ul>
<p>Resolve(解析)</p>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程。</li>
<li>事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行。</li>
<li>符号引用就是一组符号来描述所引用的目标。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info/CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li>
</ul>
<p>3.Initialization（初始化）环节</p>
<ul>
<li>初始化阶段就是执行类构造器方法clinit（）的过程。</li>
<li>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li>
<li>构造器方法中指令按语句在源文件中的出现的顺序执行。</li>
<li>Clinit不同于类的构造器（构造器是虚拟机视角下的init（））</li>
<li>若该类有父类，jvm会保证子类的clinit（）执行前，父类的clinit（）已经执行完毕</li>
<li>虚拟机必须保证一个类的clinit（）在多线程下被同步加载。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 示例1 </span><br><span class="line">public class ClassInitTest &#123;</span><br><span class="line"></span><br><span class="line">    private static int num1=1;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        num1=2;</span><br><span class="line">        num2=20;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int num2=10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 示例2</span><br><span class="line">public class ClassInitTest2 &#123;</span><br><span class="line"></span><br><span class="line">    static class Father &#123;</span><br><span class="line"></span><br><span class="line">        public static int num = 1;</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            num = 5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Son extends Father &#123;</span><br><span class="line"></span><br><span class="line">        private static int numSon = num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Son.numSon);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 示例3</span><br><span class="line">public class ClassTest3 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Runnable r = ()-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;开始&quot;);</span><br><span class="line">            ThreadInit threadInit = new ThreadInit();</span><br><span class="line">            System.out.println(&quot;结束&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(r);</span><br><span class="line">        Thread t2 = new Thread(r);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class ThreadInit &#123;</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            if(true)&#123;</span><br><span class="line">                System.out.println(&quot;加载当前类&quot;+Thread.currentThread().getName());</span><br><span class="line">                while (true)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul>
<li>VM支持两种类型的加载器，分别为引导类加载器（BootStrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</li>
<li>对于用户自定义类来说：使用系统类加载器AppClassLoader进行加载，java核心类库都是使用引导类加载器BootStrapClassLoader加载的。</li>
</ul>
<p><strong>启动类加载器（引导类加载器，BootStrap ClassLoader）</strong></p>
<ul>
<li>这个类加载使用C/C++语言实现的，嵌套在JVM内部</li>
<li>它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar/resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承自java.lang.ClassLoader,没有父加载器</li>
<li>加载拓展类和应用程序类加载器，并指定为他们的父加载器</li>
<li><p>处于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
<p><strong>拓展类加载器（Extension ClassLoader）</strong></p>
</li>
<li><p>java语言编写 ，由sun.misc.Launcher$ExtClassLoader实现。</p>
</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会由拓展类加载器自动加载</li>
</ul>
<p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p>
<ul>
<li>java语言编写， 由sun.misc.Launcher$AppClassLoader实现。</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为拓展类加载器</li>
<li>它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库</li>
<li>该类加载器是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载</li>
<li>通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器</li>
</ul>
<p><strong>用户自定义类加载器</strong></p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>拓展加载源</li>
<li>防止源码泄漏</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private final String path;</span><br><span class="line"></span><br><span class="line">    public CustomLoader(String path) &#123;</span><br><span class="line">        super(null);</span><br><span class="line">        this.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        byte[] data = new byte[0];</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            data = readBytes(name);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return defineClass(name, data, 0, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] readBytes(String name) throws IOException &#123;</span><br><span class="line">        name = name.replaceAll(&quot;\\.&quot;, &quot;\\\\&quot;);</span><br><span class="line">        String classFilePath = path + name + &quot;.class&quot;;</span><br><span class="line">        File classFile = new File(classFilePath);</span><br><span class="line">        InputStream fis = null;</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream bos = null;</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line"></span><br><span class="line">        byte[] readBytes = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            bos = new ByteArrayOutputStream();</span><br><span class="line">            fis = new FileInputStream(classFile);</span><br><span class="line">            int length;</span><br><span class="line">            while ((length = fis.read(bytes)) != -1) &#123;</span><br><span class="line">                bos.write(bytes, 0, length);</span><br><span class="line">            &#125;</span><br><span class="line">            readBytes = bos.toByteArray();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (fis != null) &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (bos != null) &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return readBytes;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ClassLoader的常用方法及获取方法</strong></p>
<p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）<br><img src="/2021/06/19/jvm小结/loader1.png" alt="avatar"><br>获取ClassLoader的途径:<br><img src="/2021/06/19/jvm小结/loader2.png" alt="avatar"></p>
<p><strong>双亲委派机制</strong></p>
<p>ava虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将她的class文件加载到内存生成的class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲微拍模式，即把请求交由父类处理，它是一种任务委派模式</p>
<p><img src="/2021/06/19/jvm小结/loader3.png" alt="avatar"></p>
<p>双亲委派机制的优势：</p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改</li>
</ul>
<p><strong>沙箱安全机制</strong></p>
<p>自定义String类，但是在加载自定义String类的时候回率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中的java\lang\String.class）,报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>
<p>注意：</p>
<p>在jvm中表示两个class对象是否为同一个类存在的两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。换句话说，在jvm中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的.</li>
<li>JVM必须知道一个类型是有启动类加载器加载的还是由用户类加载器加载的。如果一个类型由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的会议部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证两个类型的加载器是相同的。</li>
</ul>
<p><strong>类的主动使用和被动使用</strong></p>
<p>主动使用，分为七种情况：</p>
<ul>
<li>创建类的实例</li>
<li>访问某各类或接口的静态变量，或者对静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射 比如Class.forName(com.dsh.jvm.xxx)</li>
<li>初始化一个类的子类</li>
<li>java虚拟机启动时被标明为启动类的类</li>
<li>JDK 7 开始提供的动态语言支持：</li>
<li>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>
</ul>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://blog.csdn.net/qq_40368860/article/details/84447085" target="_blank" rel="noopener">https://blog.csdn.net/qq_40368860/article/details/84447085</a></li>
<li><a href="https://blog.csdn.net/rabbit_in_android/article/details/50382739" target="_blank" rel="noopener">https://blog.csdn.net/rabbit_in_android/article/details/50382739</a></li>
<li><a href="https://www.cnblogs.com/lwkdbk/p/12707708.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwkdbk/p/12707708.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux文件系统小结</title>
    <url>/2021/05/08/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>Linux：存在几十个文件系统类型：ext2，ext3，ext4，xfs，brtfs，zfs（man 5 fs可以取得全部文件系统的介绍）</p>
<p>不同文件系统采用不同的方法来管理磁盘空间，各有优劣；文件系统是具体到分区的，所以格式化针对的是分区，分区格式化是指采用指定的文件系统类型对分区空间进行登记、索引并建立相应的管理表格的过程。</p>
<ul>
<li>ext2具有极快的速度和极小的CPU占用率，可用于硬盘和移动存储设备</li>
<li>ext3增加日志功能，可回溯追踪</li>
<li>ext4日志式文件系统，支持1EB（1024*1024TB），最大单文件16TB，支持连续写入可减少文件碎片。rhel6默认文件系统</li>
<li>xfs可以管理500T的硬盘。rhel7默认文件系统</li>
<li>brtfs文件系统针对固态盘做优化，</li>
</ul>
<p>注：EXT（Extended file system）是延伸文件系统、扩展文件系统，ext1于1992年4月发表，是为linux核心所做的第一个文件系统。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式化命令：mkfs -t &lt;文件系统类型&gt; &lt;分区设备文件名&gt;</span><br><span class="line"></span><br><span class="line">　　　　　　mkfs.xfs /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><ul>
<li>FAT16：MS—DOS和win95采用的磁盘分区格式，采用16位的文件分配表，只支持2GB的磁盘分区，最大单文件2GB，且磁盘利用率低</li>
<li>FAT32：（即Vfat）采用32位的文件分配表，支持最大分区128GB，最大文件4GB</li>
<li>NTFS：支持最大分区2TB，最大文件2TB，安全性和稳定性非常好，不易出现文件碎片。</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>RAMFS：内存文件系统</li>
<li>ISO 9660：光盘</li>
<li>NFS：网络文件系统</li>
<li>SMBAFS/CIFS：支持Samba协议的网络文件系统</li>
<li>Linux swap：交换分区，用以提供虚拟内存。</li>
</ul>
<h3 id="磁盘分区基本概念"><a href="#磁盘分区基本概念" class="headerlink" title="磁盘分区基本概念"></a>磁盘分区基本概念</h3><p>硬盘分区的划分标准：</p>
<p>硬盘分区由主分区、扩展分区和逻辑分区组成</p>
<p>在一块硬盘上，如果是MBR分区方式，那么它的主分区最多只能有4个，或者3个主分区和1个扩展分区；在扩展分区上我们可以创建多个逻辑分区</p>
<p>分区编号：主分区1-4 ，逻辑分区5.。。。。。</p>
<p>LINUX规定：逻辑分区必须建立在扩展分区之上，而不是建立在主分区上</p>
<p>分区作用：</p>
<p>主分区：主要是用来启动操作系统的，它主要放的是操作系统的启动或引导程序，/boot分区最好放在主分区上<br>扩展分区不能使用的，它只是做为逻辑分区的容器存在的；我们真正存放数据的是主分区和逻辑分区，大量数据都放在逻辑分区中<br>如果你用的是GPT的分区方式，那么它没有限制主分区个数<br>注意：从MBR转到GPT分区或者说从GPT转到MBR会导致数据全部丢失<br>因此我们在对硬盘分区时最好划分主分区连续，比如说：主分区一、主分区二、扩展分区。</p>
<h3 id="分区命令parted的用法"><a href="#分区命令parted的用法" class="headerlink" title="分区命令parted的用法"></a>分区命令parted的用法</h3><p><strong>parted的适用场景</strong></p>
<p>创建操作大于2T的分区<br>一般情况下，我们都是选择使用fdisk工具来进行分区，但是目前在实际生产环境中使用的磁盘空间越来越大，呈TiB级别增长；而常用的fdisk这个工具对分区是有大小限制的，它只能划分小于2T的磁盘，所以在划大于2T磁盘分区的时候fdisk就无法满足要求了；这个时候有2个方法，其一是通过卷管理来实现，其二就是通过parted工具来实现对GPT磁盘进行分区操作；这里我们采用parted的方法来实现管理。</p>
<p><strong>parted的2种使用方式</strong></p>
<p>交互式</p>
<p>手动按序交互式的创建；</p>
<p>非交互式</p>
<p>可将命令行写在脚本中，运行脚本实现一键创建；适用于远程批量管理多台主机的场景。</p>
<p>两种方式比较</p>
<p>两种方法的使用和原理其实是一样的；要想实现非交互式创建，无非是在每一个具体的交互式命令前加上parted DEVICES_NAME即可。</p>
<p><strong>交互式方式实现分区步骤</strong></p>
<ol>
<li>选择操作磁盘</li>
</ol>
<p>parted命令后跟上欲操作磁盘的名字即可选择此设备进行操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@kvm ~]# parted /dev/sdb</span><br><span class="line">GNU Parted 3.1</span><br><span class="line">Using /dev/sdb</span><br><span class="line">Welcome to GNU Parted! Type &apos;help&apos; to view a list of commands.</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新建磁盘标签类型为GPT</li>
</ol>
<p>因为parted命令只能针对gpt格式的磁盘进行操作，所以这里必须将新建的磁盘标签格式设为gpt。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(parted) mklabel gpt</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>分区</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkpart PART-TYPE [FS-TYPE] START END</span><br><span class="line"></span><br><span class="line">PART-TYPE(分区类型)</span><br><span class="line"></span><br><span class="line">primary :主分区</span><br><span class="line">logical :逻辑分区</span><br><span class="line">extended :扩展分区</span><br><span class="line"></span><br><span class="line">FS-TYPE(文件系统类型)</span><br><span class="line">ext4、ext3、ext2、xfs</span><br><span class="line"></span><br><span class="line">START： 设定磁盘分区起始点；可以为0，numberMiB/GiB/TiB；</span><br><span class="line"></span><br><span class="line">0：设定当前分区的起始点为磁盘的第一个扇区；</span><br><span class="line">1G：设定当前分区的起始点为磁盘的1G处开始；</span><br><span class="line"></span><br><span class="line">END：设定磁盘分区结束点；</span><br><span class="line"></span><br><span class="line">-1：设定当前分区的结束点为磁盘的最后一个扇区；</span><br><span class="line">10G：设定当前分区的结束点为磁盘的10G处；</span><br></pre></td></tr></table></figure>
<p><strong>将/dev/sdb整个空间分给同一个分区</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(parted) mkpart primary 0 -1                                              </span><br><span class="line">Warning: The resulting partition is not properly aligned for best performance.</span><br><span class="line">Ignore/Cancel? I</span><br><span class="line">(parted) p                                                                </span><br><span class="line">Model: AVAGO AVAGO (scsi)</span><br><span class="line">Disk /dev/sdb: 18.0TB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name     Flags</span><br><span class="line"> 1      17.4kB  18.0TB  18.0TB               primary</span><br><span class="line">(parted) q                                                                </span><br><span class="line">Information: You may need to update /etc/fstab.</span><br></pre></td></tr></table></figure>
<p><strong>格式化分区</strong></p>
<p>因为整个/dev/sdb只分了一个区，则这个分区名默认会分配为/dev/sdb1；使用mkfs命令将/dev/sdb1分区格式化为ext4。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@kvm ~]# mkfs -t ext4 /dev/sdb1                 </span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">/dev/sdb1 alignment is offset by 244736 bytes.</span><br><span class="line">This may result in very poor performance, (re)-partitioning suggested.</span><br><span class="line">Filesystem label=</span><br><span class="line">OS type: Linux</span><br><span class="line">Block size=4096 (log=2)</span><br><span class="line">Fragment size=4096 (log=2)</span><br><span class="line">Stride=64 blocks, Stripe width=64 blocks</span><br><span class="line">274659328 inodes, 4394530311 blocks</span><br><span class="line">219726515 blocks (5.00%) reserved for the super user</span><br><span class="line">First data block=0</span><br><span class="line">134111 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">2048 inodes per group</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, </span><br><span class="line">        4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968, </span><br><span class="line">        102400000, 214990848, 512000000, 550731776, 644972544, 1934917632, </span><br><span class="line">        2560000000, 3855122432</span><br><span class="line"></span><br><span class="line">Allocating group tables: done</span><br><span class="line">Writing inode tables: done</span><br><span class="line">Creating journal (32768 blocks): done</span><br><span class="line">Writing superblocks and filesystem accounting information: done</span><br></pre></td></tr></table></figure>
<p><strong>设定分区label(非必要)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@kvm ~]# e2label /dev/sdb1 /gfsdata01</span><br></pre></td></tr></table></figure>
<p><strong>创建挂载目录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@kvm ~]# mkdir /gfsdata01</span><br></pre></td></tr></table></figure>
<p><strong>临时挂载分区</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@kvm ~]# mount /dev/sdb1 /gfsdata01</span><br><span class="line">[root@kvm ~]# df -h</span><br><span class="line">Filesystem                   Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/root_vg-lv_root   89G  2.6G   82G   4% /</span><br><span class="line">devtmpfs                     126G     0  126G   0% /dev</span><br><span class="line">tmpfs                        126G     0  126G   0% /dev/shm</span><br><span class="line">tmpfs                        126G  2.0M  126G   1% /run</span><br><span class="line">tmpfs                        126G     0  126G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                    976M  216M  694M  24% /boot</span><br><span class="line">/dev/sda7                     99G   61M   94G   1% /home</span><br><span class="line">/dev/sda8                     62G   53M   59G   1% /tmp</span><br><span class="line">/dev/sda6                     99G   61M   94G   1% /app</span><br><span class="line">tmpfs                         26G     0   26G   0% /run/user/1014</span><br><span class="line">tmpfs                         26G     0   26G   0% /run/user/0</span><br><span class="line">/dev/sdb1                     17T   20K   16T   1% /gfsdata01</span><br></pre></td></tr></table></figure>
<p><strong>开机自动挂载(永久挂载)</strong></p>
<p>即修改/etc/fstab文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &apos;/dev/sdb1 /gfsdata01    ext4    defaults    0 0&apos; &gt;&gt;/etc/fstab</span><br></pre></td></tr></table></figure>
<p><strong>非交互式方式实现脚本</strong></p>
<p>适用于需要在多台主机上进行同样的分区操作，可以通过ansible工具调用脚本实现批量分区配置挂载等操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@kvm ~]# cat ./auto_partition.sh </span><br><span class="line">#!/bin/bash</span><br><span class="line"># 新建/dev/sdb的磁盘标签类型为GPT</span><br><span class="line">parted /dev/sdb mklabel gpt </span><br><span class="line"># 将/dev/sdb整个空间分给同一个分区</span><br><span class="line">parted /dev/sdb mkpart primary 0 100%</span><br><span class="line"># 忽略警告</span><br><span class="line">ignore</span><br><span class="line"># 格式化分区</span><br><span class="line">mkfs -t ext4 /dev/sdb1</span><br><span class="line"># 设定分区label(非必要)</span><br><span class="line">e2label /dev/sdb1 /gfsdata01</span><br><span class="line"># 创建挂载目录</span><br><span class="line">mkdir /gfsdata01</span><br><span class="line"># 临时挂载</span><br><span class="line">mount /dev/sdb1 /gfsdata01</span><br><span class="line"># 开机自动挂载(永久挂载)</span><br><span class="line">echo &apos;/dev/sdb1 /gfsdata01       ext4    defaults        0 0&apos;&gt;&gt;/etc/fstab</span><br><span class="line">[root@kvm ~]#</span><br></pre></td></tr></table></figure>
<p><strong>删除分区(rm子命令)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(parted) p                                                                </span><br><span class="line">Model: AVAGO AVAGO (scsi)</span><br><span class="line">Disk /dev/sdb: 18.0TB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name     Flags</span><br><span class="line"> 1      17.4kB  4096GB  4096GB               primary</span><br><span class="line"></span><br><span class="line">(parted) rm 1                                                             </span><br><span class="line">(parted) p                                                                </span><br><span class="line">Model: AVAGO AVAGO (scsi)</span><br><span class="line">Disk /dev/sdb: 18.0TB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start  End  Size  File system  Name  Flags</span><br><span class="line"></span><br><span class="line">(parted)</span><br></pre></td></tr></table></figure>
<h3 id="实验文件系统"><a href="#实验文件系统" class="headerlink" title="实验文件系统"></a>实验文件系统</h3><p>有时候仅仅为了实验而插入新磁盘、扫描SCSI设备、再分区、格式化，整个过程挺麻烦的。</p>
<p>好在，有更为便捷的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=sdx bs=1M count=32</span><br><span class="line">mke2fs sdx</span><br></pre></td></tr></table></figure>
<p>现在sdx文件就是一个ext家族的文件系统了，相当于已经格式化的/dev/sdxN，它可以直接拿来挂载使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount sdx /mnt/sdx</span><br></pre></td></tr></table></figure>
<p>还可以使用mkisofs命令工具快速将目录创建成一个可挂载的镜像文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p foo/bar/baz</span><br><span class="line">mkisofs -o test.iso foo  # 将foo打包成iso镜像</span><br></pre></td></tr></table></figure>
<p>现在，test.iso镜像文件也可以直接挂载使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount test.iso /mnt/test</span><br></pre></td></tr></table></figure>
<h3 id="查看文件系统状态信息"><a href="#查看文件系统状态信息" class="headerlink" title="查看文件系统状态信息"></a>查看文件系统状态信息</h3><p><strong>lsblk</strong><br>lsblk(list block devices)用于列出设备及其状态，主要列出非空的存储设备。其实它只会列出/sys/dev/block中的主次设备号文件，且默认只列出非空设备。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@server2 ~]# lsblk /dev/sdb</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sdb      8:16   0   20G  0 disk</span><br><span class="line">├─sdb1   8:17   0  9.5G  0 part /mydata/data</span><br><span class="line">└─sdb2   8:18   0    3G  0 part</span><br><span class="line"></span><br><span class="line">[root@server2 ~]# lsblk /dev/sdb1</span><br><span class="line">NAME MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sdb1   8:17   0  9.5G  0 part /mydata/data</span><br></pre></td></tr></table></figure>
<p>其中上面的几列意义如下：</p>
<p>NAME：设备名称；</p>
<p>MAJ:MIN：主设备号和此设备号；</p>
<p>RM：是否为可卸载设备，1表示可卸载设备。可卸载设备如光盘、USB等。并非能够umount的就是可卸载的；</p>
<p>SIZE：设备总空间大小；</p>
<p>RO：是否为只读；</p>
<p>TYPE：是磁盘disk，还是分区part，亦或是rom，还有loop设备；</p>
<p>mountpoint：挂载点。</p>
<p><strong>blkid</strong><br>虽然它有不少比较强大的功能，但一般只用它一个功能，就是查看器文件系统类型和uuid。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@xuexi ~]# blkid</span><br><span class="line">/dev/sda1: UUID=&quot;77b5f0da-b0f9-4054-9902-c6cdacf29f5e&quot; TYPE=&quot;ext4&quot;</span><br><span class="line">/dev/sda2: UUID=&quot;f199fcb4-fb06-4bf5-a1b7-a15af0f7cb47&quot; TYPE=&quot;ext4&quot;</span><br><span class="line">/dev/sda3: UUID=&quot;6ae3975c-1a2a-46e3-87f3-d5bd3f1eff48&quot; TYPE=&quot;swap&quot;</span><br><span class="line">/dev/sdb1: UUID=&quot;95e5b9d5-be78-43ed-a06a-97fd1de9a3fe&quot; TYPE=&quot;ext4&quot;</span><br><span class="line">/dev/sdb2: UUID=&quot;45da2d94-190a-4548-85bb-b3c46ae6d9a7&quot; TYPE=&quot;ext2&quot;</span><br><span class="line"></span><br><span class="line">[root@xuexi ~]# blkid /dev/sdb1</span><br><span class="line">/dev/sdb1: UUID=&quot;95e5b9d5-be78-43ed-a06a-97fd1de9a3fe&quot; TYPE=&quot;ext4&quot;</span><br></pre></td></tr></table></figure>
<p><strong>parted /dev/sda print和fdisk -l</strong><br>虽然fdisk和gdisk分别是mbr和gpt格式的专用工具，但是仅用于查看信息还是可以的。parted能兼容两者，所以也可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; parted /dev/sdb p</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk /dev/sdb: 21.5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name              Flags</span><br><span class="line"> 1      1049kB  10.2GB  10.2GB  ext4</span><br><span class="line"> 2      10.2GB  13.5GB  3221MB  ext2         Linux filesystem</span><br><span class="line"></span><br><span class="line">shell&gt; fdisk -l /dev/sda</span><br><span class="line">Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x000cb657</span><br><span class="line"> </span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048      514047      256000   83  Linux</span><br><span class="line">/dev/sda2          514048    37847039    18666496   83  Linux</span><br><span class="line">/dev/sda3        37847040    41943039     2048000   82  Linux swap / Solaris</span><br></pre></td></tr></table></figure>
<p><strong>du</strong><br>u命令用于评估文件的空间占用情况，它会统计每个文件的大小，统计时会递归统计目录中的文件，也就是说，它会遍历整个待统计目录，所以统计速度上可能并不理想。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du [OPTION]... [FILE]...</span><br><span class="line">选项说明：</span><br><span class="line">-a, --all：列出目录中所有文件的统计信息，默认只会列出目录中子目录的统计信息，而不列出文件的统计信息</span><br><span class="line">-h, --human-readable：人性化显示大小</span><br><span class="line">-0, --null：以空字符结尾，即&quot;\0&quot;而非换行的&quot;\n&quot;</span><br><span class="line">-S, --separate-dirs：不包含子目录的大小</span><br><span class="line">-s, --summarize：对目录做总的统计，不列出目录内文件的大小信息</span><br><span class="line">-c,--total：对给出的文件或目录做总计。在统计非同一个目录文件大小时非常有用。见下文例子。</span><br><span class="line">-d,--max-depth：指定显示时的目录深度，默认会递归显示所有层次</span><br><span class="line">--max-depth=N：只列出给定层次的目录统计，如果N=0，则等价于&quot;-s&quot;</span><br><span class="line">-x, --one-file-system：忽略不同文件系统上的文件，不对它们进行统计</span><br><span class="line">-X, --exclude-from=FILE：从文件中读取要排除的文件</span><br><span class="line">--exclude=PATTERN：指定要忽略不统计的文件</span><br></pre></td></tr></table></figure></p>
<p><strong>df</strong></p>
<p>df用于报告磁盘空间使用率，默认显示的大小是1K大小block数量，也就是以k为单位。</p>
<p>和du不同的是，df是读取每个文件系统的superblock信息，所以评估速度非常快。由于是读取superblock，所以如果目录下挂载了另一个文件系统，是不会将此挂载的文件系统计入目录大小的。注意，du和df统计的结果是不一样的，如果对它们的结果不同有兴趣，可参考我的另一篇文章：详细分析du和df的统计结果为什么不一样。</p>
<p>如果用df统计某个文件的空间使用情况，将会转而统计该文件所在文件系统的空间使用情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df [OPTION]... [FILE]...</span><br><span class="line">选项说明：</span><br><span class="line">-h：人性化转换大小的显示单位</span><br><span class="line">-i：统计inode使用情况而非空间使用情况</span><br><span class="line">-l, --local：只列出本地文件系统的使用情况，不列出网络文件系统信息</span><br><span class="line">-T, --print-type：同时输出文件系统类型</span><br><span class="line">-t, --type=TYPE：只列出给定文件系统的统计信息</span><br><span class="line">-x, --exclude-type=TYPE：指定不显示的文件系统类型的统计信息</span><br></pre></td></tr></table></figure>
<p><strong>mount</strong></p>
<p>mount用来显示挂载信息或者进行文件系统挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount # 将显示当前已挂载信息</span><br><span class="line">mount [-t 欲挂载文件系统类型 ] [-o 特殊选项] 设备名 挂载目录</span><br><span class="line"></span><br><span class="line">选项说明：</span><br><span class="line">-a  将/etc/fstab文件里指定的挂载选项重新挂载一遍。</span><br><span class="line">-t  支持ext2/ext3/ext4/vfat/fat/iso9660(光盘默认格式)。 不用-t时默认会调用blkid来获取文件系统类型。</span><br><span class="line">-n  不把挂载记录写在/etc/mtab文件中，一般挂载会在/proc/mounts中记录下挂载信息，然后同步到/etc/mtab，指定-n表示不同步该挂载信息。</span><br><span class="line">-o  指定挂载特殊选项。下面是两个比较常用的：</span><br><span class="line">    loop  挂载镜像文件，如iso文件</span><br><span class="line">    ro  只读挂载</span><br><span class="line">    rw  读写挂载</span><br><span class="line">    auto  相当于mount -a</span><br><span class="line">    dev 如果挂载的文件系统中有设备访问入口则启用它，使其可以作为设备访问入口</span><br><span class="line">    default rw,suid,dev,exec,auto,nouser,async,and relatime</span><br><span class="line">    async   异步挂载，只写到内存</span><br><span class="line">    sync    同步挂载，通过挂载位置写入对方硬盘</span><br><span class="line">    atime   修改访问时间，每次访问都修改atime会导致性能降低，所以默认是noatime</span><br><span class="line">    noatime 不修改访问时间，高并发时使用这个选项可以减少磁盘IO</span><br><span class="line">    nodiratime  不修改文件夹访问时间，高并发时使用这个选项可以减少磁盘IO</span><br><span class="line">    exec/noexec  挂载后的文件系统里的可执行程序是否可执行，默认是可以执行exec， 优先级高于权限的限定</span><br><span class="line">    remount  重新挂载，此时可以不用指定挂载点。</span><br><span class="line">    suid/nosuid 对挂载的文件系统启用或禁用suid，对于外来设备最好禁用suid</span><br><span class="line">    _netdev 需要网络挂载时默认将停留在挂载界面直到加载网络了。使用_netdev可以忽略网络正常挂载。如NFS开机挂载。</span><br><span class="line">    user  允许普通用户进行挂载该目录，但只允许挂载者进行卸载该目录</span><br><span class="line">    users  允许所有用户挂载和卸载该目录</span><br><span class="line">    nouser  禁止普通用户挂载和卸载该目录，这是默认的，默认情况下一个目录不指定user/users时，将只有root能挂载</span><br></pre></td></tr></table></figure>
<p><strong>umount</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount 设备名或挂载目录</span><br><span class="line">umount -lf 强制卸载</span><br></pre></td></tr></table></figure>
<h3 id="LVM相关概念和机制"><a href="#LVM相关概念和机制" class="headerlink" title="LVM相关概念和机制"></a>LVM相关概念和机制</h3><p><strong>PV(Physical Volume)即物理卷</strong></p>
<p>硬盘分区后(还未格式化为文件系统)使用pvcreate命令可以将分区创建为pv，要求分区的system ID为8e，即为LVM格式的系统标识符。</p>
<p><strong>VG(Volume Group)即卷组</strong></p>
<p>将多个PV组合起来，使用vgcreate命令创建成卷组，这样卷组包含了多个PV就比较大了，相当于重新整合了多个分区后得到的磁盘。虽然VG是整合多个PV的，但是创建VG时会将VG所有的空间根据指定的PE大小划分为多个PE，在LVM模式下的存储都以PE为单元，类似于文件系统的Block。</p>
<p><strong>PE(Physical Extend)</strong></p>
<p>PE是VG中的存储单元。实际存储的数据都是存储在这里面的。</p>
<p><strong>LV(Logical Volume)</strong></p>
<p>VG相当于整合过的硬盘，那么LV就相当于分区，只不过该分区是通过VG来划分的。VG中有很多PE单元，可以指定将多少个PE划分给一个LV，也可以直接指定大小(如多少兆)来划分。划分为LV之后就相当于划分了分区，只需再对LV进行格式化即可变成普通的文件系统。</p>
<p>通俗地讲，非LVM管理的分区步骤是将硬盘分区，然后将分区格式化为文件系统。而使用LVM，则是在硬盘分区为特定的LVM标识符的分区后将其转变为LVM可管理的PV，其实PV仍然类似于分区，然后将几个PV整合为类似于磁盘的VG，最后划分VG为LV，此时LV就成了LVM可管理的分区，只需再对其格式化即可成为文件系统。</p>
<p><strong>LE(logical extent)</strong><br>PE是物理存储单元，而LE则是逻辑存储单元，也即为lv中的逻辑存储单元，和pe的大小是一样的。从vg中划分lv，实际上是从vg中划分vg中的pe，只不过划分lv后它不再称为pe，而是成为le。</p>
<h3 id="将2块磁盘总空间“合二为一”并挂载到同一目录"><a href="#将2块磁盘总空间“合二为一”并挂载到同一目录" class="headerlink" title="将2块磁盘总空间“合二为一”并挂载到同一目录"></a>将2块磁盘总空间“合二为一”并挂载到同一目录</h3><p><strong>创建物理卷</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@MYSQL-SERVER ~]#  pvcreate /dev/sdb1</span><br><span class="line">  Physical volume &quot;/dev/sdb1&quot; successfully created.</span><br><span class="line">[root@MYSQL-SERVER ~]#  pvcreate /dev/sdc1</span><br><span class="line">  Physical volume &quot;/dev/sdc1&quot; successfully created.</span><br></pre></td></tr></table></figure>
<p><strong>创建卷组</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@MYSQL-SERVER ~]#  vgcreate vgmysql /dev/sdb1</span><br><span class="line">  Volume group &quot;vgmysql&quot; successfully created</span><br></pre></td></tr></table></figure>
<p><strong>添加新的物理卷到卷组中</strong><br>此步即为将2块磁盘空间合二为一的关键步骤；当系统中新增了磁盘或新建了物理卷，而要将其添加到已有卷组时，就可使用vgextend命令；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@MYSQL-SERVER ~]#  vgextend vgmysql /dev/sdc1</span><br><span class="line">  Volume group &quot;vgmysql&quot; successfully extended</span><br></pre></td></tr></table></figure></p>
<p><strong>查看卷组</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@MYSQL-SERVER ~]#  vgs</span><br><span class="line">  VG      #PV #LV #SN Attr   VSize   VFree </span><br><span class="line">  vgmysql   2   0   0 wz--n-  32.74t 32.74t</span><br><span class="line">  vgroot    1   4   0 wz--n- 264.00g  4.00m</span><br></pre></td></tr></table></figure></p>
<p><strong>创建逻辑卷</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@MYSQL-SERVER ~]#  lvcreate -L 32.7T -n lvmysql vgmysql </span><br><span class="line">  Rounding up size to full physical extent 32.70 TiB</span><br><span class="line">  Logical volume &quot;lvmysql&quot; created.</span><br></pre></td></tr></table></figure></p>
<p><strong>格式化逻辑卷</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@MYSQL-SERVER ~]#  mkfs -t xfs /dev/vgmysql/lvmysql</span><br><span class="line">meta-data=/dev/vgmysql/lvmysql   isize=512    agcount=33, agsize=268435328 blks</span><br><span class="line">         =                       sectsz=4096  attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=1, sparse=0, rmapbt=0, reflink=0</span><br><span class="line">data     =                       bsize=4096   blocks=8777839616, imaxpct=5</span><br><span class="line">         =                       sunit=64     swidth=64 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line">log      =internal log           bsize=4096   blocks=521728, version=2</span><br><span class="line">         =                       sectsz=4096  sunit=1 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure></p>
<p><strong>创建挂载目录并挂载</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">挂载</span><br><span class="line">mount /dev/vgmysql/lvmysql /mysql_data/</span><br><span class="line"></span><br><span class="line">做开机自动挂载</span><br><span class="line">echo &apos;/dev/mapper/vgmysql-lvmysql /mysql_data xfs     defaults 0 0&apos; &gt;/etc/fstab</span><br></pre></td></tr></table></figure>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol>
<li><a href="https://www.cnblogs.com/daduryi/p/6619028.html" target="_blank" rel="noopener">https://www.cnblogs.com/daduryi/p/6619028.html</a></li>
<li><a href="https://www.cnblogs.com/wholj/p/10924129.html" target="_blank" rel="noopener">https://www.cnblogs.com/wholj/p/10924129.html</a></li>
<li><a href="https://www.cnblogs.com/f-ck-need-u/p/7048971.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7048971.html</a></li>
<li><a href="https://blog.csdn.net/s361260777/article/details/82631170" target="_blank" rel="noopener">https://blog.csdn.net/s361260777/article/details/82631170</a></li>
<li><a href="https://www.cnblogs.com/f-ck-need-u/p/7049233.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7049233.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统启动小结</title>
    <url>/2021/05/24/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h4 id="BIOS、EFI、UEFI"><a href="#BIOS、EFI、UEFI" class="headerlink" title="BIOS、EFI、UEFI"></a>BIOS、EFI、UEFI</h4><p>BIOS存储在BIOS芯片中，而现在的新式电脑用的基本都是UEFI启动，早期的过渡电脑用的都是EFI启动。其实EFI或UEFI的一部分也是存储在一个芯片中，由于它们在表面形式、基本功能上和BIOS差不多，所以习惯上我们也把存储EFI/UEFI的芯片叫做EFI/UEFI BIOS芯片，EFI/UEFI也叫做EFI/UEFI BIOS，但在实际上它们和BIOS根本是不一样的，所以最好还是把后面的“BIOS”尾巴去掉为好，下面就来具体谈一下BIOS、EFI和UEFI。</p>
<p>BIOS本身是汇编语言代码，是在16位实模式下调用INT 13H中断执行的，由于x86-64是一个高度兼容的指令集，也为了迁就BIOS的16位实模式的运行环境，所以即使现在的CPU都已是64位，如果还是在BIOS启动（基本见于09年以前的主板），在开机时仍然都是在16位实模式下执行的。16位实模式直接能访问的内存只有1MB，就算你安了4G、8G或者16G还是32G内存，到了BIOS上一律只先认前1MB。在这1MB内存中，前640K称为基本内存，后面384K内存留给开机必要硬件和各类BIOS本身使用，了解了这些，下面谈一下BIOS启动计算机的具体过程。</p>
<p>当按下电源开关时，电源就开始向主板和其他设备供电，这时电压还不稳定，在早期的南北桥主板上，由主板北桥向CPU发复位信号，对CPU初始化；稳定电压后复位信号便撤掉。而对于现在的单南桥主板，则由CPU自身调整稳定电压达到初始化的目的，当电压稳定后，CPU便在系统BIOS保留的内存地址处执行跳转BIOS起始处指令，开始执行POST自检。</p>
<p>在POST自检中，BIOS只检查系统的必要核心硬件是否有问题，主要是CPU、640K基本内存、显卡是否正常，PS/2键盘控制器、系统时钟是否有错误等等。由于POST检查在显卡初始化以前，因此在这个阶段如发生错误，是无法在屏幕上显示的，不过主板上还有个报警扬声器，而且如果主板的8255外围可编程接口芯片没有损坏的话，POST报警声音一定是会出来的。可以根据报警声的不同大致判断错误所在，一般情况下，一声短“嘀”声基本代表正常启动，不同的错误则是不同的短“嘀”声和长“嘀”声组合。POST自检结束后，BIOS开始调用中断完成各种硬件初始化工作。</p>
<p>硬件初始化工作中，主要说明两点，首先经过POST检测后，电脑终于出现了开机启动画面，这就是已经检测到了显卡并完成了初始化。但是请注意，由于BIOS是在16位实模式运行，因此该画面是以VGA分辨率（640*480，纵横比4:3）显示的，因为实模式最高支持的就是VGA。以前的小14-17寸CRT显示器由于都是4:3比例，最高分辨率也比较低，因此这个开机启动画面没有什么违和感，但现在的液晶显示器基本上都是宽屏16:9的，分辨率也较高，因此在这样的显示屏下，启动画面上的一切东西显示都可以说“惨不忍睹”——图形被拉长，字体很大很模糊，可以很明显看到显示字体的锯齿。第二，BIOS只识别到由主引导记录（MBR）初始化的硬盘，之所以说明这点，是因为后续的EFI或UEFI采用了一种新的GUID磁盘分区系统（GPT）格式，这种硬盘在BIOS下是无法识别的。硬件全部初始化完毕后，接下来进入更新ESCD阶段。</p>
<p>在ESCD更新阶段中，BIOS将对存储在CMOS中和操作系统交换的硬件配置数据进行检测，如果系统硬件发生变动，则会更新该数据，否则不更新保持原状不变，ESCD检测或更新结束后，BIOS将完成最后一项工作，就是启动操作系统。</p>
<p>最后这一步中，BIOS根据CMOS中用户指定的硬件启动顺序，读取相应设备的启动或引导记录，引导相应设备上的操作系统启动，进入操作系统，此后便由操作系统接替BIOS负责硬件和软件间的相互通信。如果发现所有硬件都没有能引导操作系统的记录，则会在屏幕上显示相应错误信息，并将电脑维持在16位实模式。</p>
<p>EFI，是Extensible Firmware Interface的词头缩写，直译过来就是可扩展固件接口，它是用模块化、高级语言（主要是C语言）构建的一个小型化系统，它和BIOS一样，主要在启动过程中完成硬件初始化，但它是直接利用加载EFI驱动的方式，识别系统硬件并完成硬件初始化，彻底摒弃读各种中断执行。EFI驱动并不是直接面向CPU的代码，而是由EFI字节码编写成，EFI字节码是专用于EFI的虚拟机器指令，需要在EFI驱动运行环境DXE下解释运行，这样EFI既可以实现通配，又提供了良好的兼容。此外，EFI完全是32位或64位，摒弃16位实模式，在EFI中就可以实现处理器的最大寻址，因此可以在任何内存地址存放任何信息。另外，由于EFI的驱动开发非常简单，基于EFI的驱动模型原则上可以使EFI接触到所有硬件功能，在EFI上实现文件读写，网络浏览都是完全可能的。BIOS上的的CMOS设置程序在EFI上是作为一个个EFI程序来执行的，硬件设置是硬件设置程序、而启动管理则是另一个程序，保存CMOS又是另一个程序，虽然它们在形式的Shell上是在一起的。</p>
<p>EFI在功能上完全等同于一个轻量化的OS，但是EFI在制定时就定位到不足以成为专业OS的地位上，首先，它只是一个硬件和操作系统间的一个接口；其次，EFI不提供中断访问机制，EFI必须用轮询的方式检查并解释硬件，较OS下的驱动执行效率较低，最后，EFI只有简单的存储器管理机制，在段保护模式下只将存储器分段，所有程序都可以存取任何一段位置，不提供真实的保护服务。伴随着EFI，一种全新的GUID磁盘分区系统（GPT）被引入支持，传统MBR磁盘只能存在4个主分区，只有在创建主分区不足4个时，可以建立一个扩展分区，再在其上建立被系统识别的逻辑分区，逻辑分区也是有数量的，太多的逻辑分区会严重影响系统启动，MBR硬盘分区最大仅支持2T容量，对于现在的大容量硬盘来说也是浪费。GPT支持任意多的分区，每个分区大小原则上是无限制的，但实际上受到OS的规定限制不能做到无限，不过比MBR的2T限制是非常重要的进步。GPT的分区类型由GUID表唯一指定，基本不可能出现重复，其中的EFI系统分区可以被EFI存取，用来存取部分驱动和应用程序，虽然这原则上会使EFI系统分区变得不安全，但是一般这里放置的都是些“边缘”数据，即使其被破坏，一般也不会造成严重后果，而且也能够简单的恢复回来。</p>
<p>当EFI发展到1.1的时候，英特尔决定把EFI公之于众，于是后续的2.0吸引了众多公司加入，EFI也不再属于英特尔，而是属于了Unified EFI Form的国际组织，EFI在2.0后也遂改称为UEFI，UEFI，其中的EFI和原来是一个意思，U则是Unified（一元化、统一）的缩写，所以UEFI的意思就是“统一的可扩展固件接口”，与前身EFI相比，UEFI主要有以下改进：</p>
<p>首先，UEFI具有完整的图形驱动功能，之前的EFI虽然原则上加入了图形驱动，但为了保证EFI和BIOS的良好过渡，EFI多数还是一种类DOS界面（仍然是640<em>480VGA分辨率），只支持PS/2键盘操作（极少数支持鼠标操作），不支持USB键盘和鼠标。到了UEFI，则是拥有了完整的图形驱动，无论是PS/2还是USB键盘和鼠标，UEFI一律是支持的，而且UEFI在显卡也支持GOP VBIOS的时候，显示的设置界面是显卡高分辨率按640</em>480或1024*768显示，因此画面虽小但很清楚，但是这样会导致屏幕周围大片留黑，不过鱼和熊掌不可兼得，除非UEFI默认窗口大小也是最高分辨率</p>
<p>其次，UEFI具有一个独特的功能，安全启动，而EFI是没有安全启动的，安全启动（Secure Boot），实际上通俗的解释是叫做固件验证。开启UEFI的安全启动后，主板会根据TPM芯片（或者CPU内置的TPM）记录的硬件签名对各硬件判断，只有符合认证的硬件驱动才会被加载，而Win8以后的Windows则是在操作系统加载的过程中对硬件驱动继续查签名，符合Windows记录的硬件才能被Windows加载，这在一定程度上降低了启动型程序在操作系统启动前被预加载造成的风险，但是这也会造成系统安装变得垄断</p>
<p>无论EFI还是UEFI，都必须要有预加载环境、驱动执行环境、驱动程序等必要部分组成，为了支持部分旧设备（如在UEFI下挂载传统MBR硬盘，不支持UEFI启动的显卡在UEFI下仍然支持运行等），还需要一个CSM兼容性支持模块、EFI或UEFI都是仅支持GPT磁盘引导系统的，下面就具体谈一下EFI或UEFI启动计算机的过程。</p>
<p>一般地，预加载环境和驱动执行环境是存储在UEFI（UEFI BIOS）芯片中的，当打开电源开关时，电脑的主要部件都开始有了供电，与BIOS不同的是，UEFI预加载环境首先开始执行，负责CPU和内存（是全部容量）的初始化工作，这里如出现重要问题，电脑即使有报警喇叭也不会响，因为UEFI没有去驱动8255发声，不过预加载环境只检查CPU和内存，如果这两个主要硬件出问题，屏幕没显示可以立即确定，另外一些主板会有提供LED提示，可根据CPU或内存亮灯大致判断故障。</p>
<p>CPU和内存初始化成功后，驱动执行环境（DXE）载入，当DXE载入后，UEFI就具有了枚举并加载UEFI驱动程序的能力，在此阶段，UEFI会枚举搜索各个硬件的UEFI驱动并相继加载，完成硬件初始化工作，这相比BIOS的读中断加载速度会快的多，同样如加载显卡的UEFI驱动成功，电脑也会出现启动画面，硬件驱动全部加载完毕后，最后同BIOS一样，也得去启动操作系统。</p>
<p>在启动操作系统的阶段，同样是根据启动记录的启动顺序，转到相应设备（仅限GPT设备，如果启动传统MBR设备，则需要打开CSM支持）的引导记录，引导操作系统并进入，这里需要注意的是，UEFI在检测到无任何操作系统启动设备时，会直接进入UEFI设置页面，而不是像BIOS那样黑屏显示相关信息。</p>
<p>综上对BIOS和UEFI启动计算机过程的叙述，可以概括为：BIOS先要对CPU初始化，然后跳转到BIOS启动处进行POST自检，此过程如有严重错误，则电脑会用不同的报警声音提醒，接下来采用读中断的方式加载各种硬件，完成硬件初始化后进入操作系统启动过程；而UEFI则是运行预加载环境先直接初始化CPU和内存，CPU和内存若有问题则直接黑屏，其后启动PXE采用枚举方式搜索各种硬件并加载驱动，完成硬件初始化，之后同样进入操作系统启动过程。</p>
<p>此外，BIOS是16位汇编语言程序，只能运行在16位实模式，可访问的内存只有1MB，而UEFI是32位或64位高级语言程序（C语言程序），突破实模式限制，可以达到要求的最大寻址。</p>
<h4 id="genisoimage、mkisofs"><a href="#genisoimage、mkisofs" class="headerlink" title="genisoimage、mkisofs"></a>genisoimage、mkisofs</h4><p><strong>genisoimage</strong></p>
<p>功能说明：建立ISO 9660映像文件。  </p>
<p>常用命令：genisoimage -o imagename.iso file </p>
<p>语 法：mkisofs [-adDfhJlLNrRTvz][-print-size][-quiet][-A ][-abstract ][-b ][-biblio ][-c ][-C ][-copyright ][-hide ][-hide-joliet ][-log-file ][-m ][-M ][-o ][-p ][-P ][-sysid ][-V ][-volset ][-volset-size ][-volset-seqno ][-x ][目录或文件]  </p>
<p><strong>mkisofs</strong></p>
<p>命令: mkisofs(make iso file system)</p>
<p>功能说明：建立ISO 9660映像文件。</p>
<p>语 法：mkisofs [-adDfhJlLNrRTvz][-print-size][-quiet][-A &lt;应用程序ID&gt;][-abstract &lt;摘要文件&gt;][-b &lt;开机映像文件&gt;][-biblio ][-c &lt;开机文件名称&gt;][-C &lt;盘区编号，磁区编号&gt;][-copyright &lt;版权信息文件&gt;][-hide &lt;目录或文件名&gt;][-hide-joliet &lt;文件或目录名&gt;][-log-file &lt;记录文件&gt;][-m &lt;目录或文件名&gt;][-M &lt;开机映像文件&gt;][-o &lt;映像文件&gt;][-p &lt;数据处理人&gt;][-P &lt;光盘发行人&gt;][-sysid &lt;系统ID &gt;][-V &lt;光盘ID &gt;][-volset &lt;卷册集ID&gt;][-volset-size &lt;光盘总数&gt;][-volset-seqno &lt;卷册序号&gt;][-x &lt;目录&gt;][目录或文件]</p>
<p>补充说明：mkisofs可将指定的目录与文件做成ISO 9660格式的映像文件，以供刻录光盘。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参 数：</span><br><span class="line">-a或--all mkisofs通常不处理备份文件。使用此参数可以把备份文件加到映像文件中。</span><br><span class="line">-A&lt;应用程序ID&gt;或-appid&lt;应用程序ID&gt; 指定光盘的应用程序ID。</span><br><span class="line">-abstract&lt;摘要文件&gt; 指定摘要文件的文件名。</span><br><span class="line">-b&lt;开机映像文件&gt;或-eltorito-boot&lt;开机映像文件&gt; 指定在制作可开机光盘时所需的开机映像文件。</span><br><span class="line">-biblio 指定ISBN文件的文件名，ISBN文件位于光盘根目录下，记录光盘的ISBN。</span><br><span class="line">-c&lt;开机文件名称&gt; 制作可开机光盘时，mkisofs会将开机映像文件中的全-eltorito-catalog&lt;开机文件名称&gt;全部内容作成一个文件。</span><br><span class="line">-C&lt;盘区编号，盘区编号&gt; 将许多节区合成一个映像文件时，必须使用此参数。</span><br><span class="line">-copyright&lt;版权信息文件&gt; 指定版权信息文件的文件名。</span><br><span class="line">-d或-omit-period 省略文件后的句号。</span><br><span class="line">-D或-disable-deep-relocation ISO 9660最多只能处理8层的目录，超过8层的部分，RRIP会自动将它们设置成ISO 9660兼容的格式。使用-D参数可关闭此功能。</span><br><span class="line">-f或-follow-links 忽略符号连接。</span><br><span class="line">-h 显示帮助。</span><br><span class="line">-hide&lt;目录或文件名&gt; 使指定的目录或文件在ISO 9660或Rock RidgeExtensions的系统中隐藏。</span><br><span class="line">-hide-joliet&lt;目录或文件名&gt; 使指定的目录或文件在Joliet系统中隐藏。</span><br><span class="line">-J或-joliet 使用Joliet格式的目录与文件名称。</span><br><span class="line">-l或-full-iso9660-filenames 使用ISO 9660 32字符长度的文件名。</span><br><span class="line">-L或-allow-leading-dots 允许文件名的第一个字符为句号。</span><br><span class="line">-log-file&lt;记录文件&gt; 在执行过程中若有错误信息，预设会显示在屏幕上。</span><br><span class="line">-m&lt;目录或文件名&gt;或-exclude&lt;目录或文件名&gt; 指定的目录或文件名将不会房入映像文件中。</span><br><span class="line">-M&lt;映像文件&gt;或-prev-session&lt;映像文件&gt; 与指定的映像文件合并。</span><br><span class="line">-N或-omit-version-number 省略ISO 9660文件中的版本信息。</span><br><span class="line">-o&lt;映像文件&gt;或-output&lt;映像文件&gt; 指定映像文件的名称。</span><br><span class="line">-p&lt;数据处理人&gt;或-preparer&lt;数据处理人&gt; 记录光盘的数据处理人。</span><br><span class="line">-print-size 显示预估的文件系统大小。</span><br><span class="line">-quiet 执行时不显示任何信息。</span><br><span class="line">-r或-rational-rock 使用Rock Ridge Extensions，并开放全部文件的读取权限。</span><br><span class="line">-R或-rock 使用Rock Ridge Extensions。</span><br><span class="line">-sysid&lt;系统ID&gt; 指定光盘的系统ID。</span><br><span class="line">-T或-translation-table 建立文件名的转换表，适用于不支持Rock Ridge Extensions的系统上。</span><br><span class="line">-v或-verbose 执行时显示详细的信息。</span><br><span class="line">-V&lt;光盘ID</span><br></pre></td></tr></table></figure>
<h4 id="UEFI-GPT引导基础"><a href="#UEFI-GPT引导基础" class="headerlink" title="UEFI+GPT引导基础"></a>UEFI+GPT引导基础</h4><p><strong>GPT及其优势</strong></p>
<p>GPT和MBR是两种不同的分区方案。目前在Windows下广泛采用的磁盘分区方案仍然是MBR分区结构，但不容怀疑GPT是今后的趋势。我们可将MBR磁盘分区结构用下图简单表示（Windows下基本磁盘、4个主分区）：</p>
<p><img src="/2021/05/24/linux系统启动小结/gpt1.png" alt="avatar"></p>
<p>为了方便计算机访问硬盘，把硬盘上的空间划分成许许多多的区块（英文叫sectors，即扇区），然后给每个区块分配一个地址，称为逻辑块地址（即LBA）。</p>
<p>在MBR磁盘的第一个扇区内保存着启动代码和硬盘分区表。启动代码的作用是指引计算机从活动分区引导启动操作系统（BIOS下启动操作系统的方式）；分区表的作用是记录硬盘的分区信息。在MBR中，分区表的大小是固定的，一共可容纳4个主分区信息。在MBR分区表中逻辑块地址采用32位二进制数表示，因此一共可表示2^32（2的32次方）个逻辑块地址。如果一个扇区大小为512字节，那么硬盘最大分区容量仅为2TB。</p>
<p>GPT磁盘分区结构可用下图简单表示（Windows下基本磁盘）：</p>
<p><img src="/2021/05/24/linux系统启动小结/gpt2.png" alt="avatar"></p>
<p>GPT分区结构<br>可以看到，在GTP磁盘的第一个数据块中同样有一个与MBR（主引导记录）类似的标记，叫做PMBR。PMBR的作用是，当使用不支持GPT的分区工具时，整个硬盘将显示为一个受保护的分区，以防止分区表及硬盘数据遭到破坏。UEFI并不从PMBR中获取GPT磁盘的分区信息，它有自己的分区表，即GPT分区表。</p>
<p>GPT的分区方案之所以比MBR更先进，是因为在GPT分区表头中可自定义分区数量的最大值，也就是说GPT分区表的大小不是固定的。在Windows中，微软设定GPT磁盘最大分区数量为128个。另外，GPT分区方案中逻辑块地址（LBA）采用64位二进制数表示，可以计算一下2^64是一个多么庞大的数据，以我们的需求来讲完全有理由认为这个大小约等于无限。除此之外，GPT分区方案在硬盘的末端还有一个备份分区表，保证了分区信息不容易丢失。</p>
<h4 id="安装系统启动过程"><a href="#安装系统启动过程" class="headerlink" title="安装系统启动过程"></a>安装系统启动过程</h4><p>以光盘安装操作系统为例，当我们安装系统时，它是怎么一步步读取光盘中的必要文件，从而实现系统的安装；不论是哪种安装方法，光盘、硬盘、网络等等，涉及的系统安装必要文件是一样的；</p>
<p>第一步：读取MBR： isolinux/boot.cat ###boot.cat的作用就相当于启动流程中的MBR的446字节效果</p>
<p>第二步: 读取isolinux/isolinux.bin ###isolinux.bin的作用等价于grub的第二阶段</p>
<p>第三步：加载配置文件： isolinux/isolinux.cfg ###这个文件就是启动菜单；自定义启动菜单可以修改此文件</p>
<p>第四步：根据配置文件定义调用内核文件</p>
<ul>
<li>加载内核： isolinuz/vmlinuz</li>
<li>向内核传递参数： append initrd=initrd.img</li>
</ul>
<p>第五步：装载根文件系统，并启动anaconda ###anaconda就是kickstart文件</p>
<p>默认启动GUI接口</p>
<p>若是显式指定使用GUI接口： 向内核传递text参数即可</p>
<p>(1)按tab键,在后面增加text ###tab进入的就是isolinux.cfg内容</p>
<p>(2)按ESC键： boot: linux text ###boot后面接label的内容，就进入相应的模式；如boot：rescue 当然如果是boot：linux rescue 进入的也是救援模式，因为linux和rescue之间就差一个rescue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos6 ~]#lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1  3.7G  0 rom  /mnt</span><br><span class="line">sda      8:0    0  200G  0 disk </span><br><span class="line">├─sda1   8:1    0    1G  0 part /boot</span><br><span class="line">├─sda2   8:2    0 48.8G  0 part /</span><br><span class="line">├─sda3   8:3    0 29.3G  0 part /data</span><br><span class="line">├─sda4   8:4    0    1K  0 part </span><br><span class="line">└─sda5   8:5    0    2G  0 part [SWAP]</span><br><span class="line">[root@centos6 ~]#cd /mnt/</span><br><span class="line">[root@centos6 mnt]#ls</span><br><span class="line">CentOS_BuildTag  isolinux                  RPM-GPG-KEY-CentOS-Debug-6</span><br><span class="line">EFI              Packages                  RPM-GPG-KEY-CentOS-Security-6</span><br><span class="line">EULA             RELEASE-NOTES-en-US.html  RPM-GPG-KEY-CentOS-Testing-6</span><br><span class="line">GPL              repodata                  TRANS.TBL</span><br><span class="line">images           RPM-GPG-KEY-CentOS-6</span><br><span class="line">[root@centos6 mnt]#cd isolinux/</span><br><span class="line">[root@centos6 isolinux]#ls   ###此部分就是官方提供的光盘安装系统，提供的必要文件</span><br><span class="line">boot.cat  grub.conf   isolinux.bin  memtest     TRANS.TBL     vmlinuz</span><br><span class="line">boot.msg  initrd.img  isolinux.cfg  splash.jpg  vesamenu.c32</span><br><span class="line">[root@centos6 isolinux]#</span><br></pre></td></tr></table></figure>
<p><strong>系统引导文件分析—isolinux.cfg</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos6 isolinux]#cat isolinux.cfg</span><br><span class="line">default vesamenu.c32    ###启动菜单的样式</span><br><span class="line">#prompt 1</span><br><span class="line">timeout 600</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">display boot.msg   ####启动时的背景图片，以及下面设置了相关的菜单主题风格</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">menu background splash.jpg</span><br><span class="line">menu title Welcome to CentOS 6.10!</span><br><span class="line">menu color border 0 #ffffffff #00000000</span><br><span class="line">menu color sel 7 #ffffffff #ff000000</span><br><span class="line">menu color title 0 #ffffffff #00000000</span><br><span class="line">menu color tabmsg 0 #ffffffff #00000000</span><br><span class="line">menu color unsel 0 #ffffffff #00000000</span><br><span class="line">menu color hotsel 0 #ff000000 #ffffffff</span><br><span class="line">menu color hotkey 7 #ffffffff #ff000000</span><br><span class="line">menu color scrollbar 0 #ffffffff #00000000</span><br><span class="line">label linux   ###下面的五个label定义了启动系统可供选择的五个模式，对照图片可以一一对应</span><br><span class="line">  menu label ^Install or upgrade an existing system</span><br><span class="line">  menu default</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img</span><br><span class="line">label vesa</span><br><span class="line">  menu label Install system with ^basic video driver</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img nomodeset</span><br><span class="line">label rescue</span><br><span class="line">  menu label ^Rescue installed system</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img rescue</span><br><span class="line">label local</span><br><span class="line">  menu label Boot from ^local drive</span><br><span class="line">  localboot 0xffff</span><br><span class="line">label memtest86</span><br><span class="line">  menu label ^Memory test</span><br><span class="line">  kernel memtest</span><br><span class="line">  append -</span><br></pre></td></tr></table></figure>
<h4 id="CentOS-7-UEFI模式"><a href="#CentOS-7-UEFI模式" class="headerlink" title="CentOS 7 UEFI模式"></a>CentOS 7 UEFI模式</h4><ol>
<li>UEFI模式下EFI目录是必须的，legacy模式下EFI可以删除</li>
</ol>
<p><img src="/2021/05/24/linux系统启动小结/uefi1.png" alt="avatar"></p>
<ol start="2">
<li>ks引导文件在grub.cfg里修改</li>
</ol>
<p><img src="/2021/05/24/linux系统启动小结/uefi2.png" alt="avatar"></p>
<p><img src="/2021/05/24/linux系统启动小结/uefi3.png" alt="avatar"></p>
<ol start="3">
<li>efiboot.img文件是UEFI模式下必须的</li>
</ol>
<p><img src="/2021/05/24/linux系统启动小结/uefi4.png" alt="avatar"></p>
<ol start="4">
<li>UEFI模式需要有如下包支持</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grub2-efi、grub2-tools、grub2-tools-extra、grub2-tools-minimal、grub2-common、shim、mokutil、efivar-libs、efibootmgr</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>legacy和UEFI模式ks文件的区别是磁盘分区，UEFI模式多了一个/boot/efi分区</li>
</ol>
<p><img src="/2021/05/24/linux系统启动小结/uefi5.png" alt="avatar"></p>
<ol start="6">
<li>UEFI打包方式和legacy模式不一样,命令如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">genisoimage -v -cache-inodes -joliet-long -R -J -T \</span><br><span class="line">-o /$iso_dir/CentOS-7_x86_64-UEFI.iso -b isolinux/isolinux.bin -c isolinux/boot.cat \</span><br><span class="line">-no-emul-boot -boot-load-size 4 -boot-info-table -eltorito-alt-boot -b images/efiboot.img -no-emul-boot -input-charset</span><br></pre></td></tr></table></figure>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://blog.csdn.net/ZhangSong051052/article/details/80670970" target="_blank" rel="noopener">https://blog.csdn.net/ZhangSong051052/article/details/80670970</a></li>
<li><a href="https://www.cnblogs.com/klb561/p/9108712.html" target="_blank" rel="noopener">https://www.cnblogs.com/klb561/p/9108712.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/45791653" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45791653</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/345519855" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/345519855</a></li>
<li><a href="https://developer.aliyun.com/article/523995" target="_blank" rel="noopener">https://developer.aliyun.com/article/523995</a></li>
<li><strong><a href="https://www.zhihu.com/question/21672895" target="_blank" rel="noopener">https://www.zhihu.com/question/21672895</a></strong></li>
<li><a href="https://blog.51cto.com/xlogin/1261632" target="_blank" rel="noopener">https://blog.51cto.com/xlogin/1261632</a></li>
<li><a href="https://yangfannie.com/1930.html" target="_blank" rel="noopener">https://yangfannie.com/1930.html</a></li>
<li><a href="https://www.iruanmi.com/what-is-gpt-and-what-is-uefi/" target="_blank" rel="noopener">https://www.iruanmi.com/what-is-gpt-and-what-is-uefi/</a></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>pika安装过程中illegal instruction的问题</title>
    <url>/2021/04/13/pika%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E4%B8%ADillegal-instruction%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h4><p>最近在运行pika的过程中遇到了”illegal instruction”的问题，通过strace跟踪系统调用的过程，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execve(&quot;./pika&quot;, [&quot;./pika&quot;], [/* 26 vars */]) = 0</span><br><span class="line">brk(NULL)                               = 0x22b2000</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x2ab721822000</span><br><span class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=97425, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 97425, PROT_READ, MAP_PRIVATE, 3, 0) = 0x2ab721823000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/lib64/libpthread.so.0&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\0m\0\0\0\0\0\0&quot;..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=144792, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 2208904, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x2ab721a24000</span><br><span class="line">mprotect(0x2ab721a3b000, 2093056, PROT_NONE) = 0</span><br><span class="line">mmap(0x2ab721c3a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x16000) = 0x2ab721c3a000</span><br><span class="line">mmap(0x2ab721c3c000, 13448, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x2ab721c3c000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/lib64/librt.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\&quot;\0\0\0\0\0\0&quot;..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=44448, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 2128952, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x2ab721c40000</span><br><span class="line">mprotect(0x2ab721c47000, 2093056, PROT_NONE) = 0</span><br><span class="line">mmap(0x2ab721e46000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6000) = 0x2ab721e46000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/lib64/libz.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\20!\0\0\0\0\0\0&quot;..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=90248, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x2ab72183b000</span><br><span class="line">mmap(NULL, 2183272, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x2ab721e48000</span><br><span class="line">mprotect(0x2ab721e5d000, 2093056, PROT_NONE) = 0</span><br><span class="line">mmap(0x2ab72205c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x14000) = 0x2ab72205c000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/lib64/libbz2.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0`\27\0\0\0\0\0\0&quot;..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=68192, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 2162024, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x2ab72205e000</span><br><span class="line">mprotect(0x2ab72206d000, 2093056, PROT_NONE) = 0</span><br><span class="line">mmap(0x2ab72226c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0xe000) = 0x2ab72226c000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/lib64/libm.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0pS\0\0\0\0\0\0&quot;..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1139680, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 3150136, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x2ab72226e000</span><br><span class="line">mprotect(0x2ab72236f000, 2093056, PROT_NONE) = 0</span><br><span class="line">mmap(0x2ab72256e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x100000) = 0x2ab72256e000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/lib64/libgcc_s.so.1&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\220*\0\0\0\0\0\0&quot;..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=88776, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x2ab72183c000</span><br><span class="line">mmap(NULL, 2184192, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x2ab722570000</span><br><span class="line">mprotect(0x2ab722585000, 2093056, PROT_NONE) = 0</span><br><span class="line">mmap(0x2ab722784000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x14000) = 0x2ab722784000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/lib64/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P%\2\0\0\0\0\0&quot;..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2173512, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 3981792, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x2ab722786000</span><br><span class="line">mprotect(0x2ab722949000, 2093056, PROT_NONE) = 0</span><br><span class="line">mmap(0x2ab722b48000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c2000) = 0x2ab722b48000</span><br><span class="line">mmap(0x2ab722b4e000, 16864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x2ab722b4e000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x2ab72183d000</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x2ab72183e000</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x2ab72183e4c0) = 0</span><br><span class="line">mprotect(0x2ab722b48000, 16384, PROT_READ) = 0</span><br><span class="line">mprotect(0x2ab722784000, 4096, PROT_READ) = 0</span><br><span class="line">mprotect(0x2ab72256e000, 4096, PROT_READ) = 0</span><br><span class="line">mprotect(0x2ab72226c000, 4096, PROT_READ) = 0</span><br><span class="line">mprotect(0x2ab72205c000, 4096, PROT_READ) = 0</span><br><span class="line">mprotect(0x2ab721c3a000, 4096, PROT_READ) = 0</span><br><span class="line">mprotect(0x2ab721e46000, 4096, PROT_READ) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x2ab721840000</span><br><span class="line">mprotect(0x2ab721a21000, 4096, PROT_READ) = 0</span><br><span class="line">munmap(0x2ab721823000, 97425)           = 0</span><br><span class="line">set_tid_address(0x2ab72183e790)         = 8293</span><br><span class="line">set_robust_list(0x2ab72183e7a0, 24)     = 0</span><br><span class="line">rt_sigaction(SIGRTMIN, &#123;0x2ab721a2a7e0, [], SA_RESTORER|SA_SIGINFO, 0x2ab721a336d0&#125;, NULL, 8) = 0</span><br><span class="line">rt_sigaction(SIGRT_1, &#123;0x2ab721a2a870, [], SA_RESTORER|SA_RESTART|SA_SIGINFO, 0x2ab721a336d0&#125;, NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">getrlimit(RLIMIT_STACK, &#123;rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY&#125;) = 0</span><br><span class="line">brk(NULL)                               = 0x22b2000</span><br><span class="line">futex(0xd8b190, FUTEX_WAKE_PRIVATE, 2147483647) = 0</span><br><span class="line">brk(NULL)                               = 0x22b2000</span><br><span class="line">brk(0x2ab2000)                          = 0x2ab2000</span><br><span class="line">brk(NULL)                               = 0x2ab2000</span><br><span class="line">brk(NULL)                               = 0x2ab2000</span><br><span class="line">brk(0x2bb2000)                          = 0x2bb2000</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x2ab721823000</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x2ab721824000</span><br><span class="line">mincore(0x7ffe5ebfb15f, 1, 0x7ffe5ebfb15f) = -1 EINVAL (Invalid argument)</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">msync(0x7ffe5ebfb000, 4096, MS_ASYNC)   = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">msync(0x7ffe5ebfc000, 4096, MS_ASYNC)   = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">msync(0xa13000, 4096, MS_ASYNC)         = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], [], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0</span><br><span class="line">rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0</span><br><span class="line">msync(0x410000, 4096, MS_ASYNC)         = 0</span><br><span class="line">futex(0xf4554c, FUTEX_WAKE_PRIVATE, 2147483647) = 0</span><br><span class="line">futex(0xf45558, FUTEX_WAKE_PRIVATE, 2147483647) = 0</span><br><span class="line">--- SIGILL &#123;si_signo=SIGILL, si_code=ILL_ILLOPN, si_addr=0x673a12&#125; ---</span><br><span class="line">+++ killed by SIGILL (core dumped) +++</span><br><span class="line">非法指令(吐核)</span><br></pre></td></tr></table></figure></p>
<p>查看操作系统版本</p>
<p><img src="/2021/04/13/pika安装过程中illegal-instruction的问题/pika1.png" alt="avatar"></p>
<p>查看CPU的相关信息</p>
<p><img src="/2021/04/13/pika安装过程中illegal-instruction的问题/pika2.png" alt="avatar"></p>
<p>可以发现该系统为由KVM安全虚拟化的操作系统，通过strace跟踪日志提示“ILL_ILLOPN”，可基本判断是执行pika命令过程中堆栈内存溢出。那具体是什么原因造成SIGILL？</p>
<p>在KVM虚拟化的centos7.6上安装pika，没有复现客户现场问题。参考<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://blog.craftyun.cn/post/191.html</span><br></pre></td></tr></table></figure></p>
<h4 id="Illegal-Instruction问题整理"><a href="#Illegal-Instruction问题整理" class="headerlink" title="Illegal Instruction问题整理"></a>Illegal Instruction问题整理</h4><p>illegal instruction，即SIGILL， 是POSIX标准中提供的一类错误。 从名字上看，SIGILL是启动的某个进程中的某一句不能被CPU识别成正确的指令。 此类错误是由操作系统发送给进程的，在进程试图执行一些形式错误、未知或者特权指令时操作系统会使用SIGILL信号终止程序。 SIGILL对应的常数是4.</p>
<p><strong>造成SIGILL的原因</strong></p>
<ol>
<li>将不正确的数据写入代码段</li>
</ol>
<p>进程在代码段中的数据是要被作为一个指令执行的。 若不小心覆盖了已有的代码段，可能会得到错误格式的指令。 这种错误尤其在Just-In-Time即时编译器中最可能出现。</p>
<p>同样，如果不小心覆盖了栈上活跃记录中的返回地址，程序就可能根据这个错误地址，执行没有意义的内存中的数据，进而操作。</p>
<p>进一步可以认为，任何导致数据错误的问题都可能带来illegal instruction问题。比如硬盘发生故障。</p>
<ol start="2">
<li>指令集的演进</li>
</ol>
<p>比如SIMD指令，自从奔腾4开始有MMX，X86的芯片就开始不停的增加和拓宽SIMD支持，SSE、SSE2、SSE3、SSE42、AVX、AVX2。 默认情况下，很多编译器都在O2或者O3中开了自动向量化，这就导致很多在新体系结构中编译的可执行程序，在老机器上运行时会有illegal instruction问题。</p>
<ol start="3">
<li>工具链bug</li>
</ol>
<p>对于普通C语言通过编译器生成的可执行程序。一般都已经通过严格的测试,不会随便发生这种问题。 所以如果你遇到这种错，并且试过了静态链，而且程序中没有嵌入式汇编，基本可以断定是工具链出了问题。 编译器？汇编器或者链接器。</p>
<ol start="4">
<li>访存对齐或浮点数格式问题</li>
</ol>
<p>根据Heiher的经验，请注意出现错误的指令可能和访存地址指令有关。 另外，浮点数的格式是否符合IEEE的标准也可能会有影响。</p>
<p><strong>错误排查指南</strong></p>
<ul>
<li>程序中有没有特权指令、或者访问特权寄存器</li>
<li>有没有将在较新CPU上编译得到的可执行文件拿到老CPU上运行</li>
<li>程序中有没有嵌入式汇编，先检查。</li>
<li>一般编译器很少会生成有这种问题的代码</li>
<li>X86平台上要尤其注意64位汇编指令和32位汇编指令的混用问题</li>
<li>程序有在进程代码段空间写数据的机会吗？</li>
<li>栈操作够安全吗？</li>
<li>注意程序的ABI是否正确</li>
<li>尤其是动态链和静态链是否处理的正确，尽量避免动态链的可执行文件调用错误库的问题（ARM的EABI，MIPS的N32/O32/N64都很可能出这种问题）</li>
</ul>
<p>与pika开发沟通后，大致定位在C++编译过程中动态链接库的问题，解决方式为在用户系统上重新编译pika。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><p>在编译pika之前，需要配置相关的yum源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y epel-release</span><br><span class="line">sudo sed -e &apos;s|^metalink=|#metalink=|g&apos; \</span><br><span class="line">         -e &apos;s|^#baseurl=https\?://download.fedoraproject.org/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g&apos; \</span><br><span class="line">         -i.bak \</span><br><span class="line">         /etc/yum.repos.d/epel.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p>参考链接<br><a href="https://github.com/Qihoo360/pika/wiki/%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">https://github.com/Qihoo360/pika/wiki/%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8</a></p>
</li>
</ol>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://blog.csdn.net/jk110333/article/details/41247789" target="_blank" rel="noopener">https://blog.csdn.net/jk110333/article/details/41247789</a><br><a href="https://blog.51cto.com/eminzhang/1629684" target="_blank" rel="noopener">https://blog.51cto.com/eminzhang/1629684</a><br><a href="https://blog.csdn.net/fatparsifal/article/details/6049246" target="_blank" rel="noopener">https://blog.csdn.net/fatparsifal/article/details/6049246</a><br><a href="https://www.coder.work/article/3284822" target="_blank" rel="noopener">https://www.coder.work/article/3284822</a></p>
]]></content>
      <tags>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的垃圾回收机制</title>
    <url>/2021/04/24/python%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="小整数对象池"><a href="#小整数对象池" class="headerlink" title="小整数对象池"></a>小整数对象池</h4><ol>
<li><p>小整数[-5,257)共用对象，常驻内存</p>
</li>
<li><p>单个字符共用对象，常驻内存</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a=1</span><br><span class="line">&gt;&gt;&gt; b=1</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4394670128</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">4394670128</span><br><span class="line">&gt;&gt;&gt; a=256</span><br><span class="line">&gt;&gt;&gt; b=256</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4394678288</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">4394678288</span><br><span class="line">&gt;&gt;&gt; b=257</span><br><span class="line">&gt;&gt;&gt; a=257</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4398855184</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">4396990128</span><br></pre></td></tr></table></figure>
<h4 id="大整数对象池"><a href="#大整数对象池" class="headerlink" title="大整数对象池"></a>大整数对象池</h4><p>每一个大整数，均创建一个新的对象。大整数不共用内存，引用计数为0，销毁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=1234</span><br><span class="line">&gt;&gt;&gt; b=1234</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4396990128</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">4398855088</span><br></pre></td></tr></table></figure>
<h4 id="intern机制"><a href="#intern机制" class="headerlink" title="intern机制"></a>intern机制</h4><ol>
<li>单个单词，不可修改，默认开启intern机制，共用对象，引用计数为0，则销毁</li>
<li>字符串（含有空格），不可修改，没开启intern机制，不共用对象，引用计数为0，销毁</li>
<li>数值类型和字符串类型在 Python 中都是不可变的，这意味着你无法修改这个对象的值，每次对变量的修改，实际上是创建一个新的对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=&quot;helloworld&quot;</span><br><span class="line">&gt;&gt;&gt; b=&quot;helloworld&quot;</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4532801648</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">4532801648</span><br><span class="line">&gt;&gt;&gt; b=&quot;hello world&quot;</span><br><span class="line">&gt;&gt;&gt; a=&quot;hello world&quot;</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">4532802416</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">4532802480</span><br></pre></td></tr></table></figure>
<h4 id="Garbage-collection-GC垃圾回收"><a href="#Garbage-collection-GC垃圾回收" class="headerlink" title="Garbage collection(GC垃圾回收)"></a>Garbage collection(GC垃圾回收)</h4><p>Python里也同java一样采用了垃圾收集机制，不过不一样的是: python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。</p>
<p>引用计数机制：</p>
<p>python里每一个东西都是对象，它们的核心就是一个结构体：PyObject</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct_object &#123;</span><br><span class="line">    int ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<p>PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define Py_INCREF(op)   ((op)-&gt;ob_refcnt++) //增加计数</span><br><span class="line">#define Py_DECREF(op) \ //减少计数</span><br><span class="line">    if (--(op)-&gt;ob_refcnt != 0) \</span><br><span class="line">        ; \</span><br><span class="line">    else \</span><br><span class="line">        __Py_Dealloc((PyObject *)(op))</span><br></pre></td></tr></table></figure>
<p>当引用计数为0时，该对象生命就结束了。</p>
<p><strong>引用计数机制的优点：</strong></p>
<ol>
<li>简单</li>
<li>实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。</li>
</ol>
<p><strong>引用计数机制的缺点：</strong></p>
<ol>
<li>维护引用计数消耗资源</li>
<li>循环引用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 = []</span><br><span class="line">list2 = []</span><br><span class="line">list1.append(list2)</span><br><span class="line">list2.append(list1)</span><br></pre></td></tr></table></figure>
<p>list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。 对于如今的强大硬件，缺点1尚可接受，但是循环引用导致内存泄露，注定python还将引入新的回收机制。(标记清除和分代收集)</p>
<h4 id="Python-的对象分配"><a href="#Python-的对象分配" class="headerlink" title="Python 的对象分配"></a>Python 的对象分配</h4><p>用Pyhon来创建一个Node对象：<br><img src="/2021/04/24/python中的垃圾回收机制/gc1.png" alt="avatar"></p>
<p>与Ruby不同，当创建对象时Python立即向操作系统请求内存。(Python实际上实现了一套自己的内存分配系统，在操作系统堆之上提供了一个抽象层。但是我今天不展开说了。)<br>当我们创建第二个对象的时候，再次像OS请求内存：<br><img src="/2021/04/24/python中的垃圾回收机制/gc2.png" alt="avatar"></p>
<p>在内部，创建一个对象时，Python总是在对象的C结构体里保存一个整数，称为引用数。期初，Python将这个值设置为1：<br><img src="/2021/04/24/python中的垃圾回收机制/gc3.png" alt="avatar"></p>
<p>值为1说明分别有个一个指针指向或是引用这三个对象。假如我们现在创建一个新的Node实例，JKL：<br><img src="/2021/04/24/python中的垃圾回收机制/gc4.png" alt="avatar"></p>
<p>与之前一样，Python设置JKL的引用数为1。然而，请注意由于我们改变了n1指向了JKL，不再指向ABC，Python就把ABC的引用数置为0了。 此刻，Python垃圾回收器立刻挺身而出！每当对象的引用数减为0，Python立即将其释放，把内存还给操作系统：</p>
<p><img src="/2021/04/24/python中的垃圾回收机制/gc5.png" alt="avatar"></p>
<p>上面Python回收了ABC Node实例使用的内存。记住，Ruby弃旧对象原地于不顾，也不释放它们的内存。</p>
<p>Python的这种垃圾回收算法被称为引用计数。是George-Collins在1960年发明的，恰巧与John McCarthy发明的可用列表算法在同一年出现。就像Mike-Bernstein在6月份哥谭市Ruby大会杰出的垃圾回收机制演讲中说的: “1960年是垃圾收集器的黄金年代…”</p>
<p>现在来看第二例子。加入我们让n2引用n1：<br><img src="/2021/04/24/python中的垃圾回收机制/gc6.png" alt="avatar"><br>上图中左边的DEF的引用数已经被Python减少了，垃圾回收器会立即回收DEF实例。同时JKL的引用数已经变为了2 ，因为n1和n2都指向它。</p>
<h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p>首先Ruby把程序停下来，Ruby用”地球停转垃圾回收大法”。之后Ruby轮询所有指针，变量和代码产生别的引用对象和其他值。同时Ruby通过自身的虚拟机便利内部指针。标记出这些指针引用的每个对象。<br><img src="/2021/04/24/python中的垃圾回收机制/gc7.png" alt="avatar"></p>
<p>如果说被标记的对象是存活的，剩下的未被标记的对象只能是垃圾，这意味着我们的代码不再会使用它了。我会在下图中用白格子表示垃圾对象：<br><img src="/2021/04/24/python中的垃圾回收机制/gc8.png" alt="avatar"></p>
<p>接下来Ruby清除这些无用的垃圾对象，把它们送回到可用列表中：<br><img src="/2021/04/24/python中的垃圾回收机制/gc9.png" alt="avatar"></p>
<p>在内部这一切发生得迅雷不及掩耳，因为Ruby实际上不会吧对象从这拷贝到那。而是通过调整内部指针，将其指向一个新链表的方式，来将垃圾对象归位到可用列表中的。</p>
<h4 id="Python中的零代-Generation-Zero"><a href="#Python中的零代-Generation-Zero" class="headerlink" title="Python中的零代(Generation Zero)"></a>Python中的零代(Generation Zero)</h4><p>python使用一种不同的链表来持续追踪活跃的对象。而不将其称之为“活跃列表”，Python的内部C代码将其称为零代(Generation Zero)。每次当你创建一个对象或其他什么值的时候，Python会将其加入零代链表:<br><img src="/2021/04/24/python中的垃圾回收机制/gc10.png" alt="avatar"></p>
<p>从上边可以看到当我们创建ABC节点的时候，Python将其加入零代链表。请注意到这并不是一个真正的列表，并不能直接在你的代码中访问，事实上这个链表是一个完全内部的Python运行时。 相似的，当我们创建DEF节点的时候，Python将其加入同样的链表：<br><img src="/2021/04/24/python中的垃圾回收机制/gc11.png" alt="avatar"></p>
<p>现在零代包含了两个节点对象。(他还将包含Python创建的每个其他值，与一些Python自己使用的内部值。)</p>
<p><strong>检测循环引用</strong></p>
<p>随后，Python会循环遍历零代列表上的每个对象，检查列表中每个互相引用的对象，根据规则减掉其引用计数。在这个过程中，Python会一个接一个的统计内部引用的数量以防过早地释放对象。</p>
<p>为了便于理解，来看一个例子：</p>
<p><img src="/2021/04/24/python中的垃圾回收机制/gc12.png" alt="avatar"></p>
<p>从上面可以看到 ABC 和 DEF 节点包含的引用数为1.有三个其他的对象同时存在于零代链表中，蓝色的箭头指示了有一些对象正在被零代链表之外的其他对象所引用。(接下来我们会看到，Python中同时存在另外两个分别被称为一代和二代的链表)。这些对象有着更高的引用计数因为它们正在被其他指针所指向着。</p>
<p>接下来你会看到Python的GC是如何处理零代链表的</p>
<p><img src="/2021/04/24/python中的垃圾回收机制/gc13.png" alt="avatar"></p>
<p>通过识别内部引用，Python能够减少许多零代链表对象的引用计数。在上图的第一行中你能够看见ABC和DEF的引用计数已经变为零了，这意味着收集器可以释放它们并回收内存空间了。剩下的活跃的对象则被移动到一个新的链表：一代链表。</p>
<p>从某种意义上说，Python的GC算法类似于Ruby所用的标记回收算法。周期性地从一个对象到另一个对象追踪引用以确定对象是否还是活跃的，正在被程序所使用的，这正类似于Ruby的标记过程。</p>
<p><strong>Python中的GC阈值</strong></p>
<p>Python什么时候会进行这个标记过程？随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。</p>
<p>当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。</p>
<p>随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代列表。</p>
<p>通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。</p>
<h4 id="gc模块常用功能解析"><a href="#gc模块常用功能解析" class="headerlink" title="gc模块常用功能解析"></a>gc模块常用功能解析</h4><p>gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。</p>
<p><strong>常用函数：</strong></p>
<ol>
<li>gc.set_debug(flags) 设置gc的debug日志，一般设置为gc.DEBUG_LEAK</li>
<li>gc.collect([generation]) 显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。 返回不可达（unreachable objects）对象的数目</li>
<li>gc.get_threshold() 获取的gc模块中自动执行垃圾回收的频率。</li>
<li>gc.set_threshold(threshold0[, threshold1[, threshold2]) 设置自动执行垃圾回收的频率。</li>
<li>gc.get_count() 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表</li>
</ol>
<p><strong>gc模块的自动垃圾回收机制</strong></p>
<p>必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。<br>这个机制的主要作用就是发现并处理不可达的垃圾对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">垃圾回收=垃圾检查+垃圾回收</span><br></pre></td></tr></table></figure>
<p>在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，改对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。</p>
<p>gc模块里面会有一个长度为3的列表的计数器，可以通过gc.get_count()获取。</p>
<p>例如(488,3,0)，其中488是指距离上一次一代垃圾检查，Python分配内存的数目减去释放内存的数目，注意是内存分配，而不是引用计数的增加。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print gc.get_count() # (590, 8, 0)</span><br><span class="line">a = ClassA()</span><br><span class="line">print gc.get_count() # (591, 8, 0)</span><br><span class="line">del a</span><br><span class="line">print gc.get_count() # (590, 8, 0)</span><br></pre></td></tr></table></figure>
<p>3是指距离上一次二代垃圾检查，一代垃圾检查的次数，同理，0是指距离上一次三代垃圾检查，二代垃圾检查的次数。</p>
<p>gc模快有一个自动垃圾回收的阀值，即通过gc.get_threshold函数获取到的长度为3的元组，例如(700,10,10) 每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器</p>
<p>例如，假设阀值是(700,10,10)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当计数器从(699,3,0)增加到(700,3,0)，gc模块就会执行gc.collect(0),即检查一代对象的垃圾，并重置计数器为(0,4,0)</span><br><span class="line">当计数器从(699,9,0)增加到(700,9,0)，gc模块就会执行gc.collect(1),即检查一、二代对象的垃圾，并重置计数器为(0,0,1)</span><br><span class="line">当计数器从(699,9,9)增加到(700,9,9)，gc模块就会执行gc.collect(2),即检查一、二、三代对象的垃圾，并重置计数器为(0,0,0)</span><br></pre></td></tr></table></figure>
<p>gc模块唯一处理不了的是循环引用的类都有<strong>del</strong>方法，所以项目中要避免定义<strong>del</strong>方法</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>垃圾回收机制</strong></p>
<p>Python中的垃圾回收是以引用计数为主，分代收集为辅。</p>
<p><strong>导致引用计数+1的情况</strong></p>
<ol>
<li>对象被创建，例如a=23</li>
<li>对象被引用，例如b=a</li>
<li>对象被作为参数，传入到一个函数中，例如func(a)</li>
<li>对象作为一个元素，存储在容器中，例如list1=[a,a]</li>
</ol>
<p><strong>导致引用计数-1的情况</strong></p>
<ol>
<li>对象的别名被显式销毁，例如del a</li>
<li>对象的别名被赋予新的对象，例如a=24</li>
<li>一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）</li>
<li>对象所在的容器被销毁，或从容器中删除对象</li>
</ol>
<p><strong>查看一个对象的引用计数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">a = &quot;hello world&quot;</span><br><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure>
<p>可以查看a对象的引用计数，但是比正常计数大1，因为调用函数的时候传入a，这会让a的引用计数+1</p>
<p><strong>循环引用导致内存泄露</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassA():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;object born,id:%s&apos;%str(hex(id(self))))</span><br><span class="line"></span><br><span class="line">def f2():</span><br><span class="line">    while True:</span><br><span class="line">        c1 = ClassA()</span><br><span class="line">        c2 = ClassA()</span><br><span class="line">        c1.t = c2</span><br><span class="line">        c2.t = c1</span><br><span class="line">        del c1</span><br><span class="line">        del c2</span><br><span class="line"></span><br><span class="line">f2()</span><br></pre></td></tr></table></figure>
<p>执行f2()，进程占用的内存会不断增大。</p>
<ol>
<li>创建了c1，c2后这两块内存的引用计数都是1，执行c1.t=c2和c2.t=c1后，这两块内存的引用计数变成2.</li>
<li>在del c1后，内存1的对象的引用计数变为1，由于不是为0，所以内存1的对象不会被销毁，所以内存2的对象的引用数依然是2，在del c2后，同理，内存1的对象，内存2的对象的引用数都是1。</li>
<li>虽然它们两个的对象都是可以被销毁的，但是由于循环引用，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。</li>
</ol>
<p><strong>垃圾回收</strong></p>
<p>有三种情况会触发垃圾回收</p>
<ol>
<li>调用gc.collect(),</li>
<li>当gc模块的计数器达到阀值的时候。</li>
<li>程序退出的时候</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import gc</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;object born,id:%s&apos;%str(hex(id(self))))</span><br><span class="line">    # def __del__(self):</span><br><span class="line">    #     print(&apos;object del,id:%s&apos;%str(hex(id(self))))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def f3():</span><br><span class="line">...     print(&quot;------0&quot;)</span><br><span class="line">...     c1=A()</span><br><span class="line">...     c2=A()</span><br><span class="line">...     print(&quot;------1&quot;)</span><br><span class="line">...     c1.t=c2</span><br><span class="line">...     c2.t=c1</span><br><span class="line">...     print(&quot;------2&quot;)</span><br><span class="line">...     del c1</span><br><span class="line">...     del c2</span><br><span class="line">...     print(&quot;------3&quot;)</span><br><span class="line">...     import gc</span><br><span class="line">...     print(gc.garbage)</span><br><span class="line">...     print(&quot;------4&quot;)</span><br><span class="line">...     print(gc.collect())</span><br><span class="line">...     print(&quot;------5&quot;)</span><br><span class="line">...     print(gc.garbage)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; import gc</span><br><span class="line">&gt;&gt;&gt; gc.set_debug(gc.DEBUG_LEAK)</span><br><span class="line">&gt;&gt;&gt; f3()</span><br><span class="line">------0</span><br><span class="line">object born 0x10e2cce10</span><br><span class="line">object born 0x10e2ccdd8</span><br><span class="line">------1</span><br><span class="line">------2</span><br><span class="line">------3</span><br><span class="line">[]</span><br><span class="line">------4</span><br><span class="line">gc: collectable &lt;A 0x10e2cce10&gt;</span><br><span class="line">gc: collectable &lt;A 0x10e2ccdd8&gt;</span><br><span class="line">gc: collectable &lt;dict 0x10e0dd708&gt;</span><br><span class="line">gc: collectable &lt;dict 0x10e0dd750&gt;</span><br><span class="line">gc: collectable &lt;cell 0x10e231618&gt;</span><br><span class="line">gc: collectable &lt;function 0x10e272400&gt;</span><br><span class="line">gc: collectable &lt;function 0x10e272598&gt;</span><br><span class="line">gc: collectable &lt;function 0x10e272488&gt;</span><br><span class="line">gc: collectable &lt;function 0x10e272620&gt;</span><br><span class="line">gc: collectable &lt;dict 0x10e23c3f0&gt;</span><br><span class="line">gc: collectable &lt;type 0x7fa09c049c18&gt;</span><br><span class="line">gc: collectable &lt;staticmethod 0x10e271278&gt;</span><br><span class="line">gc: collectable &lt;member_descriptor 0x10e263b88&gt;</span><br><span class="line">gc: collectable &lt;function 0x10e272378&gt;</span><br><span class="line">gc: collectable &lt;tuple 0x10e263bd0&gt;</span><br><span class="line">gc: collectable &lt;tuple 0x10e271208&gt;</span><br><span class="line">gc: collectable &lt;cell 0x10e231d38&gt;</span><br><span class="line">gc: collectable &lt;cell 0x10e231d08&gt;</span><br><span class="line">gc: collectable &lt;cell 0x10e2317f8&gt;</span><br><span class="line">gc: collectable &lt;function 0x10e272510&gt;</span><br><span class="line">gc: collectable &lt;set 0x10e253f28&gt;</span><br><span class="line">gc: collectable &lt;member_descriptor 0x10e263b40&gt;</span><br><span class="line">gc: collectable &lt;member_descriptor 0x10e23c510&gt;</span><br><span class="line">gc: collectable &lt;getset_descriptor 0x10e23c5a0&gt;</span><br><span class="line">gc: collectable &lt;getset_descriptor 0x10e21a900&gt;</span><br><span class="line">gc: collectable &lt;tuple 0x10e218788&gt;</span><br><span class="line">26</span><br><span class="line">------5</span><br><span class="line">[&lt;__main__.A object at 0x10e2cce10&gt;, &lt;__main__.A object at 0x10e2ccdd8&gt;, &#123;&apos;t&apos;: &lt;__main__.A object at 0x10e2ccdd8&gt;&#125;, &#123;&apos;t&apos;: &lt;__main__.A object at 0x10e2cce10&gt;&#125;, &lt;cell at 0x10e231618: type object at 0x7fa09c049c18&gt;, &lt;function partial.__call__ at 0x10e272400&gt;, &lt;function partial.__repr__ at 0x10e272598&gt;, &lt;function partial.__reduce__ at 0x10e272488&gt;, &lt;function partial.__setstate__ at 0x10e272620&gt;, &#123;&apos;__module__&apos;: &apos;functools&apos;, &apos;__doc__&apos;: &apos;New function with partial application of the given arguments\n    and keywords.\n    &apos;, &apos;__slots__&apos;: (&apos;func&apos;, &apos;args&apos;, &apos;keywords&apos;, &apos;__dict__&apos;, &apos;__weakref__&apos;), &apos;__new__&apos;: &lt;staticmethod object at 0x10e271278&gt;, &apos;__call__&apos;: &lt;function partial.__call__ at 0x10e272400&gt;, &apos;__repr__&apos;: &lt;function partial.__repr__ at 0x10e272598&gt;, &apos;__reduce__&apos;: &lt;function partial.__reduce__ at 0x10e272488&gt;, &apos;__setstate__&apos;: &lt;function partial.__setstate__ at 0x10e272620&gt;, &apos;args&apos;: &lt;member &apos;args&apos; of &apos;partial&apos; objects&gt;, &apos;func&apos;: &lt;member &apos;func&apos; of &apos;partial&apos; objects&gt;, &apos;keywords&apos;: &lt;member &apos;keywords&apos; of &apos;partial&apos; objects&gt;, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;partial&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;partial&apos; objects&gt;&#125;, &lt;class &apos;functools.partial&apos;&gt;, &lt;staticmethod object at 0x10e271278&gt;, &lt;member &apos;args&apos; of &apos;partial&apos; objects&gt;, &lt;function partial.__new__ at 0x10e272378&gt;, (&lt;cell at 0x10e2317f8: str object at 0x10e240c70&gt;, &lt;cell at 0x10e231d08: set object at 0x10e253f28&gt;, &lt;cell at 0x10e231d38: function object at 0x10e272510&gt;), (&lt;cell at 0x10e231618: type object at 0x7fa09c049c18&gt;,), &lt;cell at 0x10e231d38: function object at 0x10e272510&gt;, &lt;cell at 0x10e231d08: set object at 0x10e253f28&gt;, &lt;cell at 0x10e2317f8: str object at 0x10e240c70&gt;, &lt;function partial.__repr__ at 0x10e272510&gt;, set(), &lt;member &apos;func&apos; of &apos;partial&apos; objects&gt;, &lt;member &apos;keywords&apos; of &apos;partial&apos; objects&gt;, &lt;attribute &apos;__dict__&apos; of &apos;partial&apos; objects&gt;, &lt;attribute &apos;__weakref__&apos; of &apos;partial&apos; objects&gt;, (&lt;class &apos;functools.partial&apos;&gt;, &lt;class &apos;object&apos;&gt;)]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol>
<li>圾回收后的对象会放在gc.garbage列表里面</li>
<li>gc.collect()会返回不可达的对象数目，4等于两个对象以及它们对应的dict</li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的线程小结</title>
    <url>/2021/05/05/python%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def say_hello(name):</span><br><span class="line">    print(&quot;hello world! %d&quot; % name)</span><br><span class="line">    time.sleep(3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        say_hello(i)</span><br></pre></td></tr></table></figure>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def say_hello(name):</span><br><span class="line">    print(&quot;hello world! %d&quot; % name)</span><br><span class="line">    time.sleep(3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    t_list = []</span><br><span class="line">    for i in range(1000):</span><br><span class="line">        t = threading.Thread(target=say_hello, args=(i,))</span><br><span class="line">        t_list.append(t)</span><br><span class="line"></span><br><span class="line">    for t_thread in t_list:</span><br><span class="line">        t_thread.start()</span><br><span class="line"></span><br><span class="line">    for t_thread in t_list:</span><br><span class="line">        t_thread.join()</span><br><span class="line"></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    print(&quot;time used %0.2f&quot; % (end_time - start_time))</span><br></pre></td></tr></table></figure>
<h4 id="查看线程数量"><a href="#查看线程数量" class="headerlink" title="查看线程数量"></a>查看线程数量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">from time import sleep, ctime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def sing():</span><br><span class="line">    for i in range(3):</span><br><span class="line">        print(&quot;正在唱歌...%d&quot; % i)</span><br><span class="line">        sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dance():</span><br><span class="line">    for i in range(3):</span><br><span class="line">        print(&quot;正在跳舞...%d&quot; % i)</span><br><span class="line">        sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print(&apos;---开始---:&apos;, ctime())</span><br><span class="line"></span><br><span class="line">    t1 = threading.Thread(target=sing)</span><br><span class="line">    t2 = threading.Thread(target=dance)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        length = len(threading.enumerate())</span><br><span class="line">        print(&apos;当前运行的线程数为：%d&apos; % length)</span><br><span class="line">        if length &lt;= 1:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">        sleep(0.5)</span><br></pre></td></tr></table></figure>
<h4 id="线程执行代码的封装"><a href="#线程执行代码的封装" class="headerlink" title="线程执行代码的封装"></a>线程执行代码的封装</h4><p>通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承threading.Thread就可以了，然后重写run方法.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyThread(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        for i in range(5):</span><br><span class="line">            print(&quot;hello my custom thread %d&quot; % i)</span><br><span class="line">            sleep(5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<p>python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyThread(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        for i in range(3):</span><br><span class="line">            msg = &quot;I&apos;m &quot; + self.name + &apos; @ &apos; + str(i)</span><br><span class="line">            print(msg)</span><br><span class="line">            sleep(2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>
<p>从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。</p>
<ul>
<li>每个线程一定会有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。</li>
<li>当线程的run()方法结束时该线程完成。</li>
<li>无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</li>
<li>线程的几种状态</li>
</ul>
<p><img src="/2021/05/05/python中的线程小结/thread.png" alt="avatar"></p>
<h4 id="多线程-共享全局变量"><a href="#多线程-共享全局变量" class="headerlink" title="多线程-共享全局变量"></a>多线程-共享全局变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        global num</span><br><span class="line">        num += 1</span><br><span class="line">        print(&quot;I&apos;m &quot; + self.name + &apos; @ &apos; + str(i) + &apos;num=&apos; + str(num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p><strong>多线程开发可能遇到的问题</strong></p>
<p>假设两个线程t1和t2都要对num=0进行增1运算，t1和t2都各对num修改10次，num的最终的结果应该为20。</p>
<p>但是由于是多线程访问，有可能出现下面情况：</p>
<p>在num=0时，t1取得num=0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得num=0。然后t2对得到的值进行加1并赋给num，使得num=1。然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给num。这样，明明t1和t2都完成了1次加1工作，但结果仍然是num=1。</p>
<p><strong>什么是同步</strong></p>
<p>如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行;B依言执行，再将结果给A;A再继续操作。    </p>
<p><strong>解决问题的思路</strong></p>
<ol>
<li>系统调用t1，然后获取到num的值为0，此时上一把锁，即不允许其他现在操作num</li>
<li>对num的值进行+1</li>
<li>解锁，此时num的值为1，其他的线程就可以使用num了，而且是num的值不是0而是1</li>
<li>同理其他线程在对num进行修改时，都要先上锁，处理完后再解锁，在上锁的整个过程中不允许其他线程访问，就保证了数据的正确性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">num = 0</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        global num</span><br><span class="line"></span><br><span class="line">        num = num + 1</span><br><span class="line">        time.sleep(0.5)  # 用来模拟适当的数据处理</span><br><span class="line">        print(self.name + &apos; set num to &apos; + str(num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>
<p>问题产生的原因就是没有控制多个线程对同一资源的访问，对数据造成破坏，使得线程运行的结果不可预期。这种现象称为“线程不安全”。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p><strong>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制</strong></p>
<p>线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。</p>
<p>互斥锁为资源引入一个状态：锁定/非锁定。</p>
<p>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建锁</span><br><span class="line">mutex = threading.Lock()</span><br><span class="line">#锁定</span><br><span class="line">mutex.acquire([blocking])</span><br><span class="line">#释放</span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure></p>
<p>其中，锁定方法acquire可以有一个blocking参数。</p>
<ul>
<li>如果设定blocking为True，则当前线程会堵塞，直到获取到这个锁为止（如果没有指定，那么默认为True）</li>
<li>如果设定blocking为False，则当前线程不会堵塞</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">num = 0</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        global num</span><br><span class="line">        mutex_flag = lock.acquire(True)  # True表示堵塞</span><br><span class="line">        print(&apos;---线程(%s)的锁状态为%d---&apos; % (self.name, mutex_flag))</span><br><span class="line">        if mutex_flag:</span><br><span class="line">            num = num + 1</span><br><span class="line">            time.sleep(0.5)  # 用来模拟适当的数据处理</span><br><span class="line">            print(self.name + &apos; set num to &apos; + str(num))</span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>
<p><strong>上锁解锁过程</strong></p>
<p>当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。</p>
<p>每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。</p>
<p>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。</p>
<p><strong>优势和劣势对比</strong></p>
<p>锁的好处：</p>
<p>确保了某段关键代码只能由一个线程从头到尾完整地执行</p>
<p>锁的坏处：</p>
<p>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了<br>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</p>
<h4 id="多线程-非共享数据"><a href="#多线程-非共享数据" class="headerlink" title="多线程-非共享数据"></a>多线程-非共享数据</h4><p>在多线程开发中，全局变量是多个线程都共享的数据，而局部变量等是各自线程的，是非共享的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def __init__(self, num, sleep_time):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.num = num</span><br><span class="line">        self.sleep_time = sleep_time</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        self.num += 1</span><br><span class="line">        time.sleep(self.sleep_time)</span><br><span class="line">        print(&apos;线程(%s),num=%d&apos; % (self.name, self.num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    mutex = threading.Lock()</span><br><span class="line">    t1 = MyThread(100, 5)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2 = MyThread(200, 1)</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">lock_a = threading.Lock()</span><br><span class="line">lock_b = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread1(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        with lock_a:</span><br><span class="line">            print(self.name + &apos;----do1---up----&apos;)</span><br><span class="line">            time.sleep(1)</span><br><span class="line">            with lock_b:</span><br><span class="line">                print(self.name + &apos;----do1---down----&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread2(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        with lock_b:</span><br><span class="line">            print(self.name + &apos;----do2---up----&apos;)</span><br><span class="line">            time.sleep(1)</span><br><span class="line">            with lock_a:</span><br><span class="line">                print(self.name + &apos;----do2---down----&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    t1 = MyThread1()</span><br><span class="line">    t2 = MyThread2()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>
<h4 id="同步应用"><a href="#同步应用" class="headerlink" title="同步应用"></a>同步应用</h4><p>可以使用互斥锁完成多个任务，有序的进程工作，这就是线程的同步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">lock_a = threading.Lock()</span><br><span class="line">lock_b = threading.Lock()</span><br><span class="line">lock_b.acquire()</span><br><span class="line">lock_c = threading.Lock()</span><br><span class="line">lock_c.acquire()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TaskA(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            if lock_a.acquire():</span><br><span class="line">                print(&quot;-----Task A------&quot;)</span><br><span class="line">                time.sleep(1)</span><br><span class="line">                lock_b.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TaskB(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            if lock_b.acquire():</span><br><span class="line">                print(&quot;-----Task B------&quot;)</span><br><span class="line">                time.sleep(1)</span><br><span class="line">                lock_c.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TaskC(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            if lock_c.acquire():</span><br><span class="line">                print(&quot;-----Task C------&quot;)</span><br><span class="line">                time.sleep(1)</span><br><span class="line">                lock_a.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = TaskA()</span><br><span class="line">b = TaskB()</span><br><span class="line">c = TaskC()</span><br><span class="line"></span><br><span class="line">a.start()</span><br><span class="line">b.start()</span><br><span class="line">c.start()</span><br></pre></td></tr></table></figure>
<h4 id="线程同步之条件变量"><a href="#线程同步之条件变量" class="headerlink" title="线程同步之条件变量"></a>线程同步之条件变量</h4><p>互斥锁是最简单的线程同步机制，Python提供的Condition对象提供了对复杂线程同步问题的支持。</p>
<p>Condition被称为条件变量，除了提供与Lock类似的acquire和release方法外，还提供了wait和notify方法。</p>
<p>线程首先acquire一个条件变量，然后判断一些条件。</p>
<ul>
<li>如果条件不满足则wait；</li>
<li>如果条件满足，进行一些处理改变条件后，通过notify方法通知其他线程，其他处于wait状态的线程接到通知后会重新判断条件。不断的重复这一过程，从而解决复杂的同步问题。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from click._compat import raw_input</span><br><span class="line"></span><br><span class="line">con = threading.Condition()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            if con.acquire():</span><br><span class="line">                print(&apos;---A---1---&apos;)</span><br><span class="line">                con.wait()</span><br><span class="line">                print(&apos;---A---2---&apos;)</span><br><span class="line">                con.release()</span><br><span class="line">                time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            if con.acquire():</span><br><span class="line">                raw_input(&apos;输入任意字符:&apos;)</span><br><span class="line">                con.notify()</span><br><span class="line">                con.release()</span><br><span class="line">                time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    a = A()</span><br><span class="line">    a.start()</span><br><span class="line"></span><br><span class="line">    b = B()</span><br><span class="line">    b.start()</span><br></pre></td></tr></table></figure>
<p>可以认为Condition对象维护了一个锁（Lock/RLock)和一个waiting池。线程通过acquire获得Condition对象，当调用wait方法时，线程会释放Condition内部的锁并进入blocked状态，同时在waiting池中记录这个线程。当调用notify方法时，Condition对象会从waiting池中挑选一个线程，通知其调用acquire方法尝试取到锁。</p>
<p>Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。</p>
<p>除了notify方法外，Condition对象还提供了notifyAll方法，可以通知waiting池中的所有线程尝试acquire内部锁。由于上述机制，处于waiting状态的线程只能通过notify方法唤醒，所以notifyAll的作用在于防止有线程永远处于沉默状态。</p>
<h4 id="生产者与消费者-条件变量"><a href="#生产者与消费者-条件变量" class="headerlink" title="生产者与消费者-条件变量"></a>生产者与消费者-条件变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def __init__(self, func, args=()):</span><br><span class="line">        super(threading.Thread.__init__(self))</span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        self.result = self.func(*self.args)</span><br><span class="line"></span><br><span class="line">    def get_result(self):</span><br><span class="line">        try:</span><br><span class="line">            return self.result</span><br><span class="line">        except:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Producer(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        global count</span><br><span class="line"></span><br><span class="line">        while True:</span><br><span class="line">            if con.acquire():</span><br><span class="line">                if count &gt; 1000:</span><br><span class="line">                    con.wait()</span><br><span class="line">                else:</span><br><span class="line">                    count += 100</span><br><span class="line">                    print(self.name + &apos; produce 100, count=&apos; + str(count))</span><br><span class="line">                    con.notify()</span><br><span class="line">                con.release()</span><br><span class="line">            time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Consumer(threading.Thread):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        global count</span><br><span class="line"></span><br><span class="line">        while True:</span><br><span class="line">            if con.acquire():</span><br><span class="line">                if count &lt; 100:</span><br><span class="line">                    con.wait()</span><br><span class="line">                else:</span><br><span class="line">                    count -= 50</span><br><span class="line">                    print(self.name + &apos; consume 50, count=&apos; + str(count))</span><br><span class="line">                    con.notify()</span><br><span class="line">                con.release()</span><br><span class="line">            time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    count = 500</span><br><span class="line">    con = threading.Condition()</span><br><span class="line"></span><br><span class="line">    for i in range(2):</span><br><span class="line">        p = Producer()</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    for i in range(5):</span><br><span class="line">        c = Consumer()</span><br><span class="line">        c.start()</span><br></pre></td></tr></table></figure>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</p>
<p>可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。</p>
<p>ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">local_test = threading.local()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">    print(&quot;Hello world %s in thread %s &quot; % (local_test.name, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def process_param(name):</span><br><span class="line">    local_test.name = name</span><br><span class="line">    show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    t1 = threading.Thread(target=process_param, args=(&quot;A name&quot;,), name=&quot;ThreadA&quot;)</span><br><span class="line">    t2 = threading.Thread(target=process_param, args=(&quot;B name&quot;,), name=&quot;ThreadB&quot;)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。</p>
<p>此外，使用线程池可以有效地控制系统中并发线程的数量。当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至导致 Python 解释器崩溃，而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数。</p>
<p>线程池的基类是 concurrent.futures 模块中的 Executor，Executor 提供了两个子类，即 ThreadPoolExecutor 和 ProcessPoolExecutor，其中 ThreadPoolExecutor 用于创建线程池，而 ProcessPoolExecutor 用于创建进程池。</p>
<p>如果使用线程池/进程池来管理并发编程，那么只要将相应的 task 函数提交给线程池/进程池，剩下的事情就由线程池/进程池来搞定。</p>
<p>Executor 提供了如下常用方法：</p>
<ul>
<li>submit(fn, <em>args, **kwargs)：将 fn 函数提交给线程池。</em>args 代表传给 fn 函数的参数，*kwargs 代表以关键字参数的形式为 fn 函数传入参数。</li>
<li>map(func, <em>iterables, timeout=None, chunksize=1)：该函数类似于全局函数 map(func, </em>iterables)，只是该函数将会启动多个线程，以异步方式立即对 iterables 执行 map 处理。</li>
<li>shutdown(wait=True)：关闭线程池。</li>
</ul>
<p>程序将 task 函数提交（submit）给线程池后，submit 方法会返回一个 Future 对象，Future 类主要用于获取线程任务函数的返回值。由于线程任务会在新线程中以异步方式执行，因此，线程执行的函数相当于一个“将来完成”的任务，所以 Python 使用 Future 来代表。</p>
<p>Future 提供了如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cancel()：取消该 Future 代表的线程任务。如果该任务正在执行，不可取消，则该方法返回 False；否则，程序会取消该任务，并返回 True。</span><br><span class="line">cancelled()：返回 Future 代表的线程任务是否被成功取消。</span><br><span class="line">running()：如果该 Future 代表的线程任务正在执行、不可被取消，该方法返回 True。</span><br><span class="line">done()：如果该 Funture 代表的线程任务被成功取消或执行完成，则该方法返回 True。</span><br><span class="line">result(timeout=None)：获取该 Future 代表的线程任务最后返回的结果。如果 Future 代表的线程任务还未完成，该方法将会阻塞当前线程，其中 timeout 参数指定最多阻塞多少秒。</span><br><span class="line">exception(timeout=None)：获取该 Future 代表的线程任务所引发的异常。如果该任务成功完成，没有异常，则该方法返回 None。</span><br><span class="line">add_done_callback(fn)：为该 Future 代表的线程任务注册一个“回调函数”，当该任务成功完成时，程序会自动触发该 fn 函数。</span><br></pre></td></tr></table></figure>
<p>在用完一个线程池后，应该调用该线程池的 shutdown() 方法，该方法将启动线程池的关闭序列。调用 shutdown() 方法后的线程池不再接收新任务，但会将以前所有的已提交任务执行完成。当线程池中的所有任务都执行完成后，该线程池中的所有线程都会死亡。</p>
<p>使用线程池来执行线程任务的步骤如下：</p>
<ol>
<li>调用 ThreadPoolExecutor 类的构造器创建一个线程池。</li>
<li>定义一个普通函数作为线程任务。</li>
<li>调用 ThreadPoolExecutor 对象的 submit() 方法来提交线程任务。</li>
<li>当不想提交任何任务时，调用 ThreadPoolExecutor 对象的 shutdown() 方法来关闭线程池。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"># 定义一个准备作为线程任务的函数</span><br><span class="line">def action(max):</span><br><span class="line">    my_sum = 0</span><br><span class="line">    for i in range(max):</span><br><span class="line">        print(threading.current_thread().name + &apos;  &apos; + str(i))</span><br><span class="line">        my_sum += i</span><br><span class="line">    return my_sum</span><br><span class="line"># 创建一个包含2条线程的线程池</span><br><span class="line">pool = ThreadPoolExecutor(max_workers=2)</span><br><span class="line"># 向线程池提交一个task, 50会作为action()函数的参数</span><br><span class="line">future1 = pool.submit(action, 50)</span><br><span class="line"># 向线程池再提交一个task, 100会作为action()函数的参数</span><br><span class="line">future2 = pool.submit(action, 100)</span><br><span class="line"># 判断future1代表的任务是否结束</span><br><span class="line">print(future1.done())</span><br><span class="line">time.sleep(3)</span><br><span class="line"># 判断future2代表的任务是否结束</span><br><span class="line">print(future2.done())</span><br><span class="line"># 查看future1代表的任务返回的结果</span><br><span class="line">print(future1.result())</span><br><span class="line"># 查看future2代表的任务返回的结果</span><br><span class="line">print(future2.result())</span><br><span class="line"># 关闭线程池</span><br><span class="line">pool.shutdown()</span><br></pre></td></tr></table></figure>
<p>如果程序不希望直接调用 result() 方法阻塞线程，则可通过 Future 的 add_done_callback() 方法来添加回调函数，该回调函数形如 fn(future)。当线程任务完成后，程序会自动触发该回调函数，并将对应的 Future 对象作为参数传给该回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"># 定义一个准备作为线程任务的函数</span><br><span class="line">def action(max):</span><br><span class="line">    my_sum = 0</span><br><span class="line">    for i in range(max):</span><br><span class="line">        print(threading.current_thread().name + &apos;  &apos; + str(i))</span><br><span class="line">        my_sum += i</span><br><span class="line">    return my_sum</span><br><span class="line"># 创建一个包含2条线程的线程池</span><br><span class="line">with ThreadPoolExecutor(max_workers=2) as pool:</span><br><span class="line">    # 向线程池提交一个task, 50会作为action()函数的参数</span><br><span class="line">    future1 = pool.submit(action, 50)</span><br><span class="line">    # 向线程池再提交一个task, 100会作为action()函数的参数</span><br><span class="line">    future2 = pool.submit(action, 100)</span><br><span class="line">    def get_result(future):</span><br><span class="line">        print(future.result())</span><br><span class="line">    # 为future1添加线程完成的回调函数</span><br><span class="line">    future1.add_done_callback(get_result)</span><br><span class="line">    # 为future2添加线程完成的回调函数</span><br><span class="line">    future2.add_done_callback(get_result)</span><br><span class="line">    print(&apos;--------------&apos;)</span><br></pre></td></tr></table></figure>
<p>此外，Exectuor 还提供了一个 map(func, *iterables, timeout=None, chunksize=1) 方法，该方法的功能类似于全局函数 map()，区别在于线程池的 map() 方法会为 iterables 的每个元素启动一个线程，以并发方式来执行 func 函数。这种方式相当于启动 len(iterables) 个线程，井收集每个线程的执行结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"># 定义一个准备作为线程任务的函数</span><br><span class="line">def action(max):</span><br><span class="line">    my_sum = 0</span><br><span class="line">    for i in range(max):</span><br><span class="line">        print(threading.current_thread().name + &apos;  &apos; + str(i))</span><br><span class="line">        my_sum += i</span><br><span class="line">    return my_sum</span><br><span class="line"># 创建一个包含4条线程的线程池</span><br><span class="line">with ThreadPoolExecutor(max_workers=4) as pool:</span><br><span class="line">    # 使用线程执行map计算</span><br><span class="line">    # 后面元组有3个元素，因此程序启动3条线程来执行action函数</span><br><span class="line">    results = pool.map(action, (50, 100, 150))</span><br><span class="line">    print(&apos;--------------&apos;)</span><br><span class="line">    for r in results:</span><br><span class="line">        print(r)</span><br></pre></td></tr></table></figure>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol>
<li><a href="http://c.biancheng.net/view/2630.html" target="_blank" rel="noopener">http://c.biancheng.net/view/2630.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的面向对象</title>
    <url>/2020/09/14/python%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>在至今我们编写的所有程序中，我们曾围绕函数设计我们的程序，也就是那些能够处理数据的代码块。这被称作面向过程（Procedure-oriented）的编程方式。还有另外一种组织起你的程序的方式，它将数据与功能进行组合，并将其包装在被称作“对象”的东西内。在大多数情况下，你可以使用过程式编程，但是当你需要编写一个大型程序或面对某一更适合此方法的问题时，你可以考虑使用面向对象式的编程技术。</p>
<p>类与对象是面向对象编程的两个主要方面。一个类（Class）能够创建一种新的类型（Type），其中对象（Object）就是类的实例（Instance）。可以这样来类比：你可以拥有类型 int 的变量，也就是说存储整数的变量是 int 类的实例（对象）。</p>
<blockquote>
<p>针对静态编程语言程序员的提示<br>请注意，即使是整数也会被视为对象（int 类的对象）。这不同于 C++ 与 Java（1.5 版之前），在它们那儿整数是原始内置类型。1<br>有关类的更多详细信息，请参阅 help(int)。<br>C# 与 Java 1.5 程序员会发现这与装箱与拆箱（Boxing and Unboxing）概念2颇有相似之处。</p>
</blockquote>
<p>对象可以使用属于它的普通变量来存储数据。这种从属于对象或类的变量叫作字段（Field）。对象还可以使用属于类的函数来实现某些功能，这种函数叫作类的方法（Method）。这两个术语很重要，它有助于我们区分函数与变量，哪些是独立的，哪些又是属于类或对象的。总之，字段与方法通称类的属性（Attribute）。</p>
<p>字段有两种类型——它们属于某一类的各个实例或对象，或是从属于某一类本身。它们被分别称作实例变量（Instance Variables）与类变量（Class Variables）。</p>
<p>通过 class 关键字可以创建一个类。这个类的字段与方法可以在缩进代码块中予以列出。</p>
<h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><p>类方法与普通函数只有一种特定的区别——前者必须多加一个参数在参数列表开头，这个名字必须添加到参数列表的开头，但是你不用在你调用这个功能时为这个参数赋值，Python 会为它提供。这种特定的变量引用的是对象本身，按照惯例，它被赋予 self 这一名称。</p>
<p>尽管你可以为这一参数赋予任何名称，但是强烈推荐你使用 self 这一名称——其它的任何一种名称绝对会引人皱眉。使用一个标准名称能带来诸多好处——任何一位你的程序的读者能够立即认出它，甚至是专门的 IDE（Integrated Development Environments，集成开发环境）也可以为你提供帮助，只要你使用了 self 这一名称。</p>
<blockquote>
<p>针对 C++/Java/C# 程序员的提示<br>Python 中的 self 相当于 C++ 中的 this 指针以及 Java 与 C# 中的 this 引用。</p>
</blockquote>
<p>你一定会在想 Python 是如何给 self 赋值的，以及为什么你不必给它一个值。一个例子或许会让这些疑问得到解答。假设你有一个 MyClass 的类，这个类下有一个实例 myobject。当你调用一个这个对象的方法，如 myobject.method(arg1, arg2) 时，Python 将会自动将其转换成 MyClass.method(myobject, arg1, arg2)——这就是 self 的全部特殊之处所在。</p>
<p>这同时意味着，如果你有一个没有参数的方法，你依旧必须拥有一个参数——self。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>最简单的类（Class）可以通过下面的案例来展示（保存为 oop_simplestclass.py）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    pass  # 一个空的代码块</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">$ python oop_simplestclass.py</span><br><span class="line">&lt;__main__.Person instance at 0x10171f518&gt;</span><br></pre></td></tr></table></figure>
<p>我们通过使用 class 语句与这个类的名称来创建一个新类。在它之后是一个缩进的语句块，代表这个类的主体。在本案例中，我们创建的是一个空代码块，使用 pass 语句予以标明。</p>
<p>然后，我们通过采用类的名称后跟一对括号的方法，给这个类创建一个对象（或是实例，我们将在后面的章节中了解有关实例的更多内容）。为了验证我们的操作是否成功，我们通过直接将它们打印出来来确认变量的类型。结果告诉我们我们在 Person 类的 <strong>main</strong> 模块中拥有了一个实例。</p>
<p>要注意到在本例中还会打印出计算机内存中存储你的对象的地址。案例中给出的地址会与你在你的电脑上所能看见的地址不相同，因为 Python 会在它找到的任何空间来存储对象。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>我们已经在前面讨论过类与对象一如函数那般都可以带有方法（Method），唯一的不同在于我们还拥有一个额外的 self 变量。现在让我们来看看下面的例子（保存为 oop_method.py）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def say_hi(self):</span><br><span class="line">        print(&apos;Hello, how are you?&apos;)</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">p.say_hi()</span><br><span class="line"># 前面两行同样可以写作</span><br><span class="line"># Person().say_hi()</span><br><span class="line"></span><br><span class="line">$ python oop_method.py</span><br><span class="line">Hello, how are you?</span><br></pre></td></tr></table></figure>
<p>这里我们就能看见 self 是如何行动的了。要注意到 say_hi 这一方法不需要参数，但是依旧在函数定义中拥有 self 变量。</p>
<h2 id="init-方法"><a href="#init-方法" class="headerlink" title="init 方法"></a><strong>init</strong> 方法</h2><p>在 Python 的类中，有不少方法的名称具有着特殊的意义。现在我们要了解的就是 <strong>init</strong> 方法的意义。</p>
<p><strong>init</strong> 方法会在类的对象被实例化（Instantiated）时立即运行。这一方法可以对任何你想进行操作的目标对象进行初始化（Initialization）操作。这里你要注意在 init 前后加上的双下划线。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def say_hi(self):</span><br><span class="line">        print(&apos;Hello, my name is&apos;, self.name)</span><br><span class="line"></span><br><span class="line">p = Person(&apos;Swaroop&apos;)</span><br><span class="line">p.say_hi()</span><br><span class="line"># 前面两行同时也能写作</span><br><span class="line"># Person(&apos;Swaroop&apos;).say_hi()</span><br><span class="line"></span><br><span class="line">$ python oop_init.py</span><br><span class="line">Hello, my name is Swaroop</span><br></pre></td></tr></table></figure>
<p>在本例中，我们定义一个接受 name 参数（当然还有 self 参数）的 <strong>init</strong> 方法。在这里，我们创建了一个字段，同样称为 name。要注意到尽管它们的名字都是“name”，但这是两个不相同的变量。虽说如此，但这并不会造成任何问题，因为 self.name 中的点号意味着这个叫作“name”的东西是某个叫作“self”的对象的一部分，而另一个 name 则是一个局部变量。由于我们已经如上这般明确指出了我们所指的是哪一个名字，所以它不会引发混乱。</p>
<p>当我们在 Person 类下创建新的实例 p 时，我们采用的方法是先写下类的名称，后跟括在括号中的参数，形如：p = Person(‘Swaroop’)。</p>
<p>我们不会显式地调用 <strong>init</strong> 方法。 这正是这个方法的特殊之处所在。</p>
<p>现在，我们可以使用我们方法中的 self.name 字段了，使用的方法在 say_hi 方法中已经作过说明。</p>
<h2 id="类变量与对象变量"><a href="#类变量与对象变量" class="headerlink" title="类变量与对象变量"></a>类变量与对象变量</h2><p>我们已经讨论过了类与对象的功能部分（即方法），现在让我们来学习它们的数据部分。数据部分——也就是字段——只不过是绑定（Bound）到类与对象的命名空间（Namespace）的普通变量。这就代表着这些名称仅在这些类与对象所存在的上下文中有效。这就是它们被称作“命名空间”的原因。</p>
<p>字段（Field）有两种类型——类变量与对象变量，它们根据究竟是类还是对象拥有这些变量来进行分类。</p>
<p>类变量（Class Variable）是共享的（Shared）——它们可以被属于该类的所有实例访问。该类变量只拥有一个副本，当任何一个对象对类变量作出改变时，发生的变动将在其它所有实例中都会得到体现。</p>
<p>对象变量（Object variable）由类的每一个独立的对象或实例所拥有。在这种情况下，每个对象都拥有属于它自己的字段的副本，也就是说，它们不会被共享，也不会以任何方式与其它不同实例中的相同名称的字段产生关联。下面一个例子可以帮助你理解（保存为 oop_objvar.py）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding=UTF-8</span><br><span class="line"></span><br><span class="line">class Robot:</span><br><span class="line">    &quot;&quot;&quot;表示有一个带有名字的机器人。&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 一个类变量，用来计数机器人的数量</span><br><span class="line">    population = 0</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        &quot;&quot;&quot;初始化数据&quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        print(&quot;(Initializing &#123;&#125;)&quot;.format(self.name))</span><br><span class="line"></span><br><span class="line">        # 当有人被创建时，机器人</span><br><span class="line">        # 将会增加人口数量</span><br><span class="line">        Robot.population += 1</span><br><span class="line"></span><br><span class="line">    def die(self):</span><br><span class="line">        &quot;&quot;&quot;我挂了。&quot;&quot;&quot;</span><br><span class="line">        print(&quot;&#123;&#125; is being destroyed!&quot;.format(self.name))</span><br><span class="line"></span><br><span class="line">        Robot.population -= 1</span><br><span class="line"></span><br><span class="line">        if Robot.population == 0:</span><br><span class="line">            print(&quot;&#123;&#125; was the last one.&quot;.format(self.name))</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;There are still &#123;:d&#125; robots working.&quot;.format(</span><br><span class="line">                Robot.population))</span><br><span class="line"></span><br><span class="line">    def say_hi(self):</span><br><span class="line">        &quot;&quot;&quot;来自机器人的诚挚问候</span><br><span class="line"></span><br><span class="line">        没问题，你做得到。&quot;&quot;&quot;</span><br><span class="line">        print(&quot;Greetings, my masters call me &#123;&#125;.&quot;.format(self.name))</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def how_many(cls):</span><br><span class="line">        &quot;&quot;&quot;打印出当前的人口数量&quot;&quot;&quot;</span><br><span class="line">        print(&quot;We have &#123;:d&#125; robots.&quot;.format(cls.population))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">droid1 = Robot(&quot;R2-D2&quot;)</span><br><span class="line">droid1.say_hi()</span><br><span class="line">Robot.how_many()</span><br><span class="line"></span><br><span class="line">droid2 = Robot(&quot;C-3PO&quot;)</span><br><span class="line">droid2.say_hi()</span><br><span class="line">Robot.how_many()</span><br><span class="line"></span><br><span class="line">print(&quot;\nRobots can do some work here.\n&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;Robots have finished their work. So let&apos;s destroy them.&quot;)</span><br><span class="line">droid1.die()</span><br><span class="line">droid2.die()</span><br><span class="line"></span><br><span class="line">Robot.how_many()</span><br><span class="line"></span><br><span class="line">$ python oop_objvar.py</span><br><span class="line">(Initializing R2-D2)</span><br><span class="line">Greetings, my masters call me R2-D2.</span><br><span class="line">We have 1 robots.</span><br><span class="line">(Initializing C-3PO)</span><br><span class="line">Greetings, my masters call me C-3PO.</span><br><span class="line">We have 2 robots.</span><br><span class="line"></span><br><span class="line">Robots can do some work here.</span><br><span class="line"></span><br><span class="line">Robots have finished their work. So let&apos;s destroy them.</span><br><span class="line">R2-D2 is being destroyed!</span><br><span class="line">There are still 1 robots working.</span><br><span class="line">C-3PO is being destroyed!</span><br><span class="line">C-3PO was the last one.</span><br><span class="line">We have 0 robots.</span><br></pre></td></tr></table></figure>
<p>这是一个比较长的案例，但是它有助于展现类与对象变量的本质。在本例中，population 属于 Robot 类，因此它是一个类变量。name 变量属于一个对象（通过使用 self 分配），因此它是一个对象变量。</p>
<p>因此，我们通过 Robot.population 而非 self.population 引用 population 类变量。我们对于 name 对象变量采用 self.name 标记法加以称呼，这是这个对象中所具有的方法。要记住这个类变量与对象变量之间的简单区别。同时你还要注意当一个对象变量与一个类变量名称相同时，类变量将会被隐藏。</p>
<p>除了 Robot.popluation，我们还可以使用 self.<strong>class</strong>.population，因为每个对象都通过 self.<strong>class</strong> 属性来引用它的类。</p>
<p>how_many 实际上是一个属于类而非属于对象的方法。这就意味着我们可以将它定义为一个 classmethod（类方法） 或是一个 staticmethod（静态方法），这取决于我们是否需要知道这一方法属于哪个类。由于我们已经引用了一个类变量，因此我们使用 classmethod（类方法）。</p>
<p>我们使用装饰器（Decorator）将 how_many 方法标记为类方法。</p>
<p>你可以将装饰器想象为调用一个包装器（Wrapper）函数的快捷方式，因此启用 @classmethod 装饰器等价于调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">how_many = classmethod(how_many)</span><br></pre></td></tr></table></figure>
<p>你会观察到 <strong>init</strong> 方法会使用一个名字以初始化 Robot 实例。在这一方法中，我们将 population 按 1 往上增长，因为我们多增加了一台机器人。你还会观察到 self.name 的值是指定给每个对象的，这体现了对象变量的本质。</p>
<p>你需要记住你只能使用 self 来引用同一对象的变量与方法。这被称作属性引用（Attribute Reference）。</p>
<p>在本程序中，我们还会看见针对类和方法的 文档字符串（DocStrings） 的使用方式。我们可以在运行时通过 Robot.<strong>doc</strong> 访问类的 文档字符串，对于方法的文档字符串，则可以使用 Robot.say_hi.<strong>doc</strong>。</p>
<p>在 die 方法中，我们简单地将 Robot.population 的计数按 1 向下减少。</p>
<p>所有的类成员都是公开的。但有一个例外：如果你使用数据成员并在其名字中使用双下划线作为前缀，形成诸如 __privatevar 这样的形式，Python 会使用名称调整（Name-mangling）来使其有效地成为一个私有变量。</p>
<p>因此，你需要遵循这样的约定：任何在类或对象之中使用的变量其命名应以下划线开头，其它所有非此格式的名称都将是公开的，并可以为其它任何类或对象所使用。请记得这只是一个约定，Python 并不强制如此（除了双下划线前缀这点）。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象编程的一大优点是对代码的重用（Reuse），重用的一种实现方法就是通过继承（Inheritance）机制。继承最好是想象成在类之间实现类型与子类型（Type and Subtype）关系的工具。</p>
<p>现在假设你希望编写一款程序来追踪一所大学里的老师和学生。有一些特征是他们都具有的，例如姓名、年龄和地址。另外一些特征是他们独有的，一如教师的薪水、课程与假期，学生的成绩和学费。</p>
<p>你可以为每一种类型创建两个独立的类，并对它们进行处理。但增添一条共有特征就意味着将其添加进两个独立的类。这很快就会使程序变得笨重。</p>
<p>一个更好的方法是创建一个公共类叫作 SchoolMember，然后让教师和学生从这个类中继承（Inherit），也就是说他们将成为这一类型（类）的子类型，而我们就可以向这些子类型中添加某些该类独有的特征。</p>
<p>这种方法有诸多优点。如果我们增加或修改了 SchoolMember 的任何功能，它将自动反映在子类型中。举个例子，你可以通过简单地向 SchoolMember 类进行操作，来为所有老师与学生添加一条新的 ID 卡字段。不过，对某一子类型作出的改动并不会影响到其它子类型。另一大优点是你可以将某一老师或学生对象看作 SchoolMember 的对象并加以引用，这在某些情况下会大为有用，例如清点学校中的成员数量。这被称作多态性（Polymorphism），在任何情况下，如果父类型希望，子类型都可以被替换，也就是说，该对象可以被看作父类的实例。</p>
<p>同时还需要注意的是我们重用父类的代码，但我们不需要再在其它类中重复它们，当我们使用独立类型时才会必要地重复这些代码。</p>
<p>在上文设想的情况中，SchoolMember 类会被称作基类（Base Class）4或是超类（Superclass）。Teacher 和 Student 类会被称作派生类（Derived Classes）5或是子类（Subclass）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding=UTF-8</span><br><span class="line"></span><br><span class="line">class SchoolMember:</span><br><span class="line">    &apos;&apos;&apos;代表任何学校里的成员。&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        print(&apos;(Initialized SchoolMember: &#123;&#125;)&apos;.format(self.name))</span><br><span class="line"></span><br><span class="line">    def tell(self):</span><br><span class="line">        &apos;&apos;&apos;告诉我有关我的细节。&apos;&apos;&apos;</span><br><span class="line">        print(&apos;Name:&quot;&#123;&#125;&quot; Age:&quot;&#123;&#125;&quot;&apos;.format(self.name, self.age), end=&quot; &quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Teacher(SchoolMember):</span><br><span class="line">    &apos;&apos;&apos;代表一位老师。&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, name, age, salary):</span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.salary = salary</span><br><span class="line">        print(&apos;(Initialized Teacher: &#123;&#125;)&apos;.format(self.name))</span><br><span class="line"></span><br><span class="line">    def tell(self):</span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        print(&apos;Salary: &quot;&#123;:d&#125;&quot;&apos;.format(self.salary))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Student(SchoolMember):</span><br><span class="line">    &apos;&apos;&apos;代表一位学生。&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, name, age, marks):</span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.marks = marks</span><br><span class="line">        print(&apos;(Initialized Student: &#123;&#125;)&apos;.format(self.name))</span><br><span class="line"></span><br><span class="line">    def tell(self):</span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        print(&apos;Marks: &quot;&#123;:d&#125;&quot;&apos;.format(self.marks))</span><br><span class="line"></span><br><span class="line">t = Teacher(&apos;Mrs. Shrividya&apos;, 40, 30000)</span><br><span class="line">s = Student(&apos;Swaroop&apos;, 25, 75)</span><br><span class="line"></span><br><span class="line"># 打印一行空白行</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">members = [t, s]</span><br><span class="line">for member in members:</span><br><span class="line">    # 对全体师生工作</span><br><span class="line">    member.tell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python oop_subclass.py</span><br><span class="line">(Initialized SchoolMember: Mrs. Shrividya)</span><br><span class="line">(Initialized Teacher: Mrs. Shrividya)</span><br><span class="line">(Initialized SchoolMember: Swaroop)</span><br><span class="line">(Initialized Student: Swaroop)</span><br><span class="line"></span><br><span class="line">Name:&quot;Mrs. Shrividya&quot; Age:&quot;40&quot; Salary: &quot;30000&quot;</span><br><span class="line">Name:&quot;Swaroop&quot; Age:&quot;25&quot; Marks: &quot;75&quot;</span><br></pre></td></tr></table></figure>
<p>要想使用继承，在定义类6时我们需要在类后面跟一个包含基类名称的元组。然后，我们会注意到基类的 <strong>init</strong> 方法是通过 self 变量被显式调用的，因此我们可以初始化对象的基类部分。下面这一点很重要，需要牢记——因为我们在 Teacher 和 Student 子类中定义了 <strong>init</strong> 方法，Python 不会自动调用基类 SchoolMember 的构造函数，你必须自己显式地调用它。</p>
<p>相反，如果我们没有在一个子类中定义一个 <strong>init</strong> 方法，Python 将会自动调用基类的构造函数。</p>
<p>我们会观察到，我们可以通过在方法名前面加上基类名作为前缀，再传入 self 和其余变量，来调用基类的方法。</p>
<p>在这里你需要注意，当我们使用 SchoolMember 类的 tell 方法时，我们可以将 Teacher 或 Student 的实例看作 SchoolMember 的实例。</p>
<p>同时，你会发现被调用的是子类型的 tell 方法，而不是 SchoolMember 的 tell 方法。理解这一问题的一种思路是 Python 总会从当前的实际类型中开始寻找方法，在本例中即是如此。如果它找不到对应的方法，它就会在该类所属的基本类中依顺序逐个寻找属于基本类的方法，这个基本类是在定义子类时后跟的元组指定的。</p>
<p>这里有一条有关术语的注释——如果继承元组（Inheritance Tuple）中有超过一个类，这种情况就会被称作多重继承（Multiple Inheritance）。</p>
<p>end 参数用在超类的 tell() 方法的 print 函数中，目的是打印一行并允许下一次打印在同一行继续。这是一个让 print 能够不在打印的末尾打印出 \n （新行换行符）符号的小窍门。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python网络编程</title>
    <url>/2021/03/08/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="udp程序流程"><a href="#udp程序流程" class="headerlink" title="udp程序流程"></a>udp程序流程</h3><p>udp是传输层的一种协议，不需要进行连接就可以用来发送和接收数据，但不保证数据的可靠传输。<br><img src="/2021/03/08/python网络编程/udp01.png" alt="avatar"></p>
<h3 id="udp服务端"><a href="#udp服务端" class="headerlink" title="udp服务端"></a>udp服务端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># 1. 创建套接字</span><br><span class="line">server_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">#2. bind绑定ip地址和端口，为元祖tuple类型</span><br><span class="line"># ip如果不指明，表示本机的任何一个ip地址</span><br><span class="line">server_addr = (&quot;&quot;, 8080)</span><br><span class="line">server_sock.bind(server_addr)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    # recv方法接收发送过来的数据</span><br><span class="line">    # 返回值为接收到的数据，参数（这里为1024）表示本次收取数据的最大字节数</span><br><span class="line">    # receive_data = server_sock.recv(1024)</span><br><span class="line">    # recvfrom与recv方法类似，不同的是可以将发送数据的客户端的地址也返回</span><br><span class="line">    receive_data, client_addr = server_sock.recvfrom(1024)</span><br><span class="line">    # 注意python3中收到的数据receive_data是bytes类型</span><br><span class="line">    # print(client_addr, &quot;: &quot;, receive_data)</span><br><span class="line">    # 将bytes数据转换为字符串类型</span><br><span class="line">    msg = receive_data.decode(&quot;utf-8&quot;)</span><br><span class="line">    # 将收到的数据显示输出</span><br><span class="line">    print(client_addr, &quot;: &quot;, msg)</span><br><span class="line">    # 我们假定如果客户端发送了quit，我们就关闭服务端的套接字（即关闭服务端）</span><br><span class="line">    if msg == &quot;quit&quot;:</span><br><span class="line">        server_sock.close()</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
<p>测试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -u 表示使用udp协议</span><br><span class="line"># nc -u 服务器ip 服务器端口</span><br><span class="line">nc -u 127.0.0.1 8080</span><br></pre></td></tr></table></figure></p>
<h3 id="udp客户端"><a href="#udp客户端" class="headerlink" title="udp客户端"></a>udp客户端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># 1. 创建套接字</span><br><span class="line">client_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"># 服务器地址</span><br><span class="line">server_addr = (&apos;127.0.0.1&apos;, 8080)</span><br><span class="line"></span><br><span class="line">data = input(&quot;请输入要发送的内容：&quot;)</span><br><span class="line"># 只要用户输入的数据不为空，就向服务器端发送</span><br><span class="line">while data:</span><br><span class="line">    # 2. 使用sendto方法向服务器发送数据</span><br><span class="line">    # sendto(bytes类型要发送的数据， 对方的地址)</span><br><span class="line">    client_sock.sendto(data.encode(&quot;utf-8&quot;), server_addr)</span><br><span class="line">    data = input(&quot;请输入要发送的内容：&quot;)</span><br><span class="line"></span><br><span class="line"># 当用户输入的数据为空（&quot;&quot;)时, 关闭客户端套接字</span><br><span class="line">client_sock.close()</span><br></pre></td></tr></table></figure>
<h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><p>TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。</p>
<p>tcp通信需要经过创建连接、数据传送、终止连接三个步骤。</p>
<p><strong>1. 面向连接</strong><br>通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。</p>
<p>双方间的数据传输都可以通过这一个连接进行。</p>
<p>完成数据交换后，双方必须断开此连接，以释放系统资源。</p>
<p>这种连接是一对一的，不适用于广播的应用程序，基于广播的应用程序适合使用UDP协议。</p>
<p><strong>2. 基于数据流（字节流)</strong></p>
<p>1）tcp数据流<br>发送端执行多次写操作（send）时，TCP模块先把这些数据放入TCP发送缓冲区中，当TCP模块真正可以发送数据时，才把TCP发送缓冲区等待发送的数据封装成一个或多个TCP报文段发出。</p>
<p>TCP会把数据流切分成一个或多个适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。</p>
<p><strong>TCP模块发出的报文的个数与应用程序的写操作（send）的次数没有固定的数量关系。</strong></p>
<p><strong>应用程序执行读操作的次数和TCP模块接收到的TCP报文的个数没有固定的数量关系。</strong></p>
<p><strong>发送端执行的写操作（send）次数与接收端执行的读操作（recv）次数没有数量对应关系。</strong></p>
<p><img src="/2021/03/08/python网络编程/tcp01.png" alt="avatar"></p>
<p>2）对比udp数据报<br>UDP发送端执行一次写操作（sendto)，UDP模块把它封装成一个UDP数据报并发送。</p>
<p>接收端针对每一个数据报执行读操作（recvfrom），否则就会发生丢包，并且如果用户没有指定足够的应用程序缓冲区来读取数据报，则UDP数据报就会被截断（接收不完整）。</p>
<p><img src="/2021/03/08/python网络编程/tcp02.png" alt="avatar"></p>
<p><strong>3. 可靠传输</strong><br>1）TCP采用发送应答机制</p>
<p>TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功</p>
<p>2）超时重传</p>
<p>发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。</p>
<p>TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。</p>
<p>3）错误校验</p>
<p>TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</p>
<p>4)流量控制和阻塞管理</p>
<p>流量控制用来避免主机发送得过快而使接收方来不及完全收下。</p>
<p><strong>TCP与UDP的不同点</strong><br>面向连接（确认有创建三方交握，连接已创建才作传输。）<br>有序数据传输<br>重发丢失的数据包<br>舍弃重复的数据包<br>无差错的数据传输<br>阻塞/流量控制</p>
<p><strong>建立连接（三次握手）</strong></p>
<p>TCP用三次握手（three-way handshake）过程创建一个连接。在连接创建过程中，很多参数要被初始化，例如序号被初始化以保证按序传输和连接的强壮性。</p>
<p><img src="/2021/03/08/python网络编程/tcp03.png" alt="avatar"></p>
<p>我们把tcp通信的报文称为段。<br>客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。</p>
<p>客户端发出段1，SYN位表示连接请求。序号是1000（实际是一个随机数，此处以1000为例），这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。</p>
<p>服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。</p>
<p>服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求SYN，序号是8000（实际也是一个随机数，此处以8000为例），同时声明最大尺寸为1024。</p>
<p>客户必须再次回应服务器端一个ACK报文，这是报文段3。</p>
<p>客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。</p>
<p>在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为“三次握手（three-way-handshake）”。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。</p>
<p>在TCP通讯中，如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含RST位的段给另一方。例如，服务器并没有任何进程使用8080端口，我们却用telnet客户端去连接它，服务器收到客户端发来的SYN段就会应答一个RST段，客户端的telnet程序收到RST段后报告错误Connection refused。</p>
<p><strong>数据传输</strong></p>
<ol>
<li>客户端发出段4，包含从序号1001开始的20个字节数据。</li>
<li>服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据。</li>
<li>客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。</li>
</ol>
<p>在数据传输过程中，ACK和确认序号是非常重要的，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。</p>
<p><strong>关闭连接（四次挥手）</strong></p>
<p>由于TCP连接是可以双向通信的（全双工），因此每个方向都必须单独进行关闭。</p>
<p>这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>客户端发出段7，FIN位表示关闭连接的请求。</p>
<p>服务器发出段8，应答客户端的关闭连接请求。</p>
<p>服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。</p>
<p>客户端发出段10，应答服务器的关闭连接请求。</p>
<p>建立连接的过程是三次握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。</p>
<p><strong>tcp程序流程</strong></p>
<p><img src="/2021/03/08/python网络编程/tcp04.png" alt="avatar"></p>
<p><strong>tcp服务器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># 创建socket</span><br><span class="line"># 注意TCP协议对应的为SOCK_STREAM 流式</span><br><span class="line">server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"># 绑定IP地址和端口</span><br><span class="line">address = (&quot;&quot;, 8000)</span><br><span class="line">server_sock.bind(address)</span><br><span class="line"></span><br><span class="line"># 让服务端的socket开启监听，等待客户端的连接请求</span><br><span class="line"># listen中的参数表示已经建立链接和半链接的总数</span><br><span class="line"># 如果当前已建立链接数和半链接数已达到设定值，那么新客户端不会立即connect成功，而是等待服务器能够处理时</span><br><span class="line">server_sock.listen(128)</span><br><span class="line"></span><br><span class="line"># 使用accept方法接收客户端的连接请求</span><br><span class="line"># 如果有新的客户端来连接服务器，那么就产生一个新的套接字专门为这个客户端服务</span><br><span class="line"># client_sock用来为这个客户端服务，与客户端形成一对一的连接</span><br><span class="line"># 而server_sock就可以省下来专门等待其他新客户端的连接请求</span><br><span class="line"># client_addr是请求连接的客户端的地址信息，为元祖，包含用户的IP和端口</span><br><span class="line">client_sock, client_addr = server_sock.accept()</span><br><span class="line">print(&quot;客户端%s:%s进行了连接!&quot; % client_addr)</span><br><span class="line"></span><br><span class="line"># recv()方法可以接收客户端发送过来的数据，指明最大收取1024个字节的数据</span><br><span class="line">recv_data = client_sock.recv(1024)</span><br><span class="line"># python3中收到的数据为bytes类型</span><br><span class="line"># recv_data.decode()将bytes类型转为str类型</span><br><span class="line">print(&quot;接收到的数据为：&quot;, recv_data.decode())</span><br><span class="line"></span><br><span class="line"># send()方法向客户端发送数据，要求发送bytes类型的数据</span><br><span class="line">client_sock.send(&quot;thank you!\n&quot;.encode())</span><br><span class="line"></span><br><span class="line"># 关闭与客户端连接的socket</span><br><span class="line"># 只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接</span><br><span class="line">client_sock.close()</span><br><span class="line"></span><br><span class="line"># 关闭服务端的监听socket</span><br><span class="line"># 要这个套接字关闭了，就意味着整个程序不能再接收任何新的客户端的连接</span><br><span class="line">server_sock.close()</span><br></pre></td></tr></table></figure>
<p><strong>tcp客户端</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># 创建客户端socket用以跟服务器连接通信</span><br><span class="line"># tcp协议对应为SOCK_STREAM</span><br><span class="line">client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"># connect方法用来连接服务器</span><br><span class="line">server_addr = (&quot;127.0.0.1&quot;, 8000)</span><br><span class="line">client_sock.connect(server_addr)</span><br><span class="line"></span><br><span class="line"># 提示用户输入要发送的数据</span><br><span class="line">msg = input(&quot;请输入要发送的内容：&quot;)</span><br><span class="line"># send()方法想服务器发送数据</span><br><span class="line">client_sock.send(msg.encode())</span><br><span class="line"></span><br><span class="line"># recv()接收对方发送过来的数据，最大接收1024个字节</span><br><span class="line">recv_data = client_sock.recv(1024)</span><br><span class="line">print(&quot;收到了服务器的回应信息：%s&quot; % recv_data.decode())</span><br><span class="line"></span><br><span class="line"># 关闭客户端套接字</span><br><span class="line">client_sock.close()</span><br></pre></td></tr></table></figure>
<p><strong>tcp十种状态</strong></p>
<p><img src="/2021/03/08/python网络编程/tcp05.png" alt="avatar"></p>
<p>LISTEN ：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</p>
<ul>
<li>SYN_SENT ：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</li>
<li>SYN_RCVD : 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</li>
<li>ESTABLISHED ：表示连接已经建立。</li>
<li>FIN_WAIT_1 : FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是： FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。 FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。</li>
<li>FIN_WAIT_2 ：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。</li>
<li>TIME_WAIT : 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li>
<li>CLOSE_WAIT : 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</li>
<li>LAST_ACK : 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</li>
</ul>
<p><strong>tcp的2MSL问题</strong></p>
<p><img src="/2021/03/08/python网络编程/tcp06.png" alt="avatar"></p>
<p>2MSL (Maximum Segment Lifetime)TIME_WAIT状态的存在有两个理由：</p>
<ol>
<li><p>让4次挥手关闭流程更加可靠；4次挥手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。</p>
</li>
<li><p>防止lost duplicate对后续新建正常链接的传输造成破坏。</p>
</li>
</ol>
<p>lost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。</p>
<p>另外一个概念叫做incarnation connection，指跟上次的socket pair一摸一样的新连接，叫做incarnation of previous connection。lost uplicate加上incarnation connection，则会对我们的传输造成致命的错误。</p>
<p>TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接；假设一个incarnation connection这时收到的seq=1000, 来了一个lost duplicate为seq=1000，len=1000, 则TCP认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。</p>
<p><strong>tcp服务器(REUSEADDR)</strong></p>
<p>为了解决服务器socket可能的2MSL延迟问题，我们可以为服务器socket设置SO_REUSEADDR选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># 创建socket</span><br><span class="line"># 注意TCP协议对应的为SOCK_STREAM 流式</span><br><span class="line">server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"># 使用setsockopt()方法设置socket的选项参数</span><br><span class="line"># SOL_SOCKET = Set Option Level _ SOCKET 设置选项级别为socket级</span><br><span class="line"># SO_REUSEADDR = Socket Option _ REUSEADDR 设置socket的选项参数为重用地址功能</span><br><span class="line"># 1 表示开启此选项功能，即开启重用地址功能</span><br><span class="line">server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line"></span><br><span class="line"># 绑定IP地址和端口</span><br><span class="line">address = (&quot;&quot;, 8000)</span><br><span class="line">server_sock.bind(address)</span><br><span class="line"></span><br><span class="line"># 让服务端的socket开启监听，等待客户端的连接请求</span><br><span class="line">server_sock.listen(128)</span><br><span class="line"></span><br><span class="line"># 使用accept方法接收客户端的连接请求</span><br><span class="line">client_sock, client_addr = server_sock.accept()</span><br><span class="line">print(&quot;客户端%s:%s进行了连接!&quot; % client_addr)</span><br><span class="line"></span><br><span class="line"># recv()方法可以接收客户端发送过来的数据，指明最大收取1024个字节的数据</span><br><span class="line">recv_data = client_sock.recv(1024)</span><br><span class="line">print(&quot;接收到的数据为：&quot;, recv_data.decode())</span><br><span class="line"></span><br><span class="line"># send()方法向客户端发送数据，要求发送bytes类型的数据</span><br><span class="line">client_sock.send(&quot;thank you!\n&quot;.encode())</span><br><span class="line"></span><br><span class="line"># 关闭与客户端连接的socket</span><br><span class="line">client_sock.close()</span><br><span class="line"></span><br><span class="line"># 关闭服务端的监听socket</span><br><span class="line">server_sock.close()</span><br></pre></td></tr></table></figure>
<p><strong>tcp长连接和短连接</strong></p>
<ul>
<li><p>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。</p>
</li>
<li><p>client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；</p>
</li>
</ul>
<p>如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p>
<ul>
<li><p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。</p>
</li>
<li><p>但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux磁盘与文件系统</title>
    <url>/2021/01/26/Linux%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本篇讲述磁盘管理相关的命令。计算机中需要持久化存储的数据一般是保存在硬盘等辅助存储器中。硬盘一般容量较大，为了便于管理和使用，可以将硬盘分成一到多个逻辑磁盘，称为分区；为使分区中的文件组织成操作系统能够处理的形式，需要对分区进行格式化(创建文件系统)；在linux中，对于格式化后的分区，还必须经过挂载(可简单理解为将分区关联至linux目录树中某个已知目录)之后才能使用。</p>
<h3 id="df-显示文件系统磁盘空间使用量"><a href="#df-显示文件系统磁盘空间使用量" class="headerlink" title="df 显示文件系统磁盘空间使用量"></a>df 显示文件系统磁盘空间使用量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos7 temp]# df -h</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/centos-root   49G   18G   31G   36% /</span><br><span class="line">devtmpfs                 3.9G     0  3.9G    0% /dev</span><br><span class="line">tmpfs                    3.9G     0  3.9G    0% /dev/shm</span><br><span class="line">tmpfs                    3.9G  367M  3.5G   10% /run</span><br><span class="line">tmpfs                    3.9G     0  3.9G    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                497M  125M  373M   26% /boot</span><br><span class="line">/dev/mapper/centos-home   24G  4.0G   20G   17% /home</span><br><span class="line">tmpfs                    783M     0  783M    0% /run/user/0</span><br></pre></td></tr></table></figure>
<p>选项-h作用是转换数字的显示单位(默认为KB)。<br>显示信息文件系统列下面带tmpfs字样的是虚拟内存文件系统(此处不做展开)。<br>文件系统/dev/mapper/centos-root的挂载点是/(根目录)，即通常所说的根分区(或根文件系统)；/dev/sda1(boot分区)中保存了内核映像和一些启动时需要的辅助文件；另外，还对用户家目录单独做了分区(/dev/mapper/centos-home)。<br>在linux中还可以做一个特殊的分区：swap分区(交换分区)。作用是：当系统的物理内存不够用时，会将物理内存中一部分暂时不使用的数据交换至swap分区中，当需要使用这些数据时，再从swap空间交换回内存空间。swap在功能上突破了物理内存的限制，使程序可以操纵大于实际物理内存的空间。但由于硬盘的速度远远低于内存，使swap只能作为物理内存的辅助。通常swap空间的大小是实际物理内存大小的1到2倍。使用命令free可以查看swap空间的大小。</p>
<p>选项-i显示inode信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos7 tmp]# df -i</span><br><span class="line">文件系统                   Inode 已用(I)  可用(I) 已用(I)% 挂载点</span><br><span class="line">/dev/mapper/centos-root 50425856   78822 50347034       1% /</span><br><span class="line">devtmpfs                  998721     391   998330       1% /dev</span><br><span class="line">tmpfs                    1001340       1  1001339       1% /dev/shm</span><br><span class="line">tmpfs                    1001340     490  1000850       1% /run</span><br><span class="line">tmpfs                    1001340      13  1001327       1% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                 512000     330   511670       1% /boot</span><br><span class="line">/dev/mapper/centos-home 24621056  190391 24430665       1% /home</span><br><span class="line">tmpfs                    1001340       1  1001339       1% /run/user/0</span><br></pre></td></tr></table></figure>
<p>这里显示的数字是该文件系统中inode数量的使用情况。</p>
<h3 id="fdisk-磁盘分区工具"><a href="#fdisk-磁盘分区工具" class="headerlink" title="fdisk 磁盘分区工具"></a>fdisk 磁盘分区工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk [options] [device...]</span><br></pre></td></tr></table></figure>
<p>选项-l表示列出分区表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos7 tmp]# fdisk -l /dev/sda</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sda：85.9 GB, 85899345920 字节，167772160 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x0001abbc</span><br><span class="line"></span><br><span class="line">   设备   Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     1026047      512000   83  Linux</span><br><span class="line">/dev/sda2         1026048   167772159    83373056   8e  Linux LVM</span><br><span class="line">[root@centos7 tmp]#</span><br></pre></td></tr></table></figure>
<p>当前机械硬盘中包含一到多个固定在主轴(spindle)上的盘片(platter)，盘片由硬质磁性合金材料构成。每张盘片有上下两个表面，每个表面都包含数量巨大的扇区(sector)，扇区是大小为512 byte的区块，这些区块均匀的分布于盘片的同心圆上，这些同心圆被称为磁道(track)。上千个磁道的宽度相当于人类头发的直径。</p>
<p>硬盘中使用固定于磁臂(disk arm)顶端的磁头(disk head 上下两面均有)读写盘面中的数据。硬盘不工作时，磁头停留在启停区(盘片上靠近主轴的区域)；启停区外是数据区，盘片最外围磁道称为0磁道；硬盘启动后，盘片会围绕主轴高速旋转，盘片旋转产生的气流相当强，足以使磁头托起，并与盘面保持一个微小的距离(大概相当于人类头发直径的千分之一)。磁臂摆动，可以将磁头移动至任意磁道上方。</p>
<p>当前硬盘转速大概在7200转/分钟到15000转/分钟左右。假设硬盘转速是10000转/分钟，则意味着，转一圈需要的时间是6ms。</p>
<p>所有盘面上的同一磁道构成一个圆柱，通常称做柱面(Cylinder)，系统将数据存储到磁盘上时，按柱面、磁头、扇区的方式进行，即最上方0磁头最外围0磁道第一个扇区开始写入，写满一个磁道之后，接着在同一柱面的下一个磁头继续写入。同一个柱面都写满之后才推进到内层的下一个柱面。</p>
<p>fdisk命令中device通常是/dev/hda、/dev/hdb….(IDE接口类型的硬盘设备名)或/dev/sda、/dev/sdb….(SCSI接口类型硬盘设备名)，表示整个硬盘，如果硬盘被分区，则在设备名后追加一个数字表示此设备的第几个分区。如上例中的/dev/sda1和/dev/sda2</p>
<p>硬盘磁头存取数据是以扇区(512bytes)为单位的(上例中Start和End列)，但操作系统存取数据是以块(Block)为单位的(注意：这里说的Block的大小不同于fdisk命令输出中的Blocks列，fdisk命令输出中Blocks列的大小为1024 bytes)；扇区是硬件级别的，Block是文件系统级别的，也就是说在创建文件系统(格式化)的时候才决定一个block的大小、数量。一个块的大小是一个扇区大小2的n次方倍，本例文件系统Block的默认大小为4096 bytes(格式化时可以指定为其他值)。</p>
<p>我们在252这台机器上新添加三块硬盘(每块200GB)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# ls -l /dev/sd[a-d]*</span><br><span class="line">brw-rw---- 1 root disk 8,  0 12月 13 09:49 /dev/sda</span><br><span class="line">brw-rw---- 1 root disk 8,  1 12月 13 09:49 /dev/sda1</span><br><span class="line">brw-rw---- 1 root disk 8,  2 12月 13 09:49 /dev/sda2</span><br><span class="line">brw-rw---- 1 root disk 8, 16 12月 13 09:49 /dev/sdb</span><br><span class="line">brw-rw---- 1 root disk 8, 32 12月 13 09:49 /dev/sdc</span><br><span class="line">brw-rw---- 1 root disk 8, 48 12月 13 09:49 /dev/sdd</span><br><span class="line">#这里看到除了原有被分过区的sda外，多出了设备sdb、sdc、sdd</span><br><span class="line">#这里的第五列由逗号分隔的两个数字组成，它们是内核用来识别具体设备的标识号</span><br></pre></td></tr></table></figure></p>
<p>下面使用fdisk命令对新磁盘进行分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# fdisk /dev/sdb</span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">使用磁盘标识符 0xc41dfd92 创建新的 DOS 磁盘标签。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：</span><br></pre></td></tr></table></figure>
<p>在提示符后输入m获取帮助信息（列出了在提示符后可使用的命令及其解释）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令(输入 m 获取帮助)：m</span><br><span class="line">命令操作</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create an IRIX (SGI) partition table</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   print this menu</span><br><span class="line">   n   add a new partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   print the partition table</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition&apos;s system id</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：</span><br></pre></td></tr></table></figure>
<p>命令n表示创建一个新分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p):</span><br></pre></td></tr></table></figure>
<p>此处可选项有两个，p表示主分区(primary)，e表示扩展分区(extended)，默认为主分区。</p>
<p>每块硬盘分区后，位于0磁头0柱面1扇区的是一个特殊区域，称为MBR(Main Boot Record 主引导记录区)，其中前446字节是Bootloader(引导加载程序)，之后的64字节是DPT(Disk Partition Table 硬盘分区表)，最后两个字节的Magic Number(硬盘有效标志)。</p>
<p>DPT中记录了此块硬盘有哪些分区，由于其大小的限制，使得分区表只能包含4条记录，可以是一到四个主分区或一个扩展分区和一到三个主分区。其中扩展分区可以再分区，称为逻辑分区。</p>
<p>我们选择默认的主分区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select (default p): </span><br><span class="line">Using default response p</span><br><span class="line">分区号 (1-4，默认 1)：</span><br><span class="line">起始 扇区 (2048-419430399，默认为 2048)：</span><br><span class="line">将使用默认值 2048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-419430399，默认为 419430399)：+100G</span><br><span class="line">分区 1 已设置为 Linux 类型，大小设为 100 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：</span><br></pre></td></tr></table></figure>
<p>每一步骤都有相应提示，可以被使用的扇区从2048号开始(前面的扇区包括MBR用做其他用途)，分区结束扇区的指定可以是扇区号，也可以是+size这样的格式。这里我们指定分区大小为100G</p>
<p>使用p命令打印分区信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：214.7 GB, 214748364800 字节，419430400 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0xc41dfd92</span><br><span class="line"></span><br><span class="line">   设备   Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048   209717247   104857600   83  Linux</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：</span><br></pre></td></tr></table></figure></p>
<p>注意这里的显示的不同，Boot列如果有*标志，表示此分区为boot分区。Id列表示分区类型，可以使用命令l列出所有支持的类型，其中82表示linux swap，83表示linux默认分区类型，8e表示linux lvm(后述)。</p>
<p>然后我们将信息保存：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令(输入 m 获取帮助)：w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">正在同步磁盘。</span><br><span class="line">[root@idc-v-71252 ~]#</span><br></pre></td></tr></table></figure></p>
<h3 id="mkfs-创建文件系统"><a href="#mkfs-创建文件系统" class="headerlink" title="mkfs 创建文件系统"></a>mkfs 创建文件系统</h3><p>选项-t可以指定文件系统类型(包括ext3 ext4 btrfs xfs reiserfs等)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# mkfs -t ext4 /dev/sdb1 #或者直接执行 mkfs.ext4 /dev/sdb1</span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">文件系统标签=</span><br><span class="line">OS type: Linux</span><br><span class="line">块大小=4096 (log=2)</span><br><span class="line">分块大小=4096 (log=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">6553600 inodes, 26214400 blocks</span><br><span class="line">1310720 blocks (5.00%) reserved for the super user</span><br><span class="line">第一个数据块=0</span><br><span class="line">Maximum filesystem blocks=2174746624</span><br><span class="line">800 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, </span><br><span class="line">        4096000, 7962624, 11239424, 20480000, 23887872</span><br><span class="line"></span><br><span class="line">Allocating group tables: 完成                            </span><br><span class="line">正在写入inode表: 完成                            </span><br><span class="line">Creating journal (32768 blocks): 完成</span><br><span class="line">Writing superblocks and filesystem accounting information: 完成   </span><br><span class="line"></span><br><span class="line">[root@idc-v-71252 ~]#</span><br></pre></td></tr></table></figure>
<p>这样，我们就把刚刚分的区格式化成了ext4文件系统，输出信息中显示了inode和block数量等信息。</p>
<h3 id="mount-挂载文件系统"><a href="#mount-挂载文件系统" class="headerlink" title="mount 挂载文件系统"></a>mount 挂载文件系统</h3><p>将格式化好的文件系统挂载至/root/temp/tmp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 tmp]# mount /dev/sdb1 /root/temp/tmp</span><br><span class="line">[root@idc-v-71252 tmp]# df -h</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/centos-root   49G   14G   35G   28% /</span><br><span class="line">devtmpfs                 3.9G     0  3.9G    0% /dev</span><br><span class="line">tmpfs                    3.9G     0  3.9G    0% /dev/shm</span><br><span class="line">tmpfs                    3.9G  8.5M  3.9G    1% /run</span><br><span class="line">tmpfs                    3.9G     0  3.9G    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                497M  170M  328M   35% /boot</span><br><span class="line">/dev/mapper/centos-home   24G   16G  7.6G   68% /home</span><br><span class="line">tmpfs                    799M     0  799M    0% /run/user/0</span><br><span class="line">/dev/sdb1                 99G   61M   94G    1% /root/temp/tmp</span><br><span class="line">[root@idc-v-71252 tmp]#</span><br></pre></td></tr></table></figure>
<p>可以看到新分区已经可以使用了，在格式化时，系统会将磁盘上一定空间(此处是5%)保留做其他用途，可以使用命令dumpe2fs /dev/sdb1 2&gt;/dev/null|grep ‘Reserved block count’查看保留块数量。</p>
<p>这样挂载的分区只是临时有效，当系统重启时，并不会自动挂载该分区。如需要永久生效，可以将分区信息写入分区配置文件/etc/fstab<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# cat /etc/fstab </span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># /etc/fstab</span><br><span class="line"># Created by anaconda on Fri Jan 15 00:59:59 2016</span><br><span class="line">#</span><br><span class="line"># Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;</span><br><span class="line"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span><br><span class="line">#</span><br><span class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</span><br><span class="line">UUID=10205c20-bd44-4991-8c84-7b38db63a581 /boot                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-home /home                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-swap swap                    swap    defaults        0 0</span><br></pre></td></tr></table></figure></p>
<p>此文件中记录了原有分区及其挂载信息，#开头的行为注释行，其余行被分为6列：<br>第一列表示文件系统<br>第二列是挂载点<br>第三列为文件系统类型<br>第四列为选项<br>第五列表示是否对该文件系统使用dump工具备份，0表示不备份<br>第六列表示是否使用fsck工具对该文件系统做定时检查，0表示不检查</p>
<p>在文件中追加如下信息后，系统重启时新分区也会被自动挂载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/dev/sdb1 /root/temp/tmp ext4 defaults 0 0</span><br></pre></td></tr></table></figure>
<p>在使用mount命令挂载时，可以使用选项-o options指定挂载选项(/etc/fstab中第四列)<br>如对已挂载的新分区重新以只读方式挂载：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 home]# mount -o remount,ro /dev/sdb1</span><br><span class="line">[root@idc-v-71252 home]# cd /root/temp/tmp</span><br><span class="line">[root@idc-v-71252 tmp]# touch 1</span><br><span class="line">touch: 无法创建&quot;1&quot;: 只读文件系统</span><br><span class="line">[root@idc-v-71252 tmp]#</span><br></pre></td></tr></table></figure></p>
<p>此时再在目录/root/temp/tmp中创建文件时显示报错：只读文件系统<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 tmp]# mount -o remount,rw /dev/sdb1</span><br><span class="line">[root@idc-v-71252 tmp]# touch 2</span><br><span class="line">[root@idc-v-71252 tmp]# ls</span><br><span class="line">2  lost+found</span><br><span class="line">[root@idc-v-71252 tmp]# 重新以读写方式挂载后可以创建文件</span><br></pre></td></tr></table></figure></p>
<p>配置文件中的defaults指的是选项：rw, suid, dev, exec, auto, nouser, 和 async. 它们的意思请查看mount的man手册<br>选项-a表示读取配置文件中所有记录并重新挂载<br>选项-B或–bind可以使一个目录挂载至另一个目录<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 tmp]# ls -l /opt/</span><br><span class="line">总用量 0</span><br><span class="line">[root@idc-v-71252 tmp]# </span><br><span class="line">[root@idc-v-71252 tmp]# mount --bind /root/temp/tmp /opt</span><br><span class="line">[root@idc-v-71252 tmp]# ls /opt -l</span><br><span class="line">总用量 16</span><br><span class="line">-rw-r--r-- 1 root root     0 12月 13 14:44 2</span><br><span class="line">drwx------ 2 root root 16384 12月 13 12:54 lost+found</span><br><span class="line">[root@idc-v-71252 tmp]#</span><br></pre></td></tr></table></figure></p>
<p>这样挂载的目录使用df命令并不能查看到，可以使用mount命令查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 tmp]# mount | grep /dev/sdb1</span><br><span class="line">/dev/sdb1 on /root/temp/tmp type ext4 (rw,relatime,data=ordered)</span><br><span class="line">/dev/sdb1 on /opt type ext4 (rw,relatime,data=ordered)</span><br></pre></td></tr></table></figure>
<p>选项-t表示指定文件系统类型，如挂载光盘：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos7 tmp]# mount -t iso9660 /dev/cdrom /mnt</span><br><span class="line">mount: /dev/sr0 写保护，将以只读方式挂载</span><br><span class="line">[root@centos7 tmp]# </span><br><span class="line">#或者挂载NFS文件系统(x.x.x.x是NFS服务器IP地址)</span><br><span class="line">mount -t nfs x.x.x.x:/src_dir /path/to/local/dest_dir</span><br></pre></td></tr></table></figure>
<h3 id="umount-卸载文件系统"><a href="#umount-卸载文件系统" class="headerlink" title="umount 卸载文件系统"></a>umount 卸载文件系统</h3><p>卸载时既可以指定设备名也可以指定挂载点，当文件系统内有进程正在使用某文件时，卸载会报错：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# umount /root/temp/tmp</span><br><span class="line">umount: /root/temp/tmp：目标忙。</span><br><span class="line">        (有些情况下通过 lsof(8) 或 fuser(1) 可以</span><br><span class="line">         找到有关使用该设备的进程的有用信息)</span><br><span class="line">[root@idc-v-71252 ~]#</span><br></pre></td></tr></table></figure></p>
<p>此时可使用lsof或fuser找出进程(见这里)，停止该进程之后再卸载即可。</p>
<p>如果是卸载光盘还可以用eject命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centos7 tmp]# eject</span><br></pre></td></tr></table></figure></p>
<h3 id="fsck-检查并修复文件系统"><a href="#fsck-检查并修复文件系统" class="headerlink" title="fsck 检查并修复文件系统"></a>fsck 检查并修复文件系统</h3><p>可以使用fsck命令检查分区是否正常，需要在卸载的状态检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 temp]# umount /dev/sdb1</span><br><span class="line">[root@idc-v-71252 temp]# fsck /dev/sdb1</span><br><span class="line">fsck，来自 util-linux 2.23.2</span><br><span class="line">e2fsck 1.42.9 (28-Dec-2013)</span><br><span class="line">/dev/sdb1: clean, 12/6553600 files, 459544/26214400 blocks</span><br></pre></td></tr></table></figure>
<p>直接执行命令时，如果检测到受损，会有交互式提示询问是否进行修复坏块<br>选项-a表示不询问直接修复<br>选项-y表示总是对交互式询问输入yes</p>
<h3 id="mkswap-创建swap分区"><a href="#mkswap-创建swap分区" class="headerlink" title="mkswap 创建swap分区"></a>mkswap 创建swap分区</h3><p>linux的swap分区可以用磁盘分区做，也可以用文件做，当前系统的swap使用的是分区。下面举一个使用文件创建swap分区的例子<br>首先使用命令dd生成一个大小为8G的文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 tmp]# dd if=/dev/zero of=swapfile bs=1024K count=8192</span><br><span class="line">记录了8192+0 的读入</span><br><span class="line">记录了8192+0 的写出</span><br><span class="line">8589934592字节(8.6 GB)已复制，35.1683 秒，244 MB/秒</span><br><span class="line">[root@idc-v-71252 tmp]#</span><br><span class="line">#命令会在当前目录下创建一个文件swapfile</span><br><span class="line">#if表示指定读取的文件或设备</span><br><span class="line">#of表示指定写入的文件或设备</span><br><span class="line">#bs表示一次读出或写入的大小</span><br><span class="line">#count表示读出或写入次数</span><br><span class="line">[root@idc-v-71252 tmp]# du -sh swapfile </span><br><span class="line">8.0G    swapfile</span><br></pre></td></tr></table></figure></p>
<p>创建swap分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 tmp]# mkswap swapfile </span><br><span class="line">正在设置交换空间版本 1，大小 = 8388604 KiB</span><br><span class="line">无标签，UUID=84fbe922-9444-482b-aa55-631ce72161c0</span><br></pre></td></tr></table></figure>
<h3 id="swapon-swapoff-启用-停用swap文件或设备"><a href="#swapon-swapoff-启用-停用swap文件或设备" class="headerlink" title="swapon/swapoff 启用/停用swap文件或设备"></a>swapon/swapoff 启用/停用swap文件或设备</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 tmp]# swapon swapfile</span><br><span class="line">swapon: /root/temp/tmp/swapfile：不安全的权限 0644，建议使用 0600。</span><br><span class="line">[root@idc-v-71252 tmp]# free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7983         115          53           8        7813        7794</span><br><span class="line">Swap:         16255           0       16255</span><br><span class="line">#此处看到swap分区已被扩大</span><br><span class="line">[root@idc-v-71252 tmp]# swapoff swapfile</span><br><span class="line">[root@idc-v-71252 tmp]# free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7983         109          59           8        7813        7800</span><br><span class="line">Swap:          8063           0        8063</span><br></pre></td></tr></table></figure>
<h3 id="parted-磁盘分区工具"><a href="#parted-磁盘分区工具" class="headerlink" title="parted 磁盘分区工具"></a>parted 磁盘分区工具</h3><p>前面所述的MBR中的分区表不支持大于2TB以上的分区，为了解决这一限制和MBR的其它不足，出现了GTP(全局唯一标识分区表 GUID Partition Table)，是一种磁盘的分区表的结构布局的标准，属于UEFI(统一可扩展固件接口)标准的一部分。需要使用命令parted划分支持GTP的分区(可兼容MBR分区)。</p>
<p>直接使用命令parted时会进入交互界面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# parted /dev/sdb</span><br><span class="line">GNU Parted 3.1</span><br><span class="line">使用 /dev/sdb</span><br><span class="line">Welcome to GNU Parted! Type &apos;help&apos; to view a list of commands.</span><br><span class="line">(parted)</span><br></pre></td></tr></table></figure>
<p>可以在提示符后输入help显示可用命令列表(命令可简写)<br>命令print(简写p)表示打印分区表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(parted) p                                                                </span><br><span class="line">Model: VMware Virtual disk (scsi)</span><br><span class="line">Disk /dev/sdb: 215GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End    Size   Type     File system  标志</span><br><span class="line"> 1      1049kB  107GB  107GB  primary  ext4</span><br><span class="line"></span><br><span class="line">(parted)</span><br></pre></td></tr></table></figure>
<p>命令quit表示退出交互界面<br>选项-s表示非交互模式，此时命令写在后面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# parted -s /dev/sdb print</span><br><span class="line">Model: VMware Virtual disk (scsi)</span><br><span class="line">Disk /dev/sdb: 215GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End    Size   Type     File system  标志</span><br><span class="line"> 1      1049kB  107GB  107GB  primary  ext4</span><br><span class="line"></span><br><span class="line">[root@idc-v-71252 ~]# fdisk -l /dev/sdb1</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb1：107.4 GB, 107374182400 字节，209715200 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line"></span><br><span class="line">[root@idc-v-71252 ~]#</span><br></pre></td></tr></table></figure>
<p>Partition Table后的msdos表示为MBR分区，之所以两个命令中sdb1分区大小显示为107G而不是100G是因为在进行计算时使用1000 bytes作为1KB计数。</p>
<p>不能在已经做MBR分区的硬盘上做GTP分区，重做会导致原有分区被格式化。</p>
<p>这里在新磁盘/dev/sdc上做GTP分区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# parted /dev/sdc</span><br><span class="line">GNU Parted 3.1</span><br><span class="line">使用 /dev/sdc</span><br><span class="line">Welcome to GNU Parted! Type &apos;help&apos; to view a list of commands.</span><br><span class="line">(parted)</span><br></pre></td></tr></table></figure>
<p>注意交互模式与fdisk命令不同，parted的命令一旦按回车确认，命令就马上执行，对磁盘的更改就立即生效。</p>
<p>命令mklabel指定分区格式(msdos或gtp)，如果格式未知，使用print命令时会报错：错误: /dev/sdc: unrecognised disk label</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(parted) mklabel gpt</span><br></pre></td></tr></table></figure>
<p>命令mkpart表示创建新分区，后面接分区类型(主分区还是扩展分区)、文件系统类型(ext4等，可省略)、起始点、结束点。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(parted) mkpart primary 0KB 100GB</span><br><span class="line">警告: You requested a partition from 0.00B to 100GB (sectors 0..195312500).</span><br><span class="line">The closest location we can manage is 17.4kB to 100GB (sectors 34..195312500).</span><br><span class="line">Is this still acceptable to you?</span><br><span class="line">是/Yes/否/No? yes                                                         </span><br><span class="line">警告: The resulting partition is not properly aligned for best performance.</span><br><span class="line">忽略/Ignore/放弃/Cancel? ignore                                           </span><br><span class="line">(parted) p                                                                </span><br><span class="line">Model: VMware Virtual disk (scsi)</span><br><span class="line">Disk /dev/sdc: 215GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End    Size   File system  Name     标志</span><br><span class="line"> 1      17.4kB  100GB  100GB               primary</span><br></pre></td></tr></table></figure></p>
<p>命令rm表示删除分区，后面接分区号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(parted) rm 1                                                             </span><br><span class="line">(parted) p                                                                </span><br><span class="line">Model: VMware Virtual disk (scsi)</span><br><span class="line">Disk /dev/sdc: 215GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start  End  Size  File system  Name  标志</span><br><span class="line"></span><br><span class="line">(parted)</span><br></pre></td></tr></table></figure>
<p>下面使用非交互模式继续</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# parted -s /dev/sdc mkpart primary ext4 18KB 100GB </span><br><span class="line">警告: The resulting partition is not properly aligned for best performance.</span><br><span class="line">[root@idc-v-71252 ~]# parted -s /dev/sdc print</span><br><span class="line">Model: VMware Virtual disk (scsi)</span><br><span class="line">Disk /dev/sdc: 215GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End    Size   File system  Name     标志</span><br><span class="line"> 1      17.9kB  100GB  100GB               primary</span><br></pre></td></tr></table></figure>
<p>这里使用1000 bytes作为1KB计数<br>格式化并挂载(部分输出略)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 temp]# mkfs.ext4 /dev/sdc1</span><br><span class="line">[root@idc-v-71252 temp]# mount /dev/sdc1 /root/temp/tmp_1</span><br><span class="line">[root@idc-v-71252 temp]# df -h|grep ^/dev</span><br><span class="line">/dev/mapper/centos-root   49G   22G   27G   44% /</span><br><span class="line">/dev/sda1                497M  170M  328M   35% /boot</span><br><span class="line">/dev/mapper/centos-home   24G   16G  7.6G   68% /home</span><br><span class="line">/dev/sdb1                 99G   61M   94G    1% /root/temp/tmp</span><br><span class="line">/dev/sdc1                 92G   61M   87G    1% /root/temp/tmp_1</span><br></pre></td></tr></table></figure></p>
<p>最后再用parted做一个MBR扩展分区，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parted -s /dev/sdd mklabel msdos</span><br><span class="line">parted -s /dev/sdd mkpart extended 100GB 100%</span><br><span class="line">parted -s /dev/sdd mkpart logical 100GB 200GB</span><br></pre></td></tr></table></figure>
<p>结果显示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 temp]# parted -s /dev/sdd print</span><br><span class="line">Model: VMware Virtual disk (scsi)</span><br><span class="line">Disk /dev/sdd: 215GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start  End    Size   Type      File system  标志</span><br><span class="line"> 1      100GB  215GB  115GB  extended               lba</span><br><span class="line"> 5      100GB  200GB  100GB  logical</span><br><span class="line"></span><br><span class="line">[root@idc-v-71252 temp]# fdisk -l /dev/sdd</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdd：214.7 GB, 214748364800 字节，419430400 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x0006d495</span><br><span class="line"></span><br><span class="line">     设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdd1       195311616   419430399   112059392    f  W95 Ext&apos;d (LBA)</span><br><span class="line">/dev/sdd5       195313664   390625279    97655808   83  Linux</span><br></pre></td></tr></table></figure>
<p>格式化及挂载(省略部分输出)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 temp]# mkfs.ext4 /dev/sdd5</span><br><span class="line">[root@idc-v-71252 temp]# mount /dev/sdd5 /root/temp/tmp_2</span><br><span class="line">[root@idc-v-71252 temp]# df -h|grep ^/dev</span><br><span class="line">/dev/mapper/centos-root   49G   22G   27G   44% /</span><br><span class="line">/dev/sda1                497M  170M  328M   35% /boot</span><br><span class="line">/dev/mapper/centos-home   24G   16G  7.6G   68% /home</span><br><span class="line">/dev/sdb1                 99G   61M   94G    1% /root/temp/tmp</span><br><span class="line">/dev/sdc1                 92G   61M   87G    1% /root/temp/tmp_1</span><br><span class="line">/dev/sdd5                 92G   61M   87G    1% /root/temp/tmp_2</span><br></pre></td></tr></table></figure>
<p>这些新分区都可以写入配置文件/etc/fstab中实现重启后自动挂载</p>
<h3 id="LVM-逻辑卷管理"><a href="#LVM-逻辑卷管理" class="headerlink" title="LVM 逻辑卷管理"></a>LVM 逻辑卷管理</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>物理存储介质(The physical media)：指的是系统的存储设备，如上面制作的分区/dev/sdb1、/dev/sdc1、/dev/sdd5</p>
<p>物理卷(PV: Physical Volume)：相当于物理存储介质，但添加了与LVM相关的管理参数。</p>
<p>卷组(VG: Volume Group)：由一个或多个物理卷组成。</p>
<p>逻辑卷(LV: Logical Volume)：在卷组的基础上划分的逻辑分区(文件系统)。</p>
<p>PE(physical extent)：每一个物理卷被划分为称为PE的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是可配置的，默认为4MB。</p>
<p>LE(logical extent)：逻辑卷也被划分为被称为LE的可被寻址的基本单位。在同一个卷组中，LE的大小和PE是相同的，并且一一对应</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、创建分区<br>可以使用fdisk或parted进行分区，和前面举例中的区别仅仅是分区类型要选8e。这里将三块新硬盘的剩余空间做成LVM分区，parted方式(仅举一例，其余略)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parted -s /dev/sdb mkpart primary 107GB 100%</span><br><span class="line">parted -s /dev/sdb toggle 2 lvm  #表示将第二个分区定义为lvm类型(8e)</span><br></pre></td></tr></table></figure></p>
<p>2、 创建PV<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# pvcreate /dev/sd[bcd]2</span><br><span class="line">  Physical volume &quot;/dev/sdb2&quot; successfully created</span><br><span class="line">  Physical volume &quot;/dev/sdc2&quot; successfully created</span><br><span class="line">  Physical volume &quot;/dev/sdd2&quot; successfully created</span><br><span class="line">[root@idc-v-71252 ~]# </span><br><span class="line">#查看</span><br><span class="line">[root@idc-v-71252 ~]# pvscan </span><br><span class="line">  PV /dev/sda2   VG centos   lvm2 [79.51 GiB / 64.00 MiB free]</span><br><span class="line">  PV /dev/sdb2               lvm2 [100.00 GiB]</span><br><span class="line">  PV /dev/sdc2               lvm2 [106.87 GiB]</span><br><span class="line">  PV /dev/sdd2               lvm2 [93.13 GiB]</span><br><span class="line">  Total: 4 [379.50 GiB] / in use: 1 [79.51 GiB] / in no VG: 3 [300.00 GiB]</span><br></pre></td></tr></table></figure></p>
<p>3、 创建VG<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# vgcreate -s 8M test_lvm /dev/sd[bcd]2</span><br><span class="line">  Volume group &quot;test_lvm&quot; successfully created</span><br><span class="line">#这里使用选项-s指定PE大小为8M，卷组起名为test_lvm</span><br><span class="line">#查看</span><br><span class="line">[root@idc-v-71252 ~]# vgscan </span><br><span class="line">  Reading all physical volumes.  This may take a while...</span><br><span class="line">  Found volume group &quot;centos&quot; using metadata type lvm2</span><br><span class="line">  Found volume group &quot;test_lvm&quot; using metadata type lvm2</span><br></pre></td></tr></table></figure></p>
<p>4、创建LV</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# lvcreate -n test_1 -L 50G test_lvm </span><br><span class="line">  Logical volume &quot;test_1&quot; created.</span><br><span class="line">[root@idc-v-71252 ~]# </span><br><span class="line">#选项-n指定LV名为test_1，-L指定大小，也可以用选项-l指定LE的数量</span><br><span class="line">#查看</span><br><span class="line">[root@idc-v-71252 ~]# lvscan </span><br><span class="line">  ACTIVE            &apos;/dev/centos/swap&apos; [7.88 GiB] inherit</span><br><span class="line">  ACTIVE            &apos;/dev/centos/home&apos; [23.48 GiB] inherit</span><br><span class="line">  ACTIVE            &apos;/dev/centos/root&apos; [48.09 GiB] inherit</span><br><span class="line">  ACTIVE            &apos;/dev/test_lvm/test_1&apos; [50.00 GiB] inherit</span><br><span class="line">[root@idc-v-71252 ~]#</span><br></pre></td></tr></table></figure>
<p>5、格式化及挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在这里进行格式化，第一步分区之后并不需要格式化。</span><br><span class="line">#这里我们格式化成xfs格式</span><br><span class="line">[root@idc-v-71252 ~]# mkfs.xfs /dev/test_lvm/test_1</span><br><span class="line">meta-data=/dev/test_lvm/test_1   isize=256    agcount=4, agsize=3276800 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=0        finobt=0</span><br><span class="line">data     =                       bsize=4096   blocks=13107200, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=0</span><br><span class="line">log      =internal log           bsize=4096   blocks=6400, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">[root@idc-v-71252 ~]# mount /dev/test_lvm/test_1 /root/temp/test_1</span><br><span class="line">[root@idc-v-71252 ~]# df -h|grep ^/dev</span><br><span class="line">/dev/mapper/centos-root       49G   22G   27G   44% /</span><br><span class="line">/dev/sda1                    497M  170M  328M   35% /boot</span><br><span class="line">/dev/mapper/centos-home       24G   16G  7.6G   68% /home</span><br><span class="line">/dev/sdb1                     99G   61M   94G    1% /root/temp/tmp</span><br><span class="line">/dev/sdc1                     92G   61M   87G    1% /root/temp/tmp_1</span><br><span class="line">/dev/sdd5                     92G   61M   87G    1% /root/temp/tmp_2</span><br><span class="line">/dev/mapper/test_lvm-test_1   50G   33M   50G    1% /root/temp/test_1</span><br></pre></td></tr></table></figure>
<p>这里文件系统之所以显示为/dev/mapper/….是因为内核利用Mapper Device机制将设备做了映射：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@idc-v-71252 ~]# ls -l /dev/mapper/test_lvm-test_1</span><br><span class="line">lrwxrwxrwx 1 root root 7 12月 14 09:58 /dev/mapper/test_lvm-test_1 -&gt; ../dm-3</span><br><span class="line">[root@idc-v-71252 ~]# ls -l /dev/test_lvm/test_1</span><br><span class="line">lrwxrwxrwx 1 root root 7 12月 14 09:58 /dev/test_lvm/test_1 -&gt; ../dm-3</span><br></pre></td></tr></table></figure></p>
<p>实际上/dev/test_lvm/test_1和/dev/mapper/test_lvm-test_1指向了同一个设备/dev/dm-3(在配置文件/etc/fstab中写任意一种都可以)，这里就不对映射机制做详细展开了。</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>前面举例中说到了几个创建和查看命令，除此之外，LVM还有一系列的命令，它们都以pv/vg/lv开头，所起的作用大多是增加、删除、扩充、缩减、查看、改变等等。</p>
<p>创建命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvcreate vgcreate lvcreate</span><br></pre></td></tr></table></figure></p>
<p>查看命令分三类，显示信息侧重或详细程度不同：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvs pvscan pvdisplay</span><br><span class="line">vgs vgscan vgdisplay</span><br><span class="line">lvs lvscan lvdisplay</span><br></pre></td></tr></table></figure></p>
<p>改变属性(分别改变本层次上对象的属性)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvchange vgchange lvchange</span><br></pre></td></tr></table></figure></p>
<p>扩容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vgextend lvextend</span><br></pre></td></tr></table></figure></p>
<p>缩减(慎用)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vgreduce lvreduce</span><br></pre></td></tr></table></figure></p>
<p>改名<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vgrename lvrename</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
